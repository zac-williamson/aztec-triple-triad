{"noir_version":"1.0.0-beta.18+2db78f8894936db05c53430f364360ac9cc5c61f","hash":"14612436940291685191","abi":{"parameters":[{"name":"card_commit_1","type":{"kind":"field"},"visibility":"public"},{"name":"card_commit_2","type":{"kind":"field"},"visibility":"public"},{"name":"start_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"end_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"game_ended","type":{"kind":"field"},"visibility":"public"},{"name":"winner_id","type":{"kind":"field"},"visibility":"public"},{"name":"current_player","type":{"kind":"field"},"visibility":"private"},{"name":"card_id","type":{"kind":"field"},"visibility":"private"},{"name":"row","type":{"kind":"field"},"visibility":"private"},{"name":"col","type":{"kind":"field"},"visibility":"private"},{"name":"board_before","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"board_after","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_before","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_after","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"current_turn_before","type":{"kind":"field"},"visibility":"private"},{"name":"player_card_ids","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"blinding_factor","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"4487758756370642245":{"error_kind":"string","string":"Start state hash mismatch"},"5101543514421470893":{"error_kind":"string","string":"Card already placed on board"},"6511982886681245134":{"error_kind":"string","string":"Placed card not in committed hand"},"7317384265632011736":{"error_kind":"string","string":"Cell not empty (owner)"},"7370811245087594529":{"error_kind":"string","string":"Captured cell owner not updated"},"7520349170859696597":{"error_kind":"string","string":"Card not placed correctly"},"8084300406162371689":{"error_kind":"string","string":"Player 2 card commit mismatch"},"8749084135167576643":{"error_kind":"string","string":"Invalid player"},"9296992678443765102":{"error_kind":"string","string":"Non-placed cell card_id changed"},"9336663072722308931":{"error_kind":"string","string":"Owner not set correctly"},"9573161043312537276":{"error_kind":"string","string":"Should be a draw"},"9697039476693520435":{"error_kind":"string","string":"Player 2 should be winner"},"9715689440484907290":{"error_kind":"string","string":"Game should have ended"},"9915128275385804551":{"error_kind":"string","string":"Player 1 should be winner"},"11936972275297119974":{"error_kind":"string","string":"Invalid card ID for rank lookup"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12724384224350165649":{"error_kind":"string","string":"End state hash mismatch"},"14336771847768869760":{"error_kind":"string","string":"Not this player's turn"},"14904510168980638594":{"error_kind":"string","string":"Cell not empty"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15156018542597224275":{"error_kind":"string","string":"Player 1 card commit mismatch"},"15353634778740263988":{"error_kind":"string","string":"Game should not have ended"},"15521846062275453407":{"error_kind":"string","string":"Col out of bounds"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16309609255298369368":{"error_kind":"string","string":"Row out of bounds"},"16422110396685134300":{"error_kind":"string","string":"P1 score mismatch"},"17174323770794875209":{"error_kind":"string","string":"Non-captured cell owner changed"},"18125798406593280834":{"error_kind":"string","string":"No winner yet"},"18256603403857491958":{"error_kind":"string","string":"P2 score mismatch"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    crate::assert_constant(separator);\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"/// Game Move circuit.\n/// Proves that a game move is valid: one card placed from correct player,\n/// board state correctly updated with capture logic.\n///\n/// Public inputs:\n///   card_commit_1, card_commit_2 - player card commitments (poseidon2 hash)\n///   start_state_hash - hash of board state before this move\n///   end_state_hash - hash of board state after this move\n///   game_ended - 1 if game over, 0 otherwise\n///   winner_id - 0=not ended, 1=player1 wins, 2=player2 wins, 3=draw\n///\n/// The circuit verifies:\n/// 1. The placed card is in the current player's committed hand (card_commit binding)\n/// 2. Capture logic: rank comparison for all adjacent opponent cells\n/// 3. Non-placed, non-captured cells are unchanged between board_before/board_after\n/// 4. Scores are consistent with board ownership + hand counts\n/// 5. Game end detection and winner determination\n\n/// Board cell: each cell is (card_id, owner) where owner 0=empty, 1=player1, 2=player2\n\nuse poseidon::poseidon2::Poseidon2;\n\n// ====================== CARD DATABASE ======================\n/// Hardcoded card rank database: 50 cards with ranks [top, right, bottom, left].\nfn get_card_ranks(card_id: u32) -> [Field; 4] {\n    assert((card_id >= 1) & (card_id <= 50), \"Invalid card ID for rank lookup\");\n\n    // Level 1 - Common (IDs 1-10)\n    if card_id == 1 { [1, 4, 1, 5] }         // Mudwalker\n    else if card_id == 2 { [5, 1, 1, 3] }    // Blushy\n    else if card_id == 3 { [1, 3, 3, 5] }    // Snowdrop\n    else if card_id == 4 { [6, 1, 1, 2] }    // Sunny\n    else if card_id == 5 { [2, 3, 1, 5] }    // Inkwell\n    else if card_id == 6 { [2, 1, 4, 4] }    // Stripes\n    else if card_id == 7 { [1, 5, 4, 1] }    // Barkeeper\n    else if card_id == 8 { [3, 1, 5, 2] }    // Dotty\n    else if card_id == 9 { [2, 1, 6, 1] }    // Penny\n    else if card_id == 10 { [4, 3, 2, 4] }   // Peaches\n    // Level 2 - Uncommon (IDs 11-20)\n    else if card_id == 11 { [2, 6, 1, 6] }   // Freckles\n    else if card_id == 12 { [7, 1, 3, 1] }   // Camo\n    else if card_id == 13 { [6, 2, 2, 3] }   // Neon\n    else if card_id == 14 { [5, 3, 3, 4] }   // Glow Bug\n    else if card_id == 15 { [6, 1, 4, 3] }   // Limelight\n    else if card_id == 16 { [3, 4, 5, 3] }   // Marble\n    else if card_id == 17 { [5, 3, 2, 5] }   // Sapphire\n    else if card_id == 18 { [5, 1, 3, 5] }   // Jefferson\n    else if card_id == 19 { [5, 2, 5, 2] }   // Longfoot\n    else if card_id == 20 { [4, 2, 4, 5] }   // Featherfin\n    // Level 3 - Rare (IDs 21-30)\n    else if card_id == 21 { [3, 7, 2, 5] }   // Lilac\n    else if card_id == 22 { [5, 2, 5, 5] }   // Patches\n    else if card_id == 23 { [6, 6, 3, 3] }   // Faded\n    else if card_id == 24 { [6, 3, 6, 3] }   // Gold Dust\n    else if card_id == 25 { [3, 5, 5, 5] }   // Phantom\n    else if card_id == 26 { [7, 5, 1, 3] }   // Ash\n    else if card_id == 27 { [7, 1, 5, 3] }   // Cocoa\n    else if card_id == 28 { [5, 3, 6, 3] }   // Ringmaster\n    else if card_id == 29 { [5, 6, 2, 4] }   // Goldrush\n    else if card_id == 30 { [4, 4, 7, 2] }   // Swampling\n    // Level 4 - Epic (IDs 31-40)\n    else if card_id == 31 { [3, 6, 4, 7] }   // Glitter\n    else if card_id == 32 { [7, 2, 3, 7] }   // Starfield\n    else if card_id == 33 { [2, 3, 7, 7] }   // Specter\n    else if card_id == 34 { [6, 5, 5, 5] }   // Saffron\n    else if card_id == 35 { [4, 7, 6, 2] }   // Stardust\n    else if card_id == 36 { [2, 3, 7, 8] }   // Achoque\n    else if card_id == 37 { [1, 7, 6, 4] }   // Zacapu\n    else if card_id == 38 { [7, 3, 1, 6] }   // Laguna\n    else if card_id == 39 { [7, 4, 4, 4] }   // Streamwalker\n    else if card_id == 40 { [3, 7, 3, 6] }   // Digger\n    // Level 5 - Legendary (IDs 41-50)\n    else if card_id == 41 { [6, 7, 3, 7] }   // Eclipse\n    else if card_id == 42 { [6, 5, 8, 4] }   // Kaleidoscope\n    else if card_id == 43 { [6, 5, 6, 6] }   // Twinned\n    else if card_id == 44 { [3, 6, 7, 8] }   // Sparkletail\n    else if card_id == 45 { [7, 6, 5, 6] }   // Riddler\n    else if card_id == 46 { [3, 10, 2, 1] }  // Rosita\n    else if card_id == 47 { [6, 2, 6, 7] }   // Brooklet\n    else if card_id == 48 { [5, 5, 7, 6] }   // Whisper\n    else if card_id == 49 { [7, 7, 4, 2] }   // Misty\n    else { [7, 2, 7, 4] }                    // Lerma (50)\n}\n\n// ====================== HASH FUNCTIONS ======================\n\nfn hash_board_state(board: [Field; 18], scores: [Field; 2], current_turn: Field) -> Field {\n    let mut inputs: [Field; 21] = [0; 21];\n    for i in 0..18 {\n        inputs[i] = board[i];\n    }\n    inputs[18] = scores[0];\n    inputs[19] = scores[1];\n    inputs[20] = current_turn;\n    std::hash::pedersen_hash(inputs)\n}\n\n// ====================== MAIN CIRCUIT ======================\n\nfn main(\n    // Public inputs\n    card_commit_1: pub Field,\n    card_commit_2: pub Field,\n    start_state_hash: pub Field,\n    end_state_hash: pub Field,\n    game_ended: pub Field,\n    winner_id: pub Field,\n    // Private inputs - move data\n    current_player: Field,       // 1 or 2\n    card_id: Field,              // ID of card being placed\n    row: Field,                  // 0-2\n    col: Field,                  // 0-2\n    // Private inputs - board state\n    board_before: [Field; 18],   // 9 cells x 2 fields (card_id, owner)\n    board_after: [Field; 18],\n    scores_before: [Field; 2],\n    scores_after: [Field; 2],\n    current_turn_before: Field,\n    // Private inputs - current player's hand commitment data\n    player_card_ids: [Field; 5],\n    blinding_factor: Field,\n) {\n    // ===== 1. Validate current player =====\n    assert(\n        (current_player == 1) | (current_player == 2),\n        \"Invalid player\",\n    );\n    assert(current_player == current_turn_before, \"Not this player's turn\");\n\n    // ===== 2. Validate position =====\n    let r = row as u32;\n    let c = col as u32;\n    assert(r < 3, \"Row out of bounds\");\n    assert(c < 3, \"Col out of bounds\");\n\n    // ===== 3. Verify card_commit binding =====\n    // Recompute the current player's card_commit from their hand data\n    let mut to_hash: [Field; 6] = [0; 6];\n    for i in 0..5 {\n        to_hash[i] = player_card_ids[i];\n    }\n    to_hash[5] = blinding_factor;\n    let recomputed_commit = Poseidon2::hash(to_hash, 6);\n\n    // Verify it matches the correct card_commit (1 or 2 based on current_player)\n    if current_player == 1 {\n        assert(recomputed_commit == card_commit_1, \"Player 1 card commit mismatch\");\n    } else {\n        assert(recomputed_commit == card_commit_2, \"Player 2 card commit mismatch\");\n    }\n\n    // ===== 4. Verify placed card is in committed hand =====\n    let mut card_found: bool = false;\n    for i in 0..5 {\n        if player_card_ids[i] == card_id {\n            card_found = true;\n        }\n    }\n    assert(card_found, \"Placed card not in committed hand\");\n\n    // ===== NEW: Verify card has not already been placed (C2 fix) =====\n    for i in 0..9 {\n        if board_before[i * 2 + 1] != 0 {\n            // Cell is occupied -- verify it's not the same card\n            assert(board_before[i * 2] != card_id, \"Card already placed on board\");\n        }\n    }\n\n    // Look up placed card ranks from database\n    let placed_card_ranks = get_card_ranks(card_id as u32);\n\n    // ===== 5. Verify the cell was empty before the move =====\n    let cell_idx = r * 3 + c;\n    assert(board_before[cell_idx * 2] == 0, \"Cell not empty\");\n    assert(board_before[cell_idx * 2 + 1] == 0, \"Cell not empty (owner)\");\n\n    // ===== 6. Verify the card was placed in board_after =====\n    assert(board_after[cell_idx * 2] == card_id, \"Card not placed correctly\");\n    assert(\n        board_after[cell_idx * 2 + 1] == current_player,\n        \"Owner not set correctly\",\n    );\n\n    // ===== 7. Capture logic =====\n    // Determine the opponent\n    let opponent: Field = if current_player == 1 { 2 } else { 1 };\n\n    // Track which cells are captured (1 = captured, 0 = not)\n    let mut captured: [bool; 9] = [false; 9];\n\n    // Check all 4 adjacent directions:\n    // placed_card_ranks: [top, right, bottom, left]\n\n    // Direction 0: Top (row-1, col)\n    if r > 0 {\n        let adj_idx = (r - 1) * 3 + c;\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's top vs adjacent card's bottom\n            let placed_rank = placed_card_ranks[0] as u32;\n            let adj_rank = adj_ranks[2] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 1: Right (row, col+1)\n    if c < 2 {\n        let adj_idx = r * 3 + (c + 1);\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's right vs adjacent card's left\n            let placed_rank = placed_card_ranks[1] as u32;\n            let adj_rank = adj_ranks[3] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 2: Bottom (row+1, col)\n    if r < 2 {\n        let adj_idx = (r + 1) * 3 + c;\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's bottom vs adjacent card's top\n            let placed_rank = placed_card_ranks[2] as u32;\n            let adj_rank = adj_ranks[0] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 3: Left (row, col-1)\n    if c > 0 {\n        let adj_idx = r * 3 + (c - 1);\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's left vs adjacent card's right\n            let placed_rank = placed_card_ranks[3] as u32;\n            let adj_rank = adj_ranks[1] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // ===== 8. Verify board_after matches expected state =====\n    for i in 0..9 {\n        if i as u32 != cell_idx {\n            let before_card = board_before[i * 2];\n            let before_owner = board_before[i * 2 + 1];\n            let after_card = board_after[i * 2];\n            let after_owner = board_after[i * 2 + 1];\n\n            // Card ID must never change for non-placed cells\n            assert(after_card == before_card, \"Non-placed cell card_id changed\");\n\n            if captured[i] {\n                // Captured cell: owner must change to current_player\n                assert(\n                    after_owner == current_player,\n                    \"Captured cell owner not updated\",\n                );\n            } else {\n                // Non-captured cell: owner must stay the same\n                assert(after_owner == before_owner, \"Non-captured cell owner changed\");\n            }\n        }\n    }\n\n    // ===== 9. Verify start_state_hash matches board_before =====\n    let computed_start = hash_board_state(board_before, scores_before, current_turn_before);\n    assert(computed_start == start_state_hash, \"Start state hash mismatch\");\n\n    // ===== 10. Compute and verify end state =====\n    let next_turn: Field = if current_player == 1 { 2 } else { 1 };\n    let computed_end = hash_board_state(board_after, scores_after, next_turn);\n    assert(computed_end == end_state_hash, \"End state hash mismatch\");\n\n    // ===== 11. Verify game ended flag =====\n    let mut filled: u32 = 0;\n    for i in 0..9 {\n        if board_after[i * 2] != 0 {\n            filled += 1;\n        }\n    }\n\n    if filled == 9 {\n        assert(game_ended == 1, \"Game should have ended\");\n        let p1_score = scores_after[0] as u32;\n        let p2_score = scores_after[1] as u32;\n        if p1_score > p2_score {\n            assert(winner_id == 1, \"Player 1 should be winner\");\n        } else if p2_score > p1_score {\n            assert(winner_id == 2, \"Player 2 should be winner\");\n        } else {\n            assert(winner_id == 3, \"Should be a draw\");\n        }\n    } else {\n        assert(game_ended == 0, \"Game should not have ended\");\n        assert(winner_id == 0, \"No winner yet\");\n    }\n\n    // ===== 12. Verify scores are exactly correct (C1 fix) =====\n    let mut p1_board: u32 = 0;\n    let mut p2_board: u32 = 0;\n    for i in 0..9 {\n        let owner = board_after[i * 2 + 1];\n        if owner == 1 {\n            p1_board += 1;\n        } else if owner == 2 {\n            p2_board += 1;\n        }\n    }\n    // Player 1 goes first, so P1 has placed ceil(filled/2) cards, P2 has placed floor(filled/2)\n    let p1_played = (filled + 1) / 2;\n    let p2_played = filled / 2;\n    let p1_hand = 5 - p1_played;\n    let p2_hand = 5 - p2_played;\n    let expected_p1_score = p1_board + p1_hand;\n    let expected_p2_score = p2_board + p2_hand;\n    assert(scores_after[0] == expected_p1_score as Field, \"P1 score mismatch\");\n    assert(scores_after[1] == expected_p2_score as Field, \"P2 score mismatch\");\n}\n\n// ====================== TEST HELPERS ======================\n\n/// Helper: create a card_commit for test use (poseidon2)\nfn test_card_commit(card_ids: [Field; 5], blinding_factor: Field) -> Field {\n    let mut to_hash: [Field; 6] = [0; 6];\n    for i in 0..5 {\n        to_hash[i] = card_ids[i];\n    }\n    to_hash[5] = blinding_factor;\n    Poseidon2::hash(to_hash, 6)\n}\n\n// Default hand data for Player 1 in tests: cards 1-5\n// Mudwalker[1,4,1,5], Blushy[5,1,1,3], Snowdrop[1,3,3,5], Sunny[6,1,1,2], Inkwell[2,3,1,5]\nglobal P1_BLINDING: Field = 111;\n\nfn p1_card_ids() -> [Field; 5] { [1, 2, 3, 4, 5] }\n\n// Default hand data for Player 2 in tests: cards 10-14\n// Peaches[4,3,2,4], Freckles[2,6,1,6], Camo[7,1,3,1], Neon[6,2,2,3], Glow Bug[5,3,3,4]\nglobal P2_BLINDING: Field = 222;\n\nfn p2_card_ids() -> [Field; 5] { [10, 11, 12, 13, 14] }\n\nfn get_p1_commit() -> Field {\n    test_card_commit(p1_card_ids(), P1_BLINDING)\n}\n\nfn get_p2_commit() -> Field {\n    test_card_commit(p2_card_ids(), P2_BLINDING)\n}\n\n// ====================== TESTS ======================\n\n#[test]\nfn test_first_move_no_capture() {\n    // Player 1 places card 1 (Mudwalker) at (0,0) on empty board - no captures possible\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; // card_id = 1 (Mudwalker)\n    board_after[1] = 1; // owner = player1\n    let scores_after: [Field; 2] = [5, 5]; // 1 on board + 4 in hand = 5\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,       // game not ended\n        1,          // current_player\n        1,          // card_id (Mudwalker)\n        0, 0,       // row, col\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_second_move_no_capture() {\n    // Player 2 places card 10 (Peaches) at (1,1)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; // card at (0,0): card_id=1, owner=player1\n    board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    board_after[8] = 10; // card at (1,1): card_id=10, owner=player2\n    board_after[9] = 2;\n    let scores_after: [Field; 2] = [5, 5]; // p1: 1+4=5, p2: 1+4=5\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        2,          // current_player = player2\n        10,         // card_id = Peaches\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n#[test]\nfn test_capture_one_card() {\n    // Player 1 has card 1 (Mudwalker [1,4,1,5]) at (0,0)\n    // Player 2 has card 10 (Peaches [4,3,2,4]) at (0,1)\n    // Player 1 places card 4 (Sunny [6,1,1,2]) at (1,1)\n    // (1,1) is adjacent to (0,1) - placed card's top=6 vs Peaches's bottom=2 -> 6>2 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, player 1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, player 2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;     // (0,0) unchanged\n    board_after[2] = 10; board_after[3] = 1;    // (0,1) CAPTURED - owner changed to player 1\n    board_after[8] = 4; board_after[9] = 1;     // (1,1) placed card 4, player 1\n    let scores_after: [Field; 2] = [6, 4];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1,          // current_player\n        4,          // card_id = Sunny\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_capture_multiple_cards() {\n    // P1 places card 1 Mudwalker [1,4,1,5] at (1,1):\n    // Right (1,2): Card 12 Camo left=1 vs placed right=4 -> 4>1 CAPTURE!\n    // Left (1,0): Card 10 Peaches right=3 vs placed left=5 -> 5>3 CAPTURE!\n    // Top (0,1): Card 11 Freckles bottom=1 vs placed top=1 -> NO (equal)\n    // Bottom (2,1): Card 13 Neon top=6 vs placed bottom=1 -> NO\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;   // (0,1) Freckles\n    board_before[6] = 10; board_before[7] = 2;   // (1,0) Peaches\n    board_before[10] = 12; board_before[11] = 2; // (1,2) Camo\n    board_before[14] = 13; board_before[15] = 2; // (2,1) Neon\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;     // (0,1) unchanged\n    board_after[6] = 10; board_after[7] = 1;     // (1,0) CAPTURED\n    board_after[8] = 1; board_after[9] = 1;      // (1,1) placed\n    board_after[10] = 12; board_after[11] = 1;   // (1,2) CAPTURED\n    board_after[14] = 13; board_after[15] = 2;   // (2,1) unchanged\n    // filled=5, p1_board=3, p2_board=2, p1_played=3, p2_played=2\n    // p1_score = 3 + (5-3) = 5, p2_score = 2 + (5-2) = 5\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1,\n        1,          // card_id = Mudwalker\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_no_capture_higher_adjacent() {\n    // P1 card 3 Snowdrop [1,3,3,5] at (0,0). (0,1) has P2 card 14 Glow Bug [5,3,3,4].\n    // Placed right=3 vs adj left=4. 3<4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1,\n        3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p1_wins() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    board_before[2] = 10; board_before[3] = 2;\n    board_before[4] = 2; board_before[5] = 1;\n    board_before[6] = 11; board_before[7] = 2;\n    board_before[8] = 3; board_before[9] = 1;\n    board_before[10] = 12; board_before[11] = 1;\n    board_before[12] = 4; board_before[13] = 1;\n    board_before[14] = 13; board_before[15] = 2;\n\n    let scores_before: [Field; 2] = [6, 4];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    board_after[16] = 5;\n    board_after[17] = 1;\n    // (2,1) card 13 Neon: placed left=5 vs adj right=2 -> 5>2 CAPTURE!\n    board_after[15] = 1;\n\n    let scores_after: [Field; 2] = [7, 3];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 1,       // game ended, player 1 wins\n        1,\n        5,\n        2, 2,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_game_ends_draw() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    // Board where no captures happen on final move -> draw\n    let mut board_before2: [Field; 18] = [0; 18];\n    board_before2[0] = 1; board_before2[1] = 1;\n    board_before2[2] = 10; board_before2[3] = 2;\n    board_before2[4] = 2; board_before2[5] = 1;\n    board_before2[6] = 13; board_before2[7] = 2;\n    board_before2[8] = 3; board_before2[9] = 1;\n    board_before2[10] = 12; board_before2[11] = 2;\n    board_before2[12] = 4; board_before2[13] = 1;\n    board_before2[14] = 11; board_before2[15] = 2; // Freckles [2,6,1,6]\n    let scores_before2: [Field; 2] = [5, 5];\n    let current_turn_before2: Field = 1;\n    let start_hash2 = hash_board_state(board_before2, scores_before2, current_turn_before2);\n\n    let mut board_after2: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after2[i] = board_before2[i];\n    }\n    board_after2[16] = 5;  // Inkwell at (2,2)\n    board_after2[17] = 1;\n    // (1,2) card 12 Camo: placed top=2 vs adj bottom=3 -> NO\n    // (2,1) card 11 Freckles: placed left=5 vs adj right=6 -> NO\n    let scores_after2: [Field; 2] = [5, 5];\n    let end_hash2 = hash_board_state(board_after2, scores_after2, 2);\n\n    main(\n        cc1, cc2,\n        start_hash2, end_hash2,\n        1, 3,       // game ended, draw\n        1,\n        5,\n        2, 2,\n        board_before2, board_after2,\n        scores_before2, scores_after2,\n        current_turn_before2,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p2_wins() {\n    // P2 places the 9th card and wins with a higher score\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    // Row 0: P1 card 1, P2 card 10, P1 card 2\n    board_before[0] = 1; board_before[1] = 1;    // (0,0) Mudwalker P1\n    board_before[2] = 10; board_before[3] = 2;   // (0,1) Peaches P2\n    board_before[4] = 2; board_before[5] = 1;    // (0,2) Blushy P1\n    // Row 1: P2 card 11, P2 card 12, P1 card 3\n    board_before[6] = 11; board_before[7] = 2;   // (1,0) Freckles P2\n    board_before[8] = 12; board_before[9] = 2;   // (1,1) Camo P2\n    board_before[10] = 3; board_before[11] = 1;  // (1,2) Snowdrop P1\n    // Row 2: P2 card 13, P1 card 5, empty (2,2)\n    board_before[12] = 13; board_before[13] = 2; // (2,0) Neon P2\n    board_before[14] = 5; board_before[15] = 1;  // (2,1) Inkwell P1\n\n    // Scores: P1 has 4 on board + 1 in hand = 5, P2 has 4 on board + 1 in hand = 5\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2; // P2's turn\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    // P2 places card 14 (Glow Bug [5,3,3,4]) at (2,2)\n    board_after[16] = 14; board_after[17] = 2;\n\n    // Check captures:\n    // (1,2) Snowdrop P1 [1,3,3,5]: placed top=5 vs adj bottom=3 -> 5>3 CAPTURE!\n    board_after[11] = 2; // Snowdrop captured by P2\n    // (2,1) Inkwell P1 [2,3,1,5]: placed left=4 vs adj right=3 -> 4>3 CAPTURE!\n    board_after[15] = 2; // Inkwell captured by P2\n\n    // filled=9, p1_board=2, p2_board=7, p1_played=5, p2_played=4\n    // p1_score = 2 + (5-5) = 2, p2_score = 7 + (5-4) = 8\n    let scores_after: [Field; 2] = [2, 8];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 2,       // game ended, player 2 wins\n        2,          // current_player = P2\n        14,         // card_id = Glow Bug\n        2, 2,       // row=2, col=2\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n// ====================== FAILURE TESTS ======================\n\n#[test(should_fail_with = \"Cell not empty\")]\nfn test_fail_place_on_occupied_cell() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 10;\n    board_before[1] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,       // (0,0) is occupied\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Not this player's turn\")]\nfn test_fail_wrong_player_turn() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1; // P1's turn\n\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 10;\n    board_after[1] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        2,          // P2 trying to play on P1's turn\n        10,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Row out of bounds\")]\nfn test_fail_row_out_of_bounds() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n    let end_hash = start_hash;\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        3, 0,       // row=3 out of bounds\n        board_before, board_before,\n        scores_before, scores_before,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Placed card not in committed hand\")]\nfn test_fail_card_not_in_hand() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 20;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 20,      // card 20 not in P1's hand\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Player 1 card commit mismatch\")]\nfn test_fail_wrong_blinding_factor() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(),\n        999,        // WRONG blinding factor\n    );\n}\n\n#[test(should_fail_with = \"Non-captured cell owner changed\")]\nfn test_fail_false_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 1;      // FALSE CAPTURE\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Captured cell owner not updated\")]\nfn test_fail_missing_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;      // NOT captured (WRONG!)\n    board_after[8] = 4; board_after[9] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 4,\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Non-placed cell card_id changed\")]\nfn test_fail_card_id_changed() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 99; board_after[3] = 2;      // card_id CHANGED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_player2_move_with_capture() {\n    // P2 places card 12 (Camo [7,1,3,1]) at (1,0)\n    // (0,0) has P1 card 1 (Mudwalker [1,4,1,5]).\n    // Placed top=7 vs adj bottom=1 -> 7>1 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 2;      // CAPTURED by P2\n    board_after[6] = 12; board_after[7] = 2;\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        2,\n        12,\n        1, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n#[test]\nfn test_equal_ranks_no_capture() {\n    // P1 card 1 Mudwalker right=4 at (0,0), (0,1) has P2 card 10 Peaches left=4.\n    // 4 == 4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 10; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;      // NOT captured (equal ranks)\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n// ====================== C1 FIX TESTS: Exact Score Verification ======================\n\n#[test(should_fail_with = \"P1 score mismatch\")]\nfn test_score_fabrication_rejected() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    // Fabricated scores: should be [5, 5] but attacker claims [8, 2]\n    let scores_after: [Field; 2] = [8, 2];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_exact_scores_after_capture() {\n    // P2 places card 13 (Neon [6,2,2,3]) at (0,1).\n    // (0,0) has P1 card 5 (Inkwell [2,3,1,5]). Placed left=3 vs adj right=3 -> NO (equal)\n    // (1,1) has P1 card 1 (Mudwalker [1,4,1,5]). Placed bottom=2 vs adj top=1 -> 2>1 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 5; board_before[1] = 1;    // (0,0) Inkwell P1\n    board_before[4] = 10; board_before[5] = 2;   // (0,2) Peaches P2\n    board_before[8] = 1; board_before[9] = 1;    // (1,1) Mudwalker P1\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 5; board_after[1] = 1;      // (0,0) Inkwell P1 - unchanged\n    board_after[2] = 13; board_after[3] = 2;     // (0,1) Neon P2 - placed\n    board_after[4] = 10; board_after[5] = 2;     // (0,2) Peaches P2 - unchanged\n    board_after[8] = 1; board_after[9] = 2;      // (1,1) Mudwalker CAPTURED by P2\n    // Exact scores: p1_board=1, p2_board=3, p1_hand=3, p2_hand=3\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        2,\n        13,\n        0, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n// ====================== C2 FIX TESTS: Card Replay Prevention ======================\n\n#[test(should_fail_with = \"Card already placed on board\")]\nfn test_card_replay_rejected() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;\n    board_after[8] = 1; board_after[9] = 1;    // (1,1) card 1 REPLAYED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,          // card_id = 1 (already on board!)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_different_card_after_same_id_on_board() {\n    // P1 has card 1 on board. P1 places card 2 (different card). Should succeed.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 1;   // (0,1) CAPTURED: Blushy top=5 > Peaches bottom=2\n    board_after[8] = 2; board_after[9] = 1;    // (1,1) card 2, different card\n    // filled=3, p1_board=3, p2_board=0, p1_played=2, p2_played=1\n    // p1_score=3+3=6, p2_score=0+4=4\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 2,          // card_id = 2 (different, valid)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n","path":"/Users/zac/aztec-triple-triad-ui/repo/circuits/game_move/src/main.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\nglobal RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let num_extra_fields = in_len % RATE;\n            if num_extra_fields != 0 {\n                let remainder_start = in_len - num_extra_fields;\n                state[0] += input[remainder_start];\n                if num_extra_fields > 1 {\n                    state[1] += input[remainder_start + 1];\n                }\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4);\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/zac/nargo/github.com/noir-lang/poseidon/v0.2.6/src/poseidon2.nr"}}}