{"noir_version":"1.0.0-beta.18+2db78f8894936db05c53430f364360ac9cc5c61f","hash":"12379281497722293537","abi":{"parameters":[{"name":"card_commit_1","type":{"kind":"field"},"visibility":"public"},{"name":"card_commit_2","type":{"kind":"field"},"visibility":"public"},{"name":"start_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"end_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"game_ended","type":{"kind":"field"},"visibility":"public"},{"name":"winner_id","type":{"kind":"field"},"visibility":"public"},{"name":"current_player","type":{"kind":"field"},"visibility":"private"},{"name":"card_id","type":{"kind":"field"},"visibility":"private"},{"name":"row","type":{"kind":"field"},"visibility":"private"},{"name":"col","type":{"kind":"field"},"visibility":"private"},{"name":"board_before","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"board_after","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_before","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_after","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"current_turn_before","type":{"kind":"field"},"visibility":"private"},{"name":"player_card_ids","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"blinding_factor","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"4487758756370642245":{"error_kind":"string","string":"Start state hash mismatch"},"5101543514421470893":{"error_kind":"string","string":"Card already placed on board"},"6511982886681245134":{"error_kind":"string","string":"Placed card not in committed hand"},"7317384265632011736":{"error_kind":"string","string":"Cell not empty (owner)"},"7370811245087594529":{"error_kind":"string","string":"Captured cell owner not updated"},"7520349170859696597":{"error_kind":"string","string":"Card not placed correctly"},"8084300406162371689":{"error_kind":"string","string":"Player 2 card commit mismatch"},"8749084135167576643":{"error_kind":"string","string":"Invalid player"},"9296992678443765102":{"error_kind":"string","string":"Non-placed cell card_id changed"},"9336663072722308931":{"error_kind":"string","string":"Owner not set correctly"},"9573161043312537276":{"error_kind":"string","string":"Should be a draw"},"9697039476693520435":{"error_kind":"string","string":"Player 2 should be winner"},"9715689440484907290":{"error_kind":"string","string":"Game should have ended"},"9915128275385804551":{"error_kind":"string","string":"Player 1 should be winner"},"11936972275297119974":{"error_kind":"string","string":"Invalid card ID for rank lookup"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12724384224350165649":{"error_kind":"string","string":"End state hash mismatch"},"14336771847768869760":{"error_kind":"string","string":"Not this player's turn"},"14904510168980638594":{"error_kind":"string","string":"Cell not empty"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15156018542597224275":{"error_kind":"string","string":"Player 1 card commit mismatch"},"15353634778740263988":{"error_kind":"string","string":"Game should not have ended"},"15521846062275453407":{"error_kind":"string","string":"Col out of bounds"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16309609255298369368":{"error_kind":"string","string":"Row out of bounds"},"16422110396685134300":{"error_kind":"string","string":"P1 score mismatch"},"17174323770794875209":{"error_kind":"string","string":"Non-captured cell owner changed"},"18125798406593280834":{"error_kind":"string","string":"No winner yet"},"18256603403857491958":{"error_kind":"string","string":"P2 score mismatch"}}},"bytecode":"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","debug_symbols":"tb3RriW7cWX7L+fZD0kyIhjUr1w0DNmtbggQZENtN3Bh6N/vziA5x/EFTmlrlf2iPSRVkYszV86MDM7N+o9f/ucf/unf//c//vHP/+tf/s8vv/t//uOXf/rLH//0pz/+73/807/88+//7Y//8uev//U/fnne/2jxy+/6P/zS5v6Rv/xufP1Yv/zO/uGX/vUn7K9f//X+Qd//1/zr1/94h/rHf/vLH/7w/oFfjf0147/+/i9/+PO//fK7P//7n/70D7/839//6d/rD/2ff/39n+vnv/3+L1//7/MPv/zhz//z6+fXgP/rj3/6w0t//Qf+9vPbfzW7nb+clvrrbf6nv99+++9HxPn7Mf2Dvz+fcf7+bM9Hf7/fv99/c/4frH81P39/9fbJ3/e8f3+u3/r78dt/v7XH7gq+OH61hvzuZwjXRQy3oRG8fX8ES40Q86MR+mCE/GSEaFpFePtkhDn0GeZnOkyfGuEzHWY+GiH9kxGya4Tsn4wwH9dN9cxPlJzNmm7L376abf72EMPuZxj5qwHWfx4gfzDAo2/UeEb7aIivG+oO0cx+a4j+AyVsrmsQlqNzd364kOgfLST8fooRMT4bQl+rEeM3P8WPvhR93Zvj60b7za/VDz/EQooV7aMPEY8M/1eO+3d8t4eu6LT+0QjBQ+s/Sfl3jLA0wtcT8JMRUo4987N7/D+NEJ+MsEKrWNl/doT1iQ7Z+l1FtvHzI8yPRtAqsk3/aAR/GCF+doT85PuQvV+z/CoK+0cjtMEI46dH+KSKyKFnX4750yPkJ/6Qpqdn2nx+doT8aBVLd3eu+GyEVGn7PJ/cF+vpXSOM56MRpsrz56Nqaj16XnyN8Jt3lv/gFaPx3GvjWR8NMVTbttHnh58iGCI/GsKedYew3j4bYuptxdI+GsK75PTxmZyektPXZxc1xv12t/DnsyGWPsV8PvsUU679Zfv9oyHy0UK+3hw+GyJ0UXN+dlFX07dz9Y8uan/a1aJ/VcyfDRFTQ+RHWvSmMrn/oJ748RBzaIjPLKf3oU/xgyfpj4eQfX8N9tHN3nmH68M/W4g9Woi1zxZiarF0m58txNXl6f6Zd369duhTxGfe2UO3WY/fLhN/OMRs+hRzfPYpphy8/6BB8cMhkm9nfvjtzAwNsT7ziyUH78s/02Ktrjfz5yMtxuONl/uPvPOrS5HqUnz21Rpdt9non91mo7t6JT0+uiKDKmd8WOWMMbWQkZ8txPQe8+Vfny3kq9WjIT6rL75eIm6tNdz7Z0OovhjxfCZn2KJv9NmnmHosj/nZY3nko4V8vd5+NoTK+JHzs0/x1eBX72l8dqeuOTXE+qi+sGfcIezxD4dQ88jaZ3WnNb0dWouPLMf6o8boV5nz2RDRNMRv150/fLsz3g/9o3fUr5pCG0DRPhph3Xtsjf7RW67ZvT+WxUcj8FBf86PuT3ueppfD5/moe/P+vWSM6D8/xkffinctvx7DPxqjDb3dPe2jLk57aGd9sa3PxsjOGGt+NMbX41hjDIvPxqAL8tiTP39d1meaPnP99BjR+RwxPtPUjM9h8dn9EvbwOfyz7/qinfIs++y7znPti9dH39OvIlbf9fe/fPQ5ZnBd5kd9z6+5aWa0Nj+6Ll+9Nl2Xr9bdZ3r4w+fw/tkY8avPMX/7DbyNH+1ghipRi9/uqf+NMdRYsZgffo4pM7T529/T9u7hf6up0eM3d2Nf6/7tV0/t1ny9ej6/PYb/qH7Sl936jz7Hj8YYFFDjV8/bv2sMao+fGaP99Bg2tJav78pnY7jaZl9F0PrNMeyHbQU6Vum/nWd6Ize/3aZhjK9t998eY/yoHao9pLbm89EYnd2T/tgPPscPNEXS+HW6Kv+eTyFL7s9qv/0p5n/rp2i51A/91SvP36Un9+zPjPH89BijNbqqv/3d8P6j/SRlGNqv26p/1xhGgWv2XzHG/HAMddDaf/KOv2+Mh22p9vNr+XQMf7QWb8/PjzE+HcMY41ddyf//GNF+9q798aegJIwf3C0xfto7fujnemH46mv+9nUN/3k//9EY3/Xz+Gkn/fGn+J6fx/pv/RTf9PO/Mcb4Lxjj+ekxvunn037ez384xjf9/PtjzA/H+J6f/40xvuXn317Lp2N808+/Pcb4dIzv+Xn+tJP++FN8z8/T/1v9nIx2n+u39cz58/fbD8f45v32/THmh2N87377G2N863779lo+HeOb99u3xxifjvG9+23Fz37Tf/wpvne/rfzZT/HDfglJwq999vyo5zIau6HN+4djJHvcI/4LxvjNHsMPe3Iz1Pf9Gu2z/uKih92f304Z1RbbT/b1/sYY3+rr/XiM7/X1+pM/3dfrz/rpvl5vz0/39X48xvf6ej8e43t9vb81RvvpMb7X1/vxGN/r6/UWP93X6z/6haRv9vX6j35/5ZvvgT8c45vvgf1Hv5X0LVf/G5/iW++Bvff/1k/xvffAvzXG+C8Y4/npMb73Htj7z9elPx7je3Xp3zHG/HCMb9Wlf2uM79Sl31/Lp2N8ry79/hjj0zG+VZd+lUc/e9f2n69L+8if9o750329bs/P+/mPxviun9tPO+mPP8X3/Nzsv/VTfNPP/8YY479gjOenx/imn9v6eT//4Rjf9PPvjzE/HON7fv43xviWn397LZ+O8U0///YY49Mxvufn/tNO+uNP8T0/j+e/1c+/19fr8fP7oj8e45v3W/z8vujfGON791v8/L7o99fy6RjfvN/i5/dF/8YY37vf5s/ui/6NT/G9+23+bDf/x/2S7/X1fjjGN3tyf8cYH/XkvuquoJ/20e/Pt/6rrG7/9Vr+rjG4Zb/aR/2zMdQK++LPsphfpYvynH2Mzz7H4Hdsv+qkz/SwgR7m47MxgmtrH/0OeOv+oIf39tkYk7X4Z7njHk2Z0K+vx2ea/uq3jvv8LGfbf9XD7jM/yh33JFP+1Z77aC3j6169Y4wf/Hb+D8doPBa+Knb7bAwecf/5oKC/ZwxfjDE/uufG4He5x2j54RicVjD6+GwM/VrNF7t/Nsb81RifZbmH/UoP++y+Hb8qo4bF+myMxbX19tHvCwy3X43x2e+kDNcv3n4+RnQ+R3x4baM9vznG//j6b7//5z/+5T+fkth/+d3XpRz1n1b/6b/87uuDRP3nrP/Mr+G+xl1fP74uWXteZ/n62c7Pfn6O89POTz8/4/yc52een2v/7Ge8/o739ajv/fwc56edn35+xvk5z888P9f+OZ7z84w33vG+bGSM89POTz8/3/G+bokxz888P9f+ac/7gvT1s52f/fwc56edn35+vkdOvn9vnp/5bo58/VxvQfel73N+tvOzn5/j/LTz08/POD/n+Znn5xkvznhxxoszXpzx4owXZ7w448UZL854ccabZ7x5xptnvHnGm2e86e+vVn/9jLdA/Po5z888P9f7W7pf357n/GznZz8/x/lp+8+nn59nvJzn/8/z84y3znjrjLf6/vNrnJ9nvOXn/4/z84y3znjrjNeeZ/+FrwfWhX5h3D9jF/xCXJgX8v6tdaDdkdv5rK31C3fkdkdud+QW92/NC3fkdj9zfy7ckfsdud+R+xGidb9wR+73M/e8cEced+RxRx5XjTEu3JHH/czjqjHuyOOOPO7IdtWwq7Pdke1+Zrtq2B3Z7sh2R35vqHf7s713VMF7S72t9fbeU+/v8bb3pnrb3O29q979+PbeVm9bsb331fu22d4by8qo5rsV+0K++6kvvCfEviO/N9f7DtPeu+vN0rf39towLrwjv1O8d9iGuDAv5IV14L3N3iZAe++zDf3CuGAX/EJcmBfywjqQd+T3jvNy3H5hXHhHfpf83nUb4sK88I78qvHeeQXvred1Sm670C+8I79CvbffBr8QF96RX8XeW3DD2tDfe3DDO3K+0C+MC3bhHXm9EBfmhbzwNfLbF+vvPbihXegXxvuW/oJd8Atx4WvkqKdTXlgH3ntwwztyPbn6hXHBLrwjv4cOv/fghnkhL7wj+/vkey60C/3CO3K8YBf8Qlx4R37FfO/BDevAew9ueEd+xXzvwQ3jgl14R37FfO/BDfNCXngPTH7FfO/BDe1CvzDe40pfsAt+IS7M9+DIF/LCOvDegxvekasC6BfGBbvwjvyK+d6DG+aFvPCO/Ir53oMb2oV+4R35FfO9Bzf4hbjwjvyK+d6DG9aB9x7c8I78ivnegxvGBbvwjvyK+d6DG+aFvPA18tuP6e89uKFd6BfeMu4V870HN/iFuDDfI/xeyAtrw3jvwQ3vyFVJ9Qvjgl14R36rp/ce3DAv5IV35LeSeu/BDe1Cv/COHC/YBb8QF96R5wt5YR1478EN78hvJfvegxvGBbvwjrxeiAvzQl5Y75EFb7X4XGgX+oXxnk/9gl3wC3HhLZ1fMd97cMM68N6DG96RXzHfe3DDuGAX3pGrao0L80JeeEd+xXzvwQ3tQr/wjvyK+d6DG/xCXHhHfsV878EN68B7D254R37FfO/BDeOCXXhHfsV878EN80JeeKvr93Cc8d6Eh5qoi96q/e0kjPdGPOSiEL3V+/ubvWOmaF3KR1RzvMpmFw2RHfJxHvM+xgW7cB7zPuLCvJAXzmPe34u94Tzm3fqFccEu+IW4MC/khfOYd38u3JH9PObdxwW7cB7z7nFhXsgL5zHv78XecB7zHv3CuHAe8x5+IS7MC+cx73Ee8z6fC+3Cecz7HBfsgl84j3mf80JeWAfyPOY924V+YVw4j3lPvxAX5oXzmPc8j3lfz4V24TzmfY0LdsEvnMe8r3khL6wN8ZzHfDztQr8wLpzHfDx+IS7MC+cxH895zEd7LrQL5zEfbVywC37hPOajzQt5YR3o5zEfvV3oF8aF85iP7hfiwrxwHvPRz2M+xnOhXTiP+Rjjgl3wC+cxH2NeyAvrgJ3HfFi70C+MC+cxH+YX4sK8cB7zYecxH/5caBfOYz58XLALfuE85sPnhbywDsR5zEe0C/3CuHAe8xF+IS7MC+cxH3Ee8zGfC+3CeczHHBfsgl84j/mY80JeWAfyPOYj24V+YVw4j/lIvxAX5oXzmI88j/lYz4V24TzmY40LdsEvnMd8rHkhL6wN8zmP+fm0C/3CuHAe8/PxC3FhXjiP+fmcx/xsz4V24TzmZxsX7IJfOI/52eaFvLAO9POYn71d6BfGhfOYn90vxIV54TzmZz+P+TmeC+3CeczPMS7YBb9wHvNzzAt5YR2w+5Sf1kRdNET3KT/NRSGaovuUn3af8tMfURPdp/z0ITKRH1p+nvfLxwW7cJ73y+PCvJAXzvN+xXPhPJVX9Avjgl3wC3FhXsgL53m/bsNg3YbBmud5v+a4YBfO837NuDAv5IXzvF/5XDjP+5X9wrhwnvcr/UJcmBfO837led6v9VxoF87zfq1xwS74hfO8X2teyAvnef/1ZTkP/PfwIlEXDdF56H+Ri0I0RefB/x5edKk9oiY6D//3ICqRiVx0CoD3kCpRitalfoqA91AqURcN0SkEvshFIZqiUwy8h1JdGo+oiU5B8B5CJTKRi05R8EVTlKJ1yU5h8EVN1EVDdIqDL3JRiKboFAhftC75I2qiUyR80RCZyEWnUPiiKUrRuhSnWPiiJuqiIToFw3tAlChEU3SKhi9al+YjaqJTOHzREJnIRad4+KIpStG6lKeA+KIm6qIhOkXEF7koRFN0CokvWpfWI2qiU0x80RCZyEWnoHgPuRKl6NQUrbrzb+XQqj1/qIuG6BQWrVr0h0I0Rae4aNWm39QeUROdAqNVq/6QiVx0ioxW7fpDKVqX+ik0WrXsD3XREJ1io1Xb/lCIpugUHK1a95vGI2qiU3S0at8fMpGLTuHRqoV/KEXrkp3io1Ub/1AXDdEpQFq18g+FaIpOEdKqnb/JH1ETnUKkVUv/kIlcdIqRVm39Qylal+IWJK16+xc7OMBblLTq8V8McIK3MGktlnA+YANvcdLaHKCBtz5p1c6q7YbqZx1y0d1xqJbWoRTdTYfqah1qorvvUI2tQyZyUYimKEV3+6H6W4eaSHPY3YKoHtchF91diGpzHUrRuuSnZGnV6jp09yKq2XXIRHc7ovpdh6YoRad2adXzOtREXXTql1Z9r0MuCtGpYVr1vg7dKqaaX4duFVPNr0NDZKJbxVTz69AUpehWMdX8OtREXXSrmGp+HXJRiG4VMzJFt4oZ1STZdKuYsbpoiEx0q5ixQjRFKbpVjD2PqIm66FYx9pjIRSG6VYw9KbpVjFXFt+lWMda6aIhMdKsYayGaohTdKsb6I2qiLrpVjHUTuShEt4qxnqJbxVg1UzbdKsZGFw2RiW4VYyNEU5SiW8WYPaIm6qJbxZiZyEUhulWMWYpuFWNV8W26VYx5Fw2RiW4VYx6iKUrRrWIsHlETddGtYixM5KIQ3SrGIkW3irFqumy6VYzNLhoiE90qxmaIpihFt4qxfERN1EW3irE0kYtCdKsYyxTdKsaq4tt0qxhbXTREJrpVjK0QTVGKbhXjzyNqoi66VYw/JnJRiG4V40+KbhXj1ZzZdKsYb100RCa6VYy3EE1Rim4V4/0RNVEX3SrGu4lcFKJbxXhP0a1ivCq+TSpiau/i4gANVBFTexgXJ5igihi3B2xgB1XEuBnoYFys5k/VLtX8OWSiG6Wo5s+hKUqR4hT+iBSocCUqXJEKJ1OhUIUrVeGKVbhyFX4rmxnKbITmiJutmDFEJrrxihkhmqIU3YjFnI/ohizm7KIhujmLOV0Uoim6WYs5b2Uz8xE10WnMfNEQmchFpznzRVOUolvZzHX7M3M1URcN0e3PzOWiEE3R7c/MdSubfB5RE93+TD5DZCIX3f5MPlOUolvZZLv9mWxN1EVDdPsz2VwUoim6/Zlst7LJ/oia6PZnsg+RiVx0+zPZpyhFt7LJcfszOZqoi4bo9mdyuChEU3T7MzluZZP2iJro9mfShshELrr9mbQpStGtbNJvfya9ibpoiG5/Jt1FIZqi259Jv5VNxiNqotufyRgiE7no9mcypihFt7LJefszOZuoi4bo9mdyuihEU3T7MzlvZZP5iJro9mcyh8hELrr9mcwpStGtbHLd/kyuJuqiIbr9mVwuCtEU3f5MrlvZrOcRNdHtz6xniEzkotufWc8UpehWNqvd/sxqTdRFQ3T7M6u5KERTdPszq93KZvVH1ES3P7P6EJnIRbc/s/oUpehWNmvc/swaTdRFQ3T7M2u4KERTdPsza9zKZtkjaqLbn1k2RCZy0e3PLJuiFN3KZrn6M8sb2MEBqj+z3MEAJ6j+TG3aHIwHbKD6MysGaOAtbXrlDN/apVfQ8FAXjV2d9MoaHnJRiKYoRaf+6JU4PNREXTREJnJRiKYoRZrj/f54pRpHE3XR2BVLr/zhIReFaO4qplcG8dDatUuvFOKhJuq7YukVRDxkIhfFrlh6hREPpWhdqg5RFjVRFw2R7YqlVyjxUIimKHfF0iuYuCkeURP1XbH0CiceMpGL4peTHo0pSpFCpu9zYidIp2Kms4uGyH65uVJFTWeIFDatDlEpPm/ctNKKh5qo74qlV2DxkIlcFLti6RVaPJSiGzyt3GKlSiu4eKiLhsh2xdIrvHgoRFOUu2LpFWAsqgTjoSbqu2LpFWI8ZCIXxa5YegUZD6XohlEry1hJ0wozHuqiIbJdsfQKNB4K0RTlrlh6hRo39UfURH1XLL06wYdM5KLYFUuvTvChFN2AanWCK31aneBDXTREtiuWXp3gQyGaotwVS69O8CZ7RE3Ud8XSqxN8yEQuil2x9OoEH0rRuvTe51mKexN10RDZrlh6dYIPhWiKclcsvTrBm+IRNVHfFUuvTvAhE7kodsXSqxN8KEXrUtWDpfhsoi4aItsVS69O8KEQTVHuiqVXJ3hTPqIm6rti6dUJPmQiF8WuWHp1gg+laF167/NViq8m6qIhsl2x9OoEHwrRFOWuWHp1gouqE3yoifquWHp1gg+ZyEWxK5ZeneBDKVqXqh6sFHxroi4aItsVS69O8KEQTVGecqVXK/hgf8AG9lOu9GoHXzTQwTjlSq+W8MUEl7B+Na7KFRsN7OCtcnrl8qp2qWDeoSbqpzqpbN4hE7koRFN0q464e0Y97p5Rj7tn1OPuGfW4SdkeNyrb42Zle9ywbI+blu1hmqMqgnf1FdY71ET9VCyV1ztkIhfFqWIqs3coT+1Sqb1N8YjaqVgquHdoiEzkp2Kp8N6hKUrROhVLBfgONVEXjVOxVIjvkItCNE/FUkG+Q7eyiRun7ZXlq4qlwnyHhshEfiqWCvQdmqIUrVOxVKjvUBN10TgVSwX7DrkoRPNULBXuO3Qrm3kjtr3yfVWxVMDv0BCZyE/FUiG/Q1OUonUqlgr6HWqiLhqnYqmw3yEXhWieiqUCf4duZTNv7LZX5q8qlgr9HRoiE/mpWCr4d2iKUrROxVLhv0NN1EXjVCwVADzkohDNX+5v0KToVjbzRnF7xQDPL9h00RCZyE/FUp3gQ1OUonUqluoEH2qiLhqnYqlO8CEXhWieiqU6wYduZTNvPLdXJ7gqluoEHxoiE/mpWKoTfGiKUrROxVKd4ENN1EXjVCzVCT7kohDNU7FUJ/jQrWzmjez26gRXxVKd4ENDZCI/FUt1gg9NUYrWqViqE3yoibponIqlOsGHXBSieSqW6gQfupVN3hhvr05wVSzVCT40RCbyU7FUJ/jQFKVonYqlOsGHmqiLxqlYqhN8yEUhmqdiqU7woVvZ5I329uoEV8VSneBDQ2QiPxVLdYIPTVGK1qlYqhN8qIm6aJyKpTrBh1wUonnLlRwJqrRJJX577t2ikt06OEAD/ZYraQFOMMF1y5X0B2ygSpuKkFbtUhnSl0ZlSA+dNMyoDOmhITKRi0J0qo5RGdJD61J7RE3URUNkIheFSHO835q3dhmVId3UH1HbFcuoDOmhITKR7ypmVIb00Ny1y6gM6aF1qfpCUdREXTREtiuWURnSQyGaotwVy6gM6SZ7RE3Ud8UyKkN6yEQuil2xjMqQHkrRuvR+Ud6KZVSG9FAXDZHtimVUhvRQiKYod8UyKkO6KR5RE/VdsYzKkB4ykYtiVyyjMqSHUrQuVV+oFJ9N1EVDZLtiGZUhPRSiKcpdsYzKkG7KR9REfVcsozKkh0zkotgVy6gM6aEUrUvv02GW4quJumiIbFcsozKkh0I0RbkrllEZ0qLKkB5qor4rllEZ0kMmclHsimVUhvRQital6gtFURN10RDZrlhGZUgPhWiKclcsozKkm/ojaqK+K5ZRGdJDJnJR7IplVIb0UIrWpfc+fyuWURnSQ100RLYrllEZ0kMhmqLcFcuoDOkme0RN1HfFMipDeshELopfzm8O2xSlaF2qvlAp7k3URUNkv5zfKXYXhWiKclcsozKkm+IRNVHfFcuoAOkhE7kodsUyKjx6KEXr0nuf128UV3D0UBcNke2KZVRo9FCIpih3xTLqwIhN+YiaqO+KZdShEYdM5KLYFcuogyMOpWhdqr5QKb6aqIuGyHbFMuoAiUMhmqLcFcuoQySK6hSJQ03Ud8Uy6iCJQyZyUZxyZdRpEhcTXMI6Aql+7bg2ey52cIB2f/W4NnwuBjjBvL+I3NsS9ge8pc2ozlLVLtVZOnQrm+orVXVSbaVDXTREJnLRrTrs7hQNuztFw+5O0ahu0qEm6qIhMpGLNEdVBL0oRbeyqYxhVSyVMTzURUNkp4qpjOGhOLVLZQwPpWidiqUyhoeaqIvGqVgqY3jIRSGap2KpjOGhW9lUxvBQOxVLZQwPDZGJ/FQslTE8NEUpWqdiqYzhoSbqonEqlsoYHnJRiOapWCpjeOhWNpUxPNROxVIZw0NDZCI/FUtlDA9NUYrWqVgqY3ioibponIqlMoaHXBSieSqWyhgeupVNZQwPtVOxVMbw0BCZyE/FUhnDQ1OUonUqlsoYHmqiLhqnYqmM4SEXhWieiqUyhoduZVMZw0PtVCyVMTw0RCbyU7FUxvDQFKVonYqlMoaHmqiLxqlYKmB4yEUhmqdiqXDhoVvZVLTwUDsVSwULDw2RifxULBUqPDRFKVqnYqkDEw41UReNU7HUoQmHXBSieSqWOjjh0K1s6uiEQ+1ULHV4wqEhMpGfiqUOUDg0RSlap2KpQxQONVEXjVOx1EEKh1wUonkqljpM4dCtbOo4hUPtVCx1oMKhITKRn4qlDlU4NEUpWqdiqYMVDjVRF41TsdThCodcFKJ5KpY6YOHQrWzqiIVD7VQsdcjCoSEykZ+KpQ5aODRFKVqnYqnDFg41UReNX+7JKSZyUYjmqVjq0IVDt7KpYxcOtVOx1MELh4bIRH7LlegBTjDBdcuVGA/YwA6OW67EMNDBAOctV2IkqNImTKVNdRO/XrYKJ1h/bRYu4XrABtaHzML6kKvQQAff2d5DLUc1Ftt7sOWozuLFdbF6ixff2d7DKkd1F1udL1ntxYsGOhjgBBNcwqotDzaQ2aq2rIMrq9N40cEAJ5jgElZtebCBHWS22n/cJ2TWl+tggBNMcAnry/X+e2KjWo8XOzhAAx0McIIJLqExmzGbMZsxmzGbMZsxmzGbMZsxmzObM5szmzObM5szmzObM5szmzNbMFswWzBbMFswWzBbMFsw2/7txVW4hPu3Fzc23Qz124sHB2iggwHWbFnIHTC5A5I7ILkDkjsgud+S+y2535L7LbnfktmSO2BxByzugMUdsLgDFvfb4n5b3G+L+21xvy3NtraXeGEDOzhAAx3UdVvPBBNc1wZX03Vb+z11Ywd13VYz0MEAJ5jguldzdV231RvYwQEa6GCAE0xQ35I1mG3ouq3RwQEa6GCAE0yQ62YPyGzGdTOum3HdjOtmAU6Q64aXLLzkZF/rYjnXzQfIdXOum3PdnOvmXDfX821nX/clDK5bcN2C6xZct+C6BdctuG7BdQuu2+S6TWabXLfJdZtct8l1m1y3yXWbXLfJdUuuW3LdktmS65Zct+S6JdctuW6ZINdtcd1WA7lu1CWLumQtrtviulGXLOqSpbrEHtUl9mwvycL7nbRHXmKPvMQeeYk9T4ATvN9Je54lbA/YjsPYIy+xpw3QQNeHlJfYIy+xR15iT2NtnbV11iYvsUdeYo+8xB55iT3yEnvkJfbIS+yRl9gjL7FnNJDZ5CX2yEvskZfYIy+xR15ij7zEHnmJPfISe+Ql9lgHmc24bsZ1M66bcd0swSV0rpvqEntUl9jjQ1LLS+xxrptz3Zzrtr2kLosvobzEnmj6DMF3MvhOBmsL1hasTXWJPcF3MvhO7rqkZlNdYo/qEnsma5usbbK2ydpUl9gzWdtEyXxA1pasLVlbsrZ0fd4MkLUld0ByByzugMXaFmtbrG3XJfV5t5ds5A5Y3AGLO2DpDmjPAzawgwM00MEAdQe0J0HdAa09YAM7OEADHQyQ2ZrugNZ03Vp/wAZ2cIC3VrbWHQxwXmtrPcElHLpubTSwgwM00MG4l7ANXbc2EuS6GdfNuG7GdTOum3HdjOtmXDdjNuO6GdfNuW7OdXOum3PdnOvmXDfnujnXzZnNuW7BdcNLGl7S8JKGl7TgugXXDS85J7SUvqH7bZ/QcpDrhpc0vKThJfuEln2xJtcNL2mT7yRe0vCShpc0vKThJS35TuIlDS9pqkus4SUNL2l4ScNLGl7S8JKGlzS8pOElDS9peEnDSzpe0vGSjpd0vKTjJR0v6XhJx0s6XtLxko6XdLyk4yUdL+l4ScdLOl7S8ZKOl3S8pOMlHS/peEnHSzpe0vGSjpd0vKTjJR0v6XhJx0s6XtLxko6XdLyk4yUdL+l4ScdLOl7S8ZKOl3S8pOMlHS/peEnHSzpe0vGSjpd0vKTjJR0v6XhJx0s6XtLxko6XdLyk4yUdL+l4ScdLOl7S8ZKOl3S8pIfut46XdLyk4yUdL+l4SZ+63zpe0qeqoD4nyHcSL+l4ScdLeqrC6zlAvpPlJWWDPVUF9Zwga8NLOl7S8ZK+vaQG216yESWXg6xtsbbF2pbWNh5Vr+NpYAf11lG/1XXRQa1tPBNMUGsb7QEbqLWNpjtgNAMdDHCCCep+G+qX2FC/xAbvOIN3nNF1B4zuYIATTFD32xgP2MAODpDZhq7bGAFOMEGumz0g1824buq92jA51zAHuW7GdTOum3HdXG8dwxvIdXPd3cMNZG3O2py1OWtT79VG8J0M1oaXjP27wjVxsLZgbcHagrXhJQMv2cfj71VM1jZZ22Rtk7VN1oaXDLxk4CX7nPy9imRtydqoS/ZZ+fuTJWtL1oaXDLxk4CUj9bY4Fmtb3AGLO2BxByzut8X9Rl0yqEsGdcmgLjHqEqMusUd3gD0DNNDBACeYoO43oy4x6hKjLrGm62bNQAcDnGCCum7798gONvDuiNn+PbK6APv3yA46GOAEE9R1279HdrCB+pbs3yM7yNrwEsNLDC8x7eOYDdZmrM30fDPT09SMteElhpcYXmJ4iZne8s1Ym/Mtcb4l3sEBGuhggBNMkO9kMFvwLQm+JcF3MvhOBt/J4DsZfCeD72TwnZx8JyezTa4bXmJ4ieElhpcYXmKT64aXGF5iqaepJdcNLzG8xPASw0ss9UZlyXVLPXFsPSDfksXaFmujLrGlCs9WgBPU26LRe3V6r/40sIMDNFAVnj8BTlB3tz9am7cHbGAHB6gKz5uDAU7+rO5up/fq9F69s7bO2vAS76pevbO2zto6s3XW1lnbYG2DteElrj1h88HaBmvDS/YRZv0pTHAJy0sONrCDAzTQwQCZzZjNmM2ZzZnNmc2ZzZnNVZk7vVen9+rOdXOuW3DdgusWqhQ8Bsh1o/fqvOM47zhO79WpS5x3HOcdx3nHcd5xnH6J847j9EucfolTlzhe4niJU5d46vnmeInjJY6XOF7i1CVOXeLUJU5d4quBfCcX38nFdxIv8cVsi9kWs+ElgZcEXhKPrls8AzRQ1y20J2yhPWEL9nGCd5zgHSd4x4nWwQEaqOsWLcAJ6roFdUlQlwR1SVCXBF4S1CVBXRLUJUFdEtQlQV0S1CVBXRJ4SeAlgZcEXrLDS3vcwWyD2QZKGkoaShrXzbhuxnVjHyeM62ZcN+O6sY8Trr2OcGZzrhv7OME+TrCPE3hJONeNfZxgHyfolwTvOKF8iUWgJP2S4B0neMcJ3nGCd5zASwIvCd5xgnecmChJXRKT6zZRcqIkXhKT2ZLZqEuCuiTwksBLIrkDkjuAuiSS2ZI7YHEHLJSk9xr0XmMx20JJvCTwklhct6XrNp8H1NN00i+ZzwANdP5sgJpt0i+ZeMnESyZeMvGS2XTdZjPQQWZrum6zJSglJ73XSV0yqUsmXjLxkomXTLxkdl232RNESeqSqayazYGSeMmk9zrpvU68ZOIlEy+ZeMn+53H2xNbADqrCm8Z1U1bNJl4y2ROe9Esm/ZL9D+UcREm8ZOIl+x/L2Z/BuW4eILM5141+yaRfMum9zmC2YDb6JRMvmXjJxEtmcN2C60a/ZE5mm1y3yXWbKMme8GRPeE5mmyiJl0y8ZCbXLbluyR3AnvBkH2eyjzPZE554yeQdZ9J7nfReJ14y8ZKJl0y85ORe6+Ms7gC8ZNJ7TXqvSe818ZIkX5LkS07utRUGOMEEpWTiJSf3moUdHCCz8Y6TvOMkXpLUJck7TvKOk3hJ4iWJlyRekrzjJO84iZeQe7WTe63PMFASL0nqkqRfknhJ4iWJlyReknhJ4iWJlyReknhJ4iXkXo3cq5F7tcRLEi9JvCTxksRLEi9JvCTxksRLEi9JvITcq5F7NXKvlnhJ4iWJlyReknhJ4iWJlyReknhJ4iWJlyReknhJ4iVJvyTplyReknhJ4iWJlyR1SVKXJF5ycq8bUTKZDS85udeNKEm/JOmX7NxrvYXu3OtBAx0McIIJ6k14514PNrCDAzTQwQAnmCCzNdXKi7pkUZeQezVyr0bu1ci92uId5+ReN+pbsqhLFu84J/e6cYDGn2U26pLFO87iHefkXgvZE16845zc68YBMhvvOEsZelvK0NtiH2fnXrd8vOMs3nEWvddF73XRe130Xk/udQ+GkvReF+845F5tkVVbZNUW+zjkXo3cq5F7NXKvRu7VyL0auVc7udeNKMme8FKG3hZ7wot+ycm97j/LbLzjLN5xFv2SRb9k0S9Z7Akv+iWLfsmi97rovS76JYt+yWJPeNEvWbzjLN5xFv2SRb9k0S9Z9EsW/ZJFv2TRL1n0Sxb9kkW/ZNEvWewJk3s1cq9G7tXJvfqjfok/6r36o36JP+qX+KPeq5N79Uf9Eif36uRe/VHv1cm9+tOYTV7ij7zEyb06uVcn9+qPvMQfeYmf3OvGponlJf7IS/xRvsQf/T6OP53ZOrPJS/zpKDlQcqCkvMSfgZIDJQezyUv8GSg5UFJ7wv4YsxmzGUoaShpKGkrKS/yRl/hjKGnMJi9xcq9O7tUfeYmTe3Vyr07u1cm9+uMo6SgZXDd5iT+BksFswXWTl/gTKCkv8ZN73chsEyUnSk6UnCg5WdvkDpgoOVFyMtvkDkiUTJTUnrA/yWzJbImSiZKJkomSyR2wUHKh5GK2xR2wUHKh5OLuXsy2mA0vaXhJw0saXtLwkoaXNLyk4SUNL2l4ScNLGl7SGrPhJQ0vaXhJw0saXtJUl3xhglKS3Ks31SXe8JKGlzTVJd46s+ElDS9peEnDS8i9elNd4g0vaXhJG8ymusQbXtLwkqa6xNtgNryk4SUNL2l4ScNLTu61PgNe0vCSZsxmXDe8pOElJ/dafxYvaXhJw0saXtLwkoaXNLyk4SUNL2l4CblXb3gJuVcn9+oNL2l4CblXJ/fq5F6d3KuTe3Vyr07u1cm9OrlXJ/fqDS9peEnDS8i9esNLGl7S8JKGlzS8hNyrN7yk4SUNL2l4ScNLGl7S8JKGl7SFknhJw0s6XtLxko6XdO0Je8dLOl7StSfsXb+P4x0v6XhJ1+/jeNeesHe8pOMlHS/peEnHSzp1ScdLOl7SqUvIvXrHSzpeQu7VO3VJx0s6XtLxko6XkHt1cq/e8ZKOl3Tqkk5d0vGSjpd06pJOXdKVVfOOl3S8pOMlHS/p1CXdWBte0qlLuqGkMxte0qlLuqOksmrenbX5fRP2nXs9mOASxgM2sIMDNNBBZgtmC2YLZpvMNpltMttktv2vnJYkEyUnSk6+JZNvyeRbknxL1Hv1nnxLkm9JoqR6r96Tb0nyLVHv1cm9OrlXJ/fqffEtWXxLFt+Sxd29uLsX35LFbEt3N7lXJ/fqQ7/b5yf3moWabaj36uRendyrk3t1cq9+cq81mHqvTu7Vh/IlPpQv8aHeqw/1Xn0oX+KjMVtjNvVefaj36kO9Vx/qvfpQvsSHeq8+1Hv10Zmt6+4eHSUHSipf4mMw22C2gZIDJQdKDpQcurtP7rXQUNKYTblXJ/fqw1BSe8K+c6/7whqzGUoaSjpKOko6a3PdAcNR0lFSuVcfOnPAh6Oko6T2hH0EswWzBUoGSgZKBkqG7oARKBkoOZltcgdMlJwoqT1h37nXLR9eMvCSgZcMvGTgJSNZG14y8JKRKJlcN7xk4CUjUVL7OD7wkoGXDLxk4CUDLxkLJfGSgZeMhZLax3HDSwwvMe3juGkfxw0vMbzE8BLDSwwvMbzE8BLDSwwvIffqhpcYXmJ4CblXN7zE8BLDSwwvMbyE3KsbXmJ4ieElhpcYXmJ4ieElhpeQe3XDSwwvMbzE8BLDS2ywNrzE8BIzlDRmw0sMLzFDSf2esJN7dcNLDC8xvMTwEsNLDC8xvMTwEsNLDC8xvMTwEsNLDC8xvMTwEsNLDC8xvMTwEsNLDC8xvMTwEsNLDC8h9+pGXWJ4ieElhpcYXmJ4iVGXGF5ieIlRlxh1ieElhpcYdYlRlxheYniJ4SWGlxheYtQlhpcYXmLUJUZd4niJ4yVOXULu1cm9uuMljpc4XuJ4ycm9vp/B8RLHS8i9+sm91mfAS8i9uitf4uRendyrk3t1cq9O7tXJvTq5Vyf36uRendyrk3t1x0scL3G8hNyrk3t1x0scL3G8xPESx0scL3G8xPESx0scL3G8xPESx0scL3G8xPESx0scL3G8xPESx0scL3G8xPESx0scL3G8xPESD5TESxwvcbzE8RLHSzxYG17ieIlPlJzMhpc4XuITJbUn7I6XOF7ieInjJY6XOHWJ4yWOlzh1iVOXOF7ieIlTlzh1ieMljpc4XuJ4ieMlTl3ieInjJU5d4tQlgZcEXhLUJUFdEsqXeOAlgZcEXhJ4CblXJ/fqgZcEdUkoX+LRmA0vCeqSUL7Eyb16NNbW9Sa8c68HOzhAAx0McIIJ6r17514PMttgtsFsg9kGsw1mG8y2D+0rSei9knt1cq8e9EuCfknQLwl6r0HvNeiXBL3XoPca9F6DfknQeyX36uRendyrk3v1oPca9F7JvXrQew16rxHMptyrB73XoPcaOr/Ed+51yxfMRu+V3KsHvdeg9xr0XkN7wh70XoPea2hP2EN7wh70XoPea2hP2Mm9OrlXJ/fqQe816L0GvdfQ7+N40HsNeq+xmG1xd9N7DXqvod8TdnKvTu7Vg95r0Hud9F4nvdepDL1P9nEmvVdyrz6VoffJPs6k9zr1+zg+lS9xcq9O7tUnvddJ73XSe530Xif7OJPe66T3Su7VJ/s4k97rpPc62cch9+rkXn3Se530Xie910nvdbKPM+m9Tnqvk32cyT7OpPc66b1O9nGm8iU+8ZKJl0y8ZOIlEy+Z9F4nXjLxkknvdbInPPGSiZdMeq+TfZyJl0y8ZOIlEy+ZeMlkH2fiJRMvmezjTPZxJl4y8ZLJPs5kH2fiJRMvmXjJxEsmXjLxkomXTLxk4iUTL5l4ycRLJl4y8ZKJl0y8ZOIlEy+ZeMnESyZeMvGSiZdMvGTiJRMvmXjJxEsm+zic9+qc9+qc9+qc9+qJlyT7OImXJF6S7OMke8KJlyRekuzjJHvCiZckXpJ4SeIliZckXpJ4SeIliZckXpJ4SeIliZdw3qsnXpJ4SeIliZckXpJ4SeIliZckXpJ4Cee9Oue9Oue9euIl5F498ZLESxIvSbwk8ZKkLkm8JPGSpC7hvFfnvFfnvFdP6hJyr554SeIliZckXpJ4SVKXJF6SeElSl3Deq3Peq3Peqyd1CblXT7wk8ZLESzjv1Tnv1XNy3fCSxEvIvXpOrhteknhJJt9JvITcqydeknhJ4iWJlyReknhJ4iWJl5B79cRLEi9JvCTxksRLEi9JvCTxkoWXLLxk4SULL1l4ycJLFl7Cea/Oea++8JKFl5B7dXKvTu7Vyb06uVcn9+rkXp3cq5N7dXKvTu7Vyb06uVcn9+qLPWFyr07u1cm9OrlXJ/fqiz1hcq9O7tUXe8KLPWFyr07u1Rd7wos9YXKvTu7Vyb06uVcn9+rkXp3cq5N7dXKvTu7Vyb06uVcn9+rkXp3cq5N7dXKvTu7Vyb06uVcn9+rkXp3cq5N7dXKvTu7Vyb06uVdf5EvIvTq5Vyf36uRendyrL/Il5F6d3Ksv8iWLfAm5Vyf36ot8ySJfwnmvvnOv9aK7c68HA5xggnrv3rnXgw3s4ACZbTHbYrbFbIvZlKGPRxn6eJShj517fYvpeNR7jUe913jUL4lH/ZJ41C+JR/2SeNR7jUe913jUL4lHvdd41HuNR73XeNQviUe91yD3Gpz3Gpz3Gpz3Go96r/Go9xon91qfQb3XeNR7jaczW5/6DOq9xqPeazz63b7Yudct32C2gZIDJQdKDpQcrE17wvEMlDSU1J5wPNoTjsdQ0lBSe8LxGLMZsxlKGko6SjpK6iykeBwlHSWd2XQOfTyOko6SOlctnmC2YLZAyUDJQMlAyQh9Bu3jxBMoGcw2H30G7ePEM1FS55fEo3xJcN5rcN5rPBMlJ0pOlEzWltwBiZKJktrHCc57Dc57Dc57jUf7OMF5r8F5r8F5r8F5r8F5r/EslFzcAQslF0ouZtM+TjT1XqOp9xpN+zjRlC+Jhpc0vKThJQ0vaXhJU+81Gl7S8JKm3ms07QlHw0saXtLUe42mfZwvZDa8pOElDS9peEnTPk40vKThJU37ONE6s+ElDS9pAyW1jxOc9xqc9xqc9xqc9xoNL2l4ScNLGl7S8JKGlzS8pOElDS9peEnDSxpe0vCShpc0vKThJQ0vaXhJw0saXtLwkoaXNLyE816D816j4SUNL2l4ScNLGl7SgrXhJQ0vaYGSk9nwkoaXtImS2hOOhpc0vKThJQ0vaXhJw0saXtLwkoaXNLyE816D816j4SUNL+G81+C81+C81+C81+C812h4Cee9RsNLGl7S8JKGl3S8pOMlHS8h9xodL+l4ScdLOl7S8ZJOXdLxko6XdOqSTl3S8ZKOl3TqEnKv0fGSjpd0vKTjJR0v6dQlHS/peEmnLunUJR0v6XhJpy4h9xqc9xqc9xqc9xqc9xodLzm51/oMeEnHS8i9RjeuG17S8ZKuc+ij4yXkXqPjJR0v6XhJx0s6XtLxko6XdLyE3Gt0vKTjJR0v4bzX4LzX6HhJx0s6XtLxko6XdLyk4yUdL+l4ScdLOl7S8ZKOl3S8hNxrkHsNcq9B7jXIvQa51yD3GuReg9xrkHsNcq9B7jXIvQa51+iJkngJudcg9xrkXoPca/TF2vAScq/RF0pqTzjIvQa51+C81xjaEw5yr0HuNci9BrnXIPca5F6D3GuQew1yr0HuNci9BrnXIPca5F6D3GuQew1yr0HuNci9BrnXIPca5F6D3GuQew1yr0HuNci9BrnXGMqXBLnXIPca5F6D3GuQe40xWBteQu41hqGkMRteQu41hqGk8iUxjLXpXLUYOlcths5Vi6Fz1WLoXLUYOlcths5Vi517PRjgBJnNmS2YLZgtmC2YLZgtmC1upjc47zU47zU47zXG5Fsy+ZZMviXqvcaYfEsm35KJkuq9xph8SybfEvVeg9xrjGS25FuSfEuSb0nyLdFZSDHUew3Oe42xmG1xdy/u7sW3RGc0xs69bvkWsy2UXCip3muYeq9h6r2GaU84TL3XMPVew7QnHKY94TD1XsPUew3TnnBYY7bGbOq9hqn3Gqbea5h6r2E6Vy1Mvdcw9V7DGrPpXLXgvNcw9V7DdA59cN5rcN5rcN5rcN5rcN5rWEdJnasWnPcaNlByMJvOVQvTPk7YQEmd9xqmfEnYYDZDSUNJQ0lDSWNt2scJM5Q0lNQ+Tpj2ccIcJR0ltY8T5szmzOYo6SjpKOkoqX2csEDJQMlgNu3jhAVKBkpqHydM+ZIwvMTwEsNLDC8xvMQma8NLDC+xiZKT64aXcN5rcN5rmPZxgvNeg/Neg/Neg/Neg/NewxIl8RLDS2yh5GI2vMTwElsoubi78RLDSwwv4bzX4LzX4LzXcLzE8RLHSxwvcbzE8RLHSzjvNRwvcbzE8RLHSxwvcbzE8RLHSxwvcbzE8RLHSxwvcbzEtY8Tjpc4XuJ4ieMljpf4YG14ieMlPlByMBte4niJD5TUnnA4XuJ4ieMljpc4XuJ4ieMljpc4XuJ4ieMljpc4XuJ4ieMljpc4XsJ5r8F5r8F5r+F4ieMljpc4XuJ4ieMljpc4XkLuNRwv4bzX4LzX4LzX4LzXcOoSx0s47zWcusSpSxwv4bzXcOoScq/heAnnvQbnvQbnvQbnvYZTlzhewnmv4dQlTl3ieAnnvYZTl5B7Dc57Dc57Dc57Dc57Dc57jdC/2xec9xqc9xrkXuPkXqMwwAkmf1Z3N7nX4LzX4LzX4LzX4LzXCLyE816D814j8BJyr8F5r8F5rxF4SeAlgZdw3mtw3mtw3mtw3msEXhJ4Cee9RuAlgZcEXsJ5rxF4SeAlgZeQew1yr0HuNci9BrnXIPca5F6D3GuQew1yr0HuNci9BrnXIPca4SiJl5B7DXKvQe41yL1GOGvDS8i9RgRKBrPhJeReIwIltScc5F6D3GuQew1yr0HuNci9BrnXIPca5F6D3GuQew1yr0HuNci9BrnXIPca5F6D3GuQew1yr0HuNci9BrnXIPca5F6D3GuQew1yrxHKlwS51yD3GuReg9xrkHuNqXxJkHsNcq8xlS8JznsNcq9B7jWm8iUxlS+JqTMHYude60V3514PGuhggBNMUO/dUxn6mMrQx+zM1pmtM1tnts5sndk6s3VmGzfTG5Pe66T3OumXcN5rcN5rcN5rTHqvk97rpF8y6b1Oeq+T3uukXzLpvZJ7jUnvddJ75bzX4LzX4LzXmPr3cWLSe530Xqczm/5t8pj0Xie916l/Hyd27nXLx57wpPfKea/Bea/Bea/Bea8x2ROe9F457zUme8KTPeFJ75XzXmOyJzwns9F75bzX4LzX4LzX4LzXOLnX+gz0XjnvNWYym/6treC81+C815j6d/tiJrOxj8N5r8F5r8F5r8F5rzEXdzf7OJz3GnMx2+LuZh+H814jdXZ0JPmSZB8n6b1y3mtw3mtw3mtw3msk+zhJ75XzXiPZx0n2cZLeK+e9RrKPk+zjJL1XznsNznsNznsNznuNZB8n6b1y3msk+zjJPk7Se+W810j2cZJ8SeIliZdw3mtw3muk/t2+SLwk8ZJUVi0SL0n2hMm9BrnXIPcaiZckXpJ4SRqzGdfNuW7ObMqqRTrXzblu7OOQew1yr0HuNZK6JPGSxEuSuiSD6xZct2A26pIMrltw3fAScq9B7jXIvUZSl5B7DXKvkdQlSV2SyqpFTmZjH4fzXoPca5B7DXKvQe41MpmNdxxyr5Hs4+Ti7uYdh9xrpP59nEj2cZJ3nOQdh9xrkHsNcq+xdA59LN5xFu84i32cpXPoY/GOs3jHWToLKRZestjHWbzjkHsNcq9B7jWWzqGPpXPoY/GOs9jHWTqHPpbOoY/FO87SWUix8JLFPs6i98p5r7HYx1k6OzqWzqGPpX8fJxZestjHWXjJwksWXrLwkkVdstjHWXjJoi5Z7OMsvGRRlyzqksU+zmJPeOElCy9Z1CWLumRRlyz2hBd1yaIuWewJL7xkUZcs6pLFnvBiT3jhJQsvWdQli7pk4SUn97qR68Y7DrnXWHgJudcg9xrkXoPca5B7jUVdQu41yL3Gmlw3vITca5B7jZVcN+oSznsNznsNznsNznuNhZdw3mtw3mss3nE47zUWXrLwkoWXLLyE815jsSe89G9azEdeMh/VJfNRvmQ+8pJJ7nWSe53kXie513lyr3tcZmvM1pitMVtjtsZsjdkaszVma8zWmK0zW2e2zmyd2TqzdWbrzNaZrTNbZ7bBbIPZBrMNZtu/J7yx3qhmYYD1RrUHS7DeqNaL+9/a2tg02P63tmqE/W9tbTSNsP+trY3BCBNMBlsaYe8Jb2waYe8JbxwaYe8Jb3QN5qxt7wlvZG17T7gwWNveE97YNViwtr0nvJG17XPVNrK2fa7axqXBJmvb56ptZG37XLWNrK285GAwGGsrLznI2spLDrK28pKDQ4Mla0u+Jcnakm9JsrbkW7Iz9DXYYm2Lb8libYtvyWJti29JecmIwne2sf/Xdzb7esufO/d6sIHvbGaF72wWhe9sloXvbN4K39l8FE7wnS164RKWl0SNW15y8J0taorykqgpyktmfZzyklnjlpdML5zgO1vuwZawvCRr3PKSg+9sWVOUlxx8Z1uz0MF3trUKJ5hX1J17LVF37nXLN1CyvOTgkKjlJVvU8pItannJFnWgZHnJQZQsLzmIkuUlB4dELS/ZopaXbFHLS7aohpLlJQdRsrzkIEqWlxxEyfKSgyhZXnIQJctLDi6JWl6yRQ2UDJQsLzloErW8ZItaXrJFLS/ZogZKlpdsnChZXnIQJctLDppELS/ZopaXbFHLS7aoEyXLSzYmSpaXHETJ8pKDKFlechAly0sOomR5ycbyki1qeckWdaHkQsnykoMuUctLtqjlJVvU8pIt6pKSO/d6UEru3OtBKblzrwf9irpzryXqzr2WqDv3Ove4UnLnXg9KyZ17PSgld+71oJTcudeDUnLnXg9KyZ17PdiuqDv3Ovb/KiV37vWgg3FF3blX2yPkFXXnXkvUnXvdSpaXHETJ8pKDKFlecjAkannJFrW8ZItaXrJFNZQsLzmIkuUlB1GyvOQgSpaXHETJ8pKNjpLlJQe7RC0v2aI6SjpKlpccnBK1vGSLWl6yRS0v2aIGSpaXHETJ8pKDKFlecnBK1PKSLWp5yRa1vGSLOlGyvOQgSpaXHETJ8pKDKFlechAly0sOomR5ycEhUctLtqiJkomS5SUHU6KWl2xRy0u2qOUlW9SFkuUlB1GyvOQgSpaXHEyJWl5Sou7ca4m6c68l6s69lpI793pQSu7c60EpuXOvB6Xkzr1ubFJy514PSsmdez1oV9Sdex37f5WSO/d6MMF1Rd251xJ1515L1J17LVF37rWU3LnXg1Jy514PSsmdez24rqg797pFLS/ZopaXbFEHSpaXHETJ8pKDKFlechAly0sOomR5yUGULC856BK1vGSLaihpKGmqXnfudYtaXrJFLS/ZopaXbFEdJctLDqJkeclBlCwv2VheskUtL9milpdsUctLtqiBkuUlB1GyvOQgSpaXbJwoWV5yECXLSw6iZHnJwZCo5SVb1ImSEyXzAZtELS/ZopaXbFHLS7aoiZIZIEpmgii5HrBJ1PKSLWp5yRa1vGSLulByBYiSK0EpuXOvB6Xkzr0elJI793pQSu7c60G9Ue3c69j/q5TcudeDDdQb1c69lqg791qi7txribpzr6Xkzr0elJI797qxS8mdez2oN6qdey1Rd+61RN251xJ1515LyZ17PSgld+5140DJ0UCUHANEyeEgSo4J6o1q5163qIaShpLWQb1R7dzrFtX0RrVzr1tUQ0lLECX9AVHSO6g3qp173aK63qh27nWL6ijpCaJkPCBKRgdRMgxEyQgQJSNBvVHt3OsWdaLkRMk5QL1R7dzrFnXqjWrnXreoEyWn3gN27nUrmQ1EyRyg3qh27nWLmnqj2rnXLWqiZOo9YOdet5KrgSi5BoiSy0GUXBNEyaX3gJ17LVF37nXs/1VK7tzrQQP1RrVzr7ZH0BvVzr2WqDv3Wkru3OtBKblzrwel5M69HtQb1c69lqg791qi7tzr3ONKyZ17PSgld+71oJTcudeDUnLnXg9KyZ17PYiS4wH1RrVzr1vUgZIDJYeDeqPaudct6tAb1c69blENJa2BKGkDRElzUG9UO/e6RTW9Ue3c6xbVUdIbiJI+QJR0B1HSJ4iSrveAnXvdSkYD9Ua1c69b1EDJQMkIUG9UO/e6RQ29Ue3c6xZ1ouTsIEpOA1FyBqg3qp173aJOvVHt3OsWNVEyO4iSaSBKZoAomQmi5HpAlFwd1BvVzr1uURdKLpRcE9Qb1c69lqg791qi7txribpzr6Xkzr0elJI793pQSu7c60G9Ue3ca4m6c68l6s69lqg791pK7tzrQSm5c68HpeTOvR6Ukjv3urFLyZ17PSgld+71oN6odu517P9VSu7c68EE9Ua1c69b1KE3qp173aIOlBwGouQIECVHgnqj2rnXLarpjWrnXreohpJmIEpagChpCaKkPyBKegdR0g3UG9XOvW5RHSUdJV3V6869blFDb1Q797pFDb1R7dzrVjIcRMmYIEqG3gN27nWLOvVGtXOvW9SpN6qde91KTgdRck4QJafeA3budSuZDUTJHCBKpoN6o9q51y1qomSi5HpAvVHt3OsWdemNaudet6gLJVeAKLkSlJI793pQb1Q791qi7txribpzryXqzr2Wkjv3elBK7tzrQSm5c68HpeTOvR6Ukjv3elBK7tzrQb1R7dzr2P+rlNy514MN1BvVzr2WqDv3WqLu3GuJunOvpeTOvR6Ukjv3unGg5Gig3qh27nWLOvRGtXOvW9SBkmOCKDn0HrBzr1tJayBK2gBR0hxESZvg12xfrffC9WLN9npJrw3xyr1+9cUL+4v1IV8vuWigv1jjvl7y1QEvnC/Wil8v+WpwF76z1ZZk5V4vvrON+ryvl1x8Z9uX+/WSi+9sVlO8XvLVfS58Z7P6OK+X9H2NXy/56ii/+HrJxXc2r8FeL7n4zhY17uslF9/ZoqZ4veTiO9ss+V4vufjONkuz10suNomaXaImSiZKpoMhUXNK1EyJmkuiLpR8veQiSq4BouTrJRdDoq4pUVdK1NdLtqiVe91KVu71opSs3OtFKVm514tSsnKvF6Vk5V4PNilZudeL/YpaudctauVet3yVe70Y4LyiVu51i1q51y1q5V63qJV73UpW7vWilKzc60UpWbnXi/OKWrnXLWrlXreolXs9og6UHB1EyddLLqLkCBAlXy+5iJL2gCj5esnFIVHNJKqhpKGkTTAlannJFrW8ZItaXrJFdZQsLzmIkuUlB1GyvORgStTyki1qeckWtbxkixooWV5yECXLSw6iZHnJQZQsL9k4UbK85CBKlpccNIlaXrJFnSg5UbK85OCSqOUlW9Tyki1qeckWNVGyvOQgSpaXHETJ8pKDS6KWl2xRy0u2qOUlW9SFkuUlB1GyvOQgSpaXHJSSlXu9KCUr93pRSlbu9aJfUSv3ukWt3OuWr3KvF5ewvKRErdzrFrVyr1vUyr1uUSv3upWs3OtFKVm514tSsnKvB8tLStTKvW5RK/e6Ra3c6xa1cq9bycq9XpSSlXu9KCUr93pwoGR5yUGULC85iJLlJQdDopaXbFEHSg6ULC852CRqeckWtbxki1peskU1lCwvOYiS5SUHUbK85GCTqOUlW9Tyki1qeckW1VGyvOQgSpaXHETJ8pKDKFlechAly0sOomR5ycEpUctLtqiBkhMly0sOdolaXrJFLS/ZopaXbFEnSpaXHETJ8pKNiZLlJQe7RC0v2aKWl2xRy0u2qImS5SUHUbK8ZONCyfKSgyhZXnIQJctLDqJkecnBlKjlJa+oWbnXki8r93qxg+OImpV7LVGzcq8lalbutUTNyr2Wklm514tXyazc68WrZFbu9eI4omblXkvUrNxriZqVey1Rs3KvpWRW7vXiVTIr93rxKpmVe714lczKvV68SmblXi9eJbNyrxfXETUr93pEHSg5UHIM0CRqeckWtbxki1peskUdKDmW0FDSGoiSNkCTqOUlW9Tyki1qeckW1VDSltBR0huIkj5AlHQHUdIniJK+hPFI1GgSNVAyUDIMdIkaIVFjStRIiRooOR8QJWcHUXIa6BJ1hkSdU6LOlKgTJfMBUTI7iJJpIEpmgCiZCaLkesAmUVeXqAslF0ouB0OirilRV0rUdd+osnKvW8nKvV6UkpV7vSglK/d68b5RZeVet6iVe92iVu51i1q5161k5V4vSsnKvV6UkpV7vSglK/d6UUpW7vVgl5KVe71436iycq9b1Mq9bvkq93oxwPtGlZV73aJW7nWLWrnXI+pAydFBlBwGouQIcErUkRJ1LIlqj0Q1lLQOoqQZiJIWIEpagijpD4iS3sEhUd0kqqOko6RPMCWqL4kaj0SNJlEDJWOAKBkOomRMMCVqLIk6H4k6m0SdKDkHiJLTQZScE0TJuYSJktlAlMwBmkRNl6iJkomSmeCSqOuRqKtJ1NUl6kLJZSBKrgBRciV436iycq9b1Mq9blEr97pF7Y+UrNzrRSlZudeLUrJyrxelZOVeL0rJyr1elJKVe71436iyt/tGlb1Jycq9XlzCft+osvf7RpW93zeqrNzrFrVyr1vJyr1elJKVe70oJSv3enA8EnU0iTq6RB1Dog6UHA6i5JggSo4lNJS0BqKkDRAlzcGQqDYlqqGkoaQ/YJOo3iWqD4nqJlEdJT1AlPQEUTIesEnU6BI1hkQNk6iBkhEgSkaCKDkfECVnB1FyGoiSM8ApUWdK1ImSiZLZwC5Rc0jUNImaLlETJXOCKJl6D6jc61FyNbBL1DUk6jKJulyiLpRcE0TJpfeA8UjJyr1elJKVe70oJSv3elFKVu714n2jyvHojWo0KVm514sd1BvVaHqjGk1vVJV73aJW7nUrOVqCUrJyrxelZOVeL+qNqnKvW9TKvW5RK/e6RR1dSlbu9SJKjgdEydFBlBwGouQIECVHgnqjGqY3qmEoaShpA9Qb1TC9UQ3TG1XlXo+ohpKm94DhKOkNREkfoN6oKvd6RHW9UVXu9YjqKOl6D6jc61EyGoiSMUCUDAdRMiaIkqH3gDH1RjWm3qjGRMmJktNAvVGNqTeqMfVGVbnXI+pEyXxAlMwOomQaqDeqyr0eUVNvVJV7PaImSq4HRMnVQZRcBqLkChAlV4JSsnKvF6tSiMJ6vmVhufIqNNDBACeY4BLufZyNDXxny6dwgAY6GCCzNWZrzFZesv9seclBZuvM1pmtM1tnts5sndk6sw1mG8w2mG0w22C2wWyD2QazDWYbzGbMZsxmzGbMZsxmzGbMZsxmzGbM5szmzObM5szmzObM5szmzObM5swWzBbMFswWzBbMFswWzBbMFswWzDaZbTLbZLbJbJPZJrNNZisvyVaY4BKWlxxsYAdrtl5Ys41CBwOcYIJLWF5ysIEdHCCzlZdkmUJ5ycEJJrguVu71YgM7OEADHazZvHCCCS5heckbhcjKvV6s2WbhAA10MMAJ1mxZuITbS1ZhA9/Z1lP4zrZa4Tvb6oUOBvjOtmrF5SUHl7C8ZP/Z8pKDHRz8WQMdrNlKqPKSgwkuoTGbMZsxW3nJGoUGOhjgBFmbsbbykoNNn6G85OAADXSQtTlrc9ZWXrI/erC2YG3lJftDBmsL1hasLVhbsLbykoOsbbK28pKDrG2ytsnaJmubrG2ytsnaJtctWVuytuS6JWtL1pasLVlbsrZkbeUlGxdrW6ytvOQga1usbbG2xdoWa1usbWltlXu9qLVV7vXiALW2yr1eDHCCCWptlXu9qLVV7vXiALW2yr1eDHCCCbK2ztp6A1lbZ214SXTW1llbZ22dtXXWNljb9pKNrA0vCbwkBmvDSwIvCbwk8JIw1maszTrI2oy1mYOsDS8JY23G2py1OWvzDrI2Z23uIGvDSwIvCWdtwdqCtQVriwGytmBtESBrw0siWNtkbZO1TdY2B8jaJmvbXrKRteElgZdEsrZkbcnakrUld8D2kigMsGabhQku4faSjTVbFnZwgAbWbKswwK/ZvnoihQmuF9/nceVeL7YXe2EHx4tWaC/GX//hl//7+7/88ff/9Kc//J9ffvcfX//1f/37n//53/74L38+//Xf/t9/vf/PP/3lj3/60x//9z/+61/+5Z//8D///S9/+Mc//cs/v//fL8/7H6+3/D/d/qGv//H1hxv/0/yH0f/HX//61//x1/8P","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    crate::assert_constant(separator);\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"/// Game Move circuit.\n/// Proves that a game move is valid: one card placed from correct player,\n/// board state correctly updated with capture logic.\n///\n/// Public inputs:\n///   card_commit_1, card_commit_2 - player card commitments (poseidon2 hash)\n///   start_state_hash - hash of board state before this move\n///   end_state_hash - hash of board state after this move\n///   game_ended - 1 if game over, 0 otherwise\n///   winner_id - 0=not ended, 1=player1 wins, 2=player2 wins, 3=draw\n///\n/// The circuit verifies:\n/// 1. The placed card is in the current player's committed hand (card_commit binding)\n/// 2. Chain capture logic: BFS-style iterative capture with up to 8 passes\n///    (a captured card can trigger further captures of adjacent opponent cards)\n/// 3. Non-placed, non-captured cells are unchanged between board_before/board_after\n/// 4. Scores are consistent with board ownership + hand counts\n/// 5. Game end detection and winner determination\n\n/// Board cell: each cell is (card_id, owner) where owner 0=empty, 1=player1, 2=player2\n\nuse poseidon::poseidon2::Poseidon2;\n\n// ====================== CARD DATABASE ======================\n/// Hardcoded card rank database: 50 cards with ranks [top, right, bottom, left].\nfn get_card_ranks(card_id: u32) -> [Field; 4] {\n    assert((card_id >= 1) & (card_id <= 50), \"Invalid card ID for rank lookup\");\n\n    // Level 1 - Common (IDs 1-10)\n    if card_id == 1 { [1, 4, 1, 5] }         // Mudwalker\n    else if card_id == 2 { [5, 1, 1, 3] }    // Blushy\n    else if card_id == 3 { [1, 3, 3, 5] }    // Snowdrop\n    else if card_id == 4 { [6, 1, 1, 2] }    // Sunny\n    else if card_id == 5 { [2, 3, 1, 5] }    // Inkwell\n    else if card_id == 6 { [2, 1, 4, 4] }    // Stripes\n    else if card_id == 7 { [1, 5, 4, 1] }    // Barkeeper\n    else if card_id == 8 { [3, 1, 5, 2] }    // Dotty\n    else if card_id == 9 { [2, 1, 6, 1] }    // Penny\n    else if card_id == 10 { [4, 3, 2, 4] }   // Peaches\n    // Level 2 - Uncommon (IDs 11-20)\n    else if card_id == 11 { [2, 6, 1, 6] }   // Freckles\n    else if card_id == 12 { [7, 1, 3, 1] }   // Camo\n    else if card_id == 13 { [6, 2, 2, 3] }   // Neon\n    else if card_id == 14 { [5, 3, 3, 4] }   // Glow Bug\n    else if card_id == 15 { [6, 1, 4, 3] }   // Limelight\n    else if card_id == 16 { [3, 4, 5, 3] }   // Marble\n    else if card_id == 17 { [5, 3, 2, 5] }   // Sapphire\n    else if card_id == 18 { [5, 1, 3, 5] }   // Jefferson\n    else if card_id == 19 { [5, 2, 5, 2] }   // Longfoot\n    else if card_id == 20 { [4, 2, 4, 5] }   // Featherfin\n    // Level 3 - Rare (IDs 21-30)\n    else if card_id == 21 { [3, 7, 2, 5] }   // Lilac\n    else if card_id == 22 { [5, 2, 5, 5] }   // Patches\n    else if card_id == 23 { [6, 6, 3, 3] }   // Faded\n    else if card_id == 24 { [6, 3, 6, 3] }   // Gold Dust\n    else if card_id == 25 { [3, 5, 5, 5] }   // Phantom\n    else if card_id == 26 { [7, 5, 1, 3] }   // Ash\n    else if card_id == 27 { [7, 1, 5, 3] }   // Cocoa\n    else if card_id == 28 { [5, 3, 6, 3] }   // Ringmaster\n    else if card_id == 29 { [5, 6, 2, 4] }   // Goldrush\n    else if card_id == 30 { [4, 4, 7, 2] }   // Swampling\n    // Level 4 - Epic (IDs 31-40)\n    else if card_id == 31 { [3, 6, 4, 7] }   // Glitter\n    else if card_id == 32 { [7, 2, 3, 7] }   // Starfield\n    else if card_id == 33 { [2, 3, 7, 7] }   // Specter\n    else if card_id == 34 { [6, 5, 5, 5] }   // Saffron\n    else if card_id == 35 { [4, 7, 6, 2] }   // Stardust\n    else if card_id == 36 { [2, 3, 7, 8] }   // Achoque\n    else if card_id == 37 { [1, 7, 6, 4] }   // Zacapu\n    else if card_id == 38 { [7, 3, 1, 6] }   // Laguna\n    else if card_id == 39 { [7, 4, 4, 4] }   // Streamwalker\n    else if card_id == 40 { [3, 7, 3, 6] }   // Digger\n    // Level 5 - Legendary (IDs 41-50)\n    else if card_id == 41 { [6, 7, 3, 7] }   // Eclipse\n    else if card_id == 42 { [6, 5, 8, 4] }   // Kaleidoscope\n    else if card_id == 43 { [6, 5, 6, 6] }   // Twinned\n    else if card_id == 44 { [3, 6, 7, 8] }   // Sparkletail\n    else if card_id == 45 { [7, 6, 5, 6] }   // Riddler\n    else if card_id == 46 { [3, 10, 2, 1] }  // Rosita\n    else if card_id == 47 { [6, 2, 6, 7] }   // Brooklet\n    else if card_id == 48 { [5, 5, 7, 6] }   // Whisper\n    else if card_id == 49 { [7, 7, 4, 2] }   // Misty\n    else { [7, 2, 7, 4] }                    // Lerma (50)\n}\n\n// ====================== HASH FUNCTIONS ======================\n\nfn hash_board_state(board: [Field; 18], scores: [Field; 2], current_turn: Field) -> Field {\n    let mut inputs: [Field; 21] = [0; 21];\n    for i in 0..18 {\n        inputs[i] = board[i];\n    }\n    inputs[18] = scores[0];\n    inputs[19] = scores[1];\n    inputs[20] = current_turn;\n    std::hash::pedersen_hash(inputs)\n}\n\n// ====================== ADJACENCY TABLES ======================\n\n// NEIGHBORS[cell][dir] = neighbor cell index, or 9 = out-of-bounds\n// Directions: 0=top, 1=right, 2=bottom, 3=left\nglobal NEIGHBORS: [[u32; 4]; 9] = [\n    [9, 1, 3, 9], // cell 0 (0,0)\n    [9, 2, 4, 0], // cell 1 (0,1)\n    [9, 9, 5, 1], // cell 2 (0,2)\n    [0, 4, 6, 9], // cell 3 (1,0)\n    [1, 5, 7, 3], // cell 4 (1,1)\n    [2, 9, 8, 4], // cell 5 (1,2)\n    [3, 7, 9, 9], // cell 6 (2,0)\n    [4, 8, 9, 6], // cell 7 (2,1)\n    [5, 9, 9, 7], // cell 8 (2,2)\n];\n\n// DIR_RANKS[dir] = [attacker_rank_idx, defender_rank_idx]\n// top: attacker's top(0) vs defender's bottom(2)\n// right: attacker's right(1) vs defender's left(3)\n// bottom: attacker's bottom(2) vs defender's top(0)\n// left: attacker's left(3) vs defender's right(1)\nglobal DIR_RANKS: [[u32; 2]; 4] = [[0, 2], [1, 3], [2, 0], [3, 1]];\n\n// ====================== MAIN CIRCUIT ======================\n\nfn main(\n    // Public inputs\n    card_commit_1: pub Field,\n    card_commit_2: pub Field,\n    start_state_hash: pub Field,\n    end_state_hash: pub Field,\n    game_ended: pub Field,\n    winner_id: pub Field,\n    // Private inputs - move data\n    current_player: Field,       // 1 or 2\n    card_id: Field,              // ID of card being placed\n    row: Field,                  // 0-2\n    col: Field,                  // 0-2\n    // Private inputs - board state\n    board_before: [Field; 18],   // 9 cells x 2 fields (card_id, owner)\n    board_after: [Field; 18],\n    scores_before: [Field; 2],\n    scores_after: [Field; 2],\n    current_turn_before: Field,\n    // Private inputs - current player's hand commitment data\n    player_card_ids: [Field; 5],\n    blinding_factor: Field,\n) {\n    // ===== 1. Validate current player =====\n    assert(\n        (current_player == 1) | (current_player == 2),\n        \"Invalid player\",\n    );\n    assert(current_player == current_turn_before, \"Not this player's turn\");\n\n    // ===== 2. Validate position =====\n    let r = row as u32;\n    let c = col as u32;\n    assert(r < 3, \"Row out of bounds\");\n    assert(c < 3, \"Col out of bounds\");\n\n    // ===== 3. Verify card_commit binding =====\n    // Recompute the current player's card_commit from their hand data\n    let mut to_hash: [Field; 6] = [0; 6];\n    for i in 0..5 {\n        to_hash[i] = player_card_ids[i];\n    }\n    to_hash[5] = blinding_factor;\n    let recomputed_commit = Poseidon2::hash(to_hash, 6);\n\n    // Verify it matches the correct card_commit (1 or 2 based on current_player)\n    if current_player == 1 {\n        assert(recomputed_commit == card_commit_1, \"Player 1 card commit mismatch\");\n    } else {\n        assert(recomputed_commit == card_commit_2, \"Player 2 card commit mismatch\");\n    }\n\n    // ===== 4. Verify placed card is in committed hand =====\n    let mut card_found: bool = false;\n    for i in 0..5 {\n        if player_card_ids[i] == card_id {\n            card_found = true;\n        }\n    }\n    assert(card_found, \"Placed card not in committed hand\");\n\n    // ===== NEW: Verify card has not already been placed (C2 fix) =====\n    for i in 0..9 {\n        if board_before[i * 2 + 1] != 0 {\n            // Cell is occupied -- verify it's not the same card\n            assert(board_before[i * 2] != card_id, \"Card already placed on board\");\n        }\n    }\n\n    // ===== 5. Verify the cell was empty before the move =====\n    let cell_idx = r * 3 + c;\n    assert(board_before[cell_idx * 2] == 0, \"Cell not empty\");\n    assert(board_before[cell_idx * 2 + 1] == 0, \"Cell not empty (owner)\");\n\n    // ===== 6. Verify the card was placed in board_after =====\n    assert(board_after[cell_idx * 2] == card_id, \"Card not placed correctly\");\n    assert(\n        board_after[cell_idx * 2 + 1] == current_player,\n        \"Owner not set correctly\",\n    );\n\n    // ===== 7. Chain capture logic =====\n    // Determine the opponent\n    let opponent: Field = if current_player == 1 { 2 } else { 1 };\n\n    // Precompute ranks for all 9 cells (placed cell uses card_id, others use board_before)\n    // This avoids calling get_card_ranks inside the 8-pass loop (9 calls vs up to 288)\n    let mut all_ranks: [[Field; 4]; 9] = [[0; 4]; 9];\n    for i in 0..9 {\n        let cid = if i as u32 == cell_idx { card_id } else { board_before[i * 2] };\n        if cid != 0 {\n            all_ranks[i] = get_card_ranks(cid as u32);\n        }\n    }\n\n    // Track owner state (mutable copy, updated as captures happen)\n    let mut owner_state: [Field; 9] = [0; 9];\n    for i in 0..9 {\n        owner_state[i] = board_before[i * 2 + 1];\n    }\n    owner_state[cell_idx] = current_player;\n\n    // Track which cells are active attackers this pass\n    let mut active: [bool; 9] = [false; 9];\n    active[cell_idx] = true; // Seed: only the placed card\n\n    // Track all cells captured during this move\n    let mut captured: [bool; 9] = [false; 9];\n\n    // Up to 8 passes (max captures on 3x3 board = 8 cells)\n    for _pass in 0..8 {\n        let mut next_active: [bool; 9] = [false; 9];\n        for a in 0..9 {\n            if active[a] {\n                for d in 0..4 {\n                    let n = NEIGHBORS[a][d];\n                    if n != 9 {\n                        // Neighbor must be occupied, owned by opponent, and not already captured\n                        if (board_before[n * 2] != 0) & (owner_state[n] == opponent) & !captured[n] {\n                            let a_rank = all_ranks[a][DIR_RANKS[d][0]] as u32;\n                            let d_rank = all_ranks[n][DIR_RANKS[d][1]] as u32;\n                            if a_rank > d_rank {\n                                owner_state[n] = current_player;\n                                captured[n] = true;\n                                next_active[n] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for i in 0..9 {\n            active[i] = next_active[i];\n        }\n    }\n\n    // ===== 8. Verify board_after matches expected state =====\n    for i in 0..9 {\n        if i as u32 != cell_idx {\n            let before_card = board_before[i * 2];\n            let before_owner = board_before[i * 2 + 1];\n            let after_card = board_after[i * 2];\n            let after_owner = board_after[i * 2 + 1];\n\n            // Card ID must never change for non-placed cells\n            assert(after_card == before_card, \"Non-placed cell card_id changed\");\n\n            if captured[i] {\n                // Captured cell: owner must change to current_player\n                assert(\n                    after_owner == current_player,\n                    \"Captured cell owner not updated\",\n                );\n            } else {\n                // Non-captured cell: owner must stay the same\n                assert(after_owner == before_owner, \"Non-captured cell owner changed\");\n            }\n        }\n    }\n\n    // ===== 9. Verify start_state_hash matches board_before =====\n    let computed_start = hash_board_state(board_before, scores_before, current_turn_before);\n    assert(computed_start == start_state_hash, \"Start state hash mismatch\");\n\n    // ===== 10. Compute and verify end state =====\n    let next_turn: Field = if current_player == 1 { 2 } else { 1 };\n    let computed_end = hash_board_state(board_after, scores_after, next_turn);\n    assert(computed_end == end_state_hash, \"End state hash mismatch\");\n\n    // ===== 11. Verify game ended flag =====\n    let mut filled: u32 = 0;\n    for i in 0..9 {\n        if board_after[i * 2] != 0 {\n            filled += 1;\n        }\n    }\n\n    if filled == 9 {\n        assert(game_ended == 1, \"Game should have ended\");\n        let p1_score = scores_after[0] as u32;\n        let p2_score = scores_after[1] as u32;\n        if p1_score > p2_score {\n            assert(winner_id == 1, \"Player 1 should be winner\");\n        } else if p2_score > p1_score {\n            assert(winner_id == 2, \"Player 2 should be winner\");\n        } else {\n            assert(winner_id == 3, \"Should be a draw\");\n        }\n    } else {\n        assert(game_ended == 0, \"Game should not have ended\");\n        assert(winner_id == 0, \"No winner yet\");\n    }\n\n    // ===== 12. Verify scores are exactly correct (C1 fix) =====\n    let mut p1_board: u32 = 0;\n    let mut p2_board: u32 = 0;\n    for i in 0..9 {\n        let owner = board_after[i * 2 + 1];\n        if owner == 1 {\n            p1_board += 1;\n        } else if owner == 2 {\n            p2_board += 1;\n        }\n    }\n    // Player 1 goes first, so P1 has placed ceil(filled/2) cards, P2 has placed floor(filled/2)\n    let p1_played = (filled + 1) / 2;\n    let p2_played = filled / 2;\n    let p1_hand = 5 - p1_played;\n    let p2_hand = 5 - p2_played;\n    let expected_p1_score = p1_board + p1_hand;\n    let expected_p2_score = p2_board + p2_hand;\n    assert(scores_after[0] == expected_p1_score as Field, \"P1 score mismatch\");\n    assert(scores_after[1] == expected_p2_score as Field, \"P2 score mismatch\");\n}\n\n// ====================== TEST HELPERS ======================\n\n/// Helper: create a card_commit for test use (poseidon2)\nfn test_card_commit(card_ids: [Field; 5], blinding_factor: Field) -> Field {\n    let mut to_hash: [Field; 6] = [0; 6];\n    for i in 0..5 {\n        to_hash[i] = card_ids[i];\n    }\n    to_hash[5] = blinding_factor;\n    Poseidon2::hash(to_hash, 6)\n}\n\n// Default hand data for Player 1 in tests: cards 1-5\n// Mudwalker[1,4,1,5], Blushy[5,1,1,3], Snowdrop[1,3,3,5], Sunny[6,1,1,2], Inkwell[2,3,1,5]\nglobal P1_BLINDING: Field = 111;\n\nfn p1_card_ids() -> [Field; 5] { [1, 2, 3, 4, 5] }\n\n// Default hand data for Player 2 in tests: cards 10-14\n// Peaches[4,3,2,4], Freckles[2,6,1,6], Camo[7,1,3,1], Neon[6,2,2,3], Glow Bug[5,3,3,4]\nglobal P2_BLINDING: Field = 222;\n\nfn p2_card_ids() -> [Field; 5] { [10, 11, 12, 13, 14] }\n\nfn get_p1_commit() -> Field {\n    test_card_commit(p1_card_ids(), P1_BLINDING)\n}\n\nfn get_p2_commit() -> Field {\n    test_card_commit(p2_card_ids(), P2_BLINDING)\n}\n\n// ====================== TESTS ======================\n\n#[test]\nfn test_first_move_no_capture() {\n    // Player 1 places card 1 (Mudwalker) at (0,0) on empty board - no captures possible\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; // card_id = 1 (Mudwalker)\n    board_after[1] = 1; // owner = player1\n    let scores_after: [Field; 2] = [5, 5]; // 1 on board + 4 in hand = 5\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,       // game not ended\n        1,          // current_player\n        1,          // card_id (Mudwalker)\n        0, 0,       // row, col\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_second_move_no_capture() {\n    // Player 2 places card 10 (Peaches) at (1,1)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; // card at (0,0): card_id=1, owner=player1\n    board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    board_after[8] = 10; // card at (1,1): card_id=10, owner=player2\n    board_after[9] = 2;\n    let scores_after: [Field; 2] = [5, 5]; // p1: 1+4=5, p2: 1+4=5\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        2,          // current_player = player2\n        10,         // card_id = Peaches\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n#[test]\nfn test_capture_one_card() {\n    // Player 1 has card 1 (Mudwalker [1,4,1,5]) at (0,0)\n    // Player 2 has card 10 (Peaches [4,3,2,4]) at (0,1)\n    // Player 1 places card 4 (Sunny [6,1,1,2]) at (1,1)\n    // (1,1) is adjacent to (0,1) - placed card's top=6 vs Peaches's bottom=2 -> 6>2 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, player 1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, player 2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;     // (0,0) unchanged\n    board_after[2] = 10; board_after[3] = 1;    // (0,1) CAPTURED - owner changed to player 1\n    board_after[8] = 4; board_after[9] = 1;     // (1,1) placed card 4, player 1\n    let scores_after: [Field; 2] = [6, 4];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1,          // current_player\n        4,          // card_id = Sunny\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_capture_multiple_cards() {\n    // P1 places card 1 Mudwalker [1,4,1,5] at (1,1):\n    // Right (1,2): Card 12 Camo left=1 vs placed right=4 -> 4>1 CAPTURE!\n    // Left (1,0): Card 10 Peaches right=3 vs placed left=5 -> 5>3 CAPTURE!\n    // Top (0,1): Card 11 Freckles bottom=1 vs placed top=1 -> NO (equal)\n    // Bottom (2,1): Card 13 Neon top=6 vs placed bottom=1 -> NO\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;   // (0,1) Freckles\n    board_before[6] = 10; board_before[7] = 2;   // (1,0) Peaches\n    board_before[10] = 12; board_before[11] = 2; // (1,2) Camo\n    board_before[14] = 13; board_before[15] = 2; // (2,1) Neon\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;     // (0,1) unchanged\n    board_after[6] = 10; board_after[7] = 1;     // (1,0) CAPTURED\n    board_after[8] = 1; board_after[9] = 1;      // (1,1) placed\n    board_after[10] = 12; board_after[11] = 1;   // (1,2) CAPTURED\n    board_after[14] = 13; board_after[15] = 2;   // (2,1) unchanged\n    // filled=5, p1_board=3, p2_board=2, p1_played=3, p2_played=2\n    // p1_score = 3 + (5-3) = 5, p2_score = 2 + (5-2) = 5\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1,\n        1,          // card_id = Mudwalker\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_no_capture_higher_adjacent() {\n    // P1 card 3 Snowdrop [1,3,3,5] at (0,0). (0,1) has P2 card 14 Glow Bug [5,3,3,4].\n    // Placed right=3 vs adj left=4. 3<4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1,\n        3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p1_wins() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    board_before[2] = 10; board_before[3] = 2;\n    board_before[4] = 2; board_before[5] = 1;\n    board_before[6] = 11; board_before[7] = 2;\n    board_before[8] = 3; board_before[9] = 1;\n    board_before[10] = 12; board_before[11] = 1;\n    board_before[12] = 4; board_before[13] = 1;\n    board_before[14] = 13; board_before[15] = 2;\n\n    let scores_before: [Field; 2] = [6, 4];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    board_after[16] = 5;\n    board_after[17] = 1;\n    // (2,1) card 13 Neon: placed left=5 vs adj right=2 -> 5>2 CAPTURE!\n    board_after[15] = 1;\n\n    let scores_after: [Field; 2] = [7, 3];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 1,       // game ended, player 1 wins\n        1,\n        5,\n        2, 2,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_game_ends_draw() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    // Board where no captures happen on final move -> draw\n    let mut board_before2: [Field; 18] = [0; 18];\n    board_before2[0] = 1; board_before2[1] = 1;\n    board_before2[2] = 10; board_before2[3] = 2;\n    board_before2[4] = 2; board_before2[5] = 1;\n    board_before2[6] = 13; board_before2[7] = 2;\n    board_before2[8] = 3; board_before2[9] = 1;\n    board_before2[10] = 12; board_before2[11] = 2;\n    board_before2[12] = 4; board_before2[13] = 1;\n    board_before2[14] = 11; board_before2[15] = 2; // Freckles [2,6,1,6]\n    let scores_before2: [Field; 2] = [5, 5];\n    let current_turn_before2: Field = 1;\n    let start_hash2 = hash_board_state(board_before2, scores_before2, current_turn_before2);\n\n    let mut board_after2: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after2[i] = board_before2[i];\n    }\n    board_after2[16] = 5;  // Inkwell at (2,2)\n    board_after2[17] = 1;\n    // (1,2) card 12 Camo: placed top=2 vs adj bottom=3 -> NO\n    // (2,1) card 11 Freckles: placed left=5 vs adj right=6 -> NO\n    let scores_after2: [Field; 2] = [5, 5];\n    let end_hash2 = hash_board_state(board_after2, scores_after2, 2);\n\n    main(\n        cc1, cc2,\n        start_hash2, end_hash2,\n        1, 3,       // game ended, draw\n        1,\n        5,\n        2, 2,\n        board_before2, board_after2,\n        scores_before2, scores_after2,\n        current_turn_before2,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p2_wins() {\n    // P2 places the 9th card and wins with a higher score\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    // Row 0: P1 card 1, P2 card 10, P1 card 2\n    board_before[0] = 1; board_before[1] = 1;    // (0,0) Mudwalker P1\n    board_before[2] = 10; board_before[3] = 2;   // (0,1) Peaches P2\n    board_before[4] = 2; board_before[5] = 1;    // (0,2) Blushy P1\n    // Row 1: P2 card 11, P2 card 12, P1 card 3\n    board_before[6] = 11; board_before[7] = 2;   // (1,0) Freckles P2\n    board_before[8] = 12; board_before[9] = 2;   // (1,1) Camo P2\n    board_before[10] = 3; board_before[11] = 1;  // (1,2) Snowdrop P1\n    // Row 2: P2 card 13, P1 card 5, empty (2,2)\n    board_before[12] = 13; board_before[13] = 2; // (2,0) Neon P2\n    board_before[14] = 5; board_before[15] = 1;  // (2,1) Inkwell P1\n\n    // Scores: P1 has 4 on board + 1 in hand = 5, P2 has 4 on board + 1 in hand = 5\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2; // P2's turn\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    // P2 places card 14 (Glow Bug [5,3,3,4]) at (2,2)\n    board_after[16] = 14; board_after[17] = 2;\n\n    // Check captures:\n    // (1,2) Snowdrop P1 [1,3,3,5]: placed top=5 vs adj bottom=3 -> 5>3 CAPTURE!\n    board_after[11] = 2; // Snowdrop captured by P2\n    // (2,1) Inkwell P1 [2,3,1,5]: placed left=4 vs adj right=3 -> 4>3 CAPTURE!\n    board_after[15] = 2; // Inkwell captured by P2\n\n    // filled=9, p1_board=2, p2_board=7, p1_played=5, p2_played=4\n    // p1_score = 2 + (5-5) = 2, p2_score = 7 + (5-4) = 8\n    let scores_after: [Field; 2] = [2, 8];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 2,       // game ended, player 2 wins\n        2,          // current_player = P2\n        14,         // card_id = Glow Bug\n        2, 2,       // row=2, col=2\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n// ====================== FAILURE TESTS ======================\n\n#[test(should_fail_with = \"Cell not empty\")]\nfn test_fail_place_on_occupied_cell() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 10;\n    board_before[1] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,       // (0,0) is occupied\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Not this player's turn\")]\nfn test_fail_wrong_player_turn() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1; // P1's turn\n\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 10;\n    board_after[1] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        2,          // P2 trying to play on P1's turn\n        10,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Row out of bounds\")]\nfn test_fail_row_out_of_bounds() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n    let end_hash = start_hash;\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        3, 0,       // row=3 out of bounds\n        board_before, board_before,\n        scores_before, scores_before,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Placed card not in committed hand\")]\nfn test_fail_card_not_in_hand() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 20;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 20,      // card 20 not in P1's hand\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Player 1 card commit mismatch\")]\nfn test_fail_wrong_blinding_factor() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(),\n        999,        // WRONG blinding factor\n    );\n}\n\n#[test(should_fail_with = \"Non-captured cell owner changed\")]\nfn test_fail_false_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 1;      // FALSE CAPTURE\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Captured cell owner not updated\")]\nfn test_fail_missing_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;      // NOT captured (WRONG!)\n    board_after[8] = 4; board_after[9] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 4,\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Non-placed cell card_id changed\")]\nfn test_fail_card_id_changed() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 99; board_after[3] = 2;      // card_id CHANGED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_player2_move_with_capture() {\n    // P2 places card 12 (Camo [7,1,3,1]) at (1,0)\n    // (0,0) has P1 card 1 (Mudwalker [1,4,1,5]).\n    // Placed top=7 vs adj bottom=1 -> 7>1 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 2;      // CAPTURED by P2\n    board_after[6] = 12; board_after[7] = 2;\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        2,\n        12,\n        1, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n#[test]\nfn test_equal_ranks_no_capture() {\n    // P1 card 1 Mudwalker right=4 at (0,0), (0,1) has P2 card 10 Peaches left=4.\n    // 4 == 4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 10; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;      // NOT captured (equal ranks)\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n// ====================== C1 FIX TESTS: Exact Score Verification ======================\n\n#[test(should_fail_with = \"P1 score mismatch\")]\nfn test_score_fabrication_rejected() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    // Fabricated scores: should be [5, 5] but attacker claims [8, 2]\n    let scores_after: [Field; 2] = [8, 2];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_exact_scores_after_capture() {\n    // P2 places card 13 (Neon [6,2,2,3]) at (0,1).\n    // (0,0) has P1 card 5 (Inkwell [2,3,1,5]). Placed left=3 vs adj right=3 -> NO (equal)\n    // (1,1) has P1 card 1 (Mudwalker [1,4,1,5]). Placed bottom=2 vs adj top=1 -> 2>1 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 5; board_before[1] = 1;    // (0,0) Inkwell P1\n    board_before[4] = 10; board_before[5] = 2;   // (0,2) Peaches P2\n    board_before[8] = 1; board_before[9] = 1;    // (1,1) Mudwalker P1\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 5; board_after[1] = 1;      // (0,0) Inkwell P1 - unchanged\n    board_after[2] = 13; board_after[3] = 2;     // (0,1) Neon P2 - placed\n    board_after[4] = 10; board_after[5] = 2;     // (0,2) Peaches P2 - unchanged\n    board_after[8] = 1; board_after[9] = 2;      // (1,1) Mudwalker CAPTURED by P2\n    // Exact scores: p1_board=1, p2_board=3, p1_hand=3, p2_hand=3\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        2,\n        13,\n        0, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p2_card_ids(), P2_BLINDING,\n    );\n}\n\n// ====================== C2 FIX TESTS: Card Replay Prevention ======================\n\n#[test(should_fail_with = \"Card already placed on board\")]\nfn test_card_replay_rejected() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;\n    board_after[8] = 1; board_after[9] = 1;    // (1,1) card 1 REPLAYED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 1,          // card_id = 1 (already on board!)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_different_card_after_same_id_on_board() {\n    // P1 has card 1 on board. P1 places card 2 (different card). Should succeed.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 1;   // (0,1) CAPTURED: Blushy top=5 > Peaches bottom=2\n    board_after[8] = 2; board_after[9] = 1;    // (1,1) card 2, different card\n    // filled=3, p1_board=3, p2_board=0, p1_played=2, p2_played=1\n    // p1_score=3+3=6, p2_score=0+4=4\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 2,          // card_id = 2 (different, valid)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n// ===== Chain capture tests =====\n\n#[test]\nfn test_chain_capture_two_levels() {\n    // P2 has: (0,0) Freckles id=11 [2,6,1,6], (0,1) Peaches id=10 [4,3,2,4]\n    // P1 places Sunny id=4 [6,1,1,2] at (1,0).\n    // Direct: Sunny top=6 > Freckles bottom=1 -> capture (0,0)\n    // Chain:  Freckles(now P1) right=6 > Peaches left=4 -> capture (0,1)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 11; board_before[1] = 2;  // (0,0) Freckles P2\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) Peaches P2\n\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 11; board_after[1] = 1;  // (0,0) Freckles captured by P1\n    board_after[2] = 10; board_after[3] = 1;  // (0,1) Peaches chain-captured by P1\n    board_after[6] = 4;  board_after[7] = 1;  // (1,0) Sunny placed by P1\n\n    // filled=3: p1_played=2, p2_played=1, p1_hand=3, p2_hand=4\n    // p1_board=3, p2_board=0: scores = [3+3, 0+4] = [6, 4]\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 4,          // card_id = 4 (Sunny)\n        1, 0,          // row=1, col=0\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_chain_capture_three_levels() {\n    // P2 hand = [11, 23, 10, 13, 14] (custom hand with Faded)\n    // Board: (0,0) Freckles id=11 [2,6,1,6] P2\n    //        (0,1) Faded    id=23 [6,6,3,3] P2\n    //        (0,2) Peaches  id=10 [4,3,2,4] P2\n    // P1 places Sunny id=4 [6,1,1,2] at (1,0)\n    // Direct: Sunny top=6 > Freckles bottom=1 -> capture (0,0)\n    // Chain1: Freckles right=6 > Faded left=3 -> capture (0,1)\n    // Chain2: Faded right=6 > Peaches left=4 -> capture (0,2)\n    let cc1 = get_p1_commit();\n    let cc2 = Poseidon2::hash([11, 23, 10, 13, 14, P2_BLINDING], 6);\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 11; board_before[1] = 2;  // (0,0) Freckles P2\n    board_before[2] = 23; board_before[3] = 2;  // (0,1) Faded P2\n    board_before[4] = 10; board_before[5] = 2;  // (0,2) Peaches P2\n\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 11; board_after[1] = 1;   // captured\n    board_after[2] = 23; board_after[3] = 1;   // chain-captured\n    board_after[4] = 10; board_after[5] = 1;   // chain-captured\n    board_after[6] = 4;  board_after[7] = 1;   // placed\n\n    // filled=4: p1_played=2, p2_played=2, p1_hand=3, p2_hand=3\n    // p1_board=4, p2_board=0: scores = [4+3, 0+3] = [7, 3]\n    let scores_after: [Field; 2] = [7, 3];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 4,\n        1, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test]\nfn test_chain_capture_stops_when_rank_too_low() {\n    // P1 places Blushy id=2 [5,1,1,3] at (1,0)\n    // (0,0) Peaches id=10 [4,3,2,4] P2: Blushy top=5 > Peaches bottom=2 -> captured\n    // (0,1) Freckles id=11 [2,6,1,6] P2: Peaches right=3 vs Freckles left=6 -> 3<6, NO chain\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 10; board_before[1] = 2;  // (0,0) Peaches P2\n    board_before[2] = 11; board_before[3] = 2;  // (0,1) Freckles P2\n\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 10; board_after[1] = 1;   // captured\n    board_after[2] = 11; board_after[3] = 2;   // NOT captured (3 < 6)\n    board_after[6] = 2;  board_after[7] = 1;   // placed Blushy\n\n    // filled=3: p1_played=2, p2_played=1, p1_hand=3, p2_hand=4\n    // p1_board=2, p2_board=1: scores = [2+3, 1+4] = [5, 5]\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 2,          // card_id = 2 (Blushy)\n        1, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Captured cell owner not updated\")]\nfn test_chain_capture_missing_chain_rejected() {\n    // Same setup as two-level chain (Sunny at (1,0), Freckles+Peaches at (0,0)+(0,1))\n    // but board_after OMITS the chain capture of Peaches at (0,1)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 11; board_before[1] = 2;  // (0,0) Freckles P2\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) Peaches P2\n\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 11; board_after[1] = 1;   // captured\n    board_after[2] = 10; board_after[3] = 2;   // NOT captured (but should be!)\n    board_after[6] = 4;  board_after[7] = 1;   // placed Sunny\n\n    // Scores as if chain DID NOT happen (wrong)\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 4,\n        1, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n\n#[test(should_fail_with = \"Non-captured cell owner changed\")]\nfn test_chain_capture_false_chain_rejected() {\n    // P1 places Blushy id=2 [5,1,1,3] at (1,0)\n    // (0,0) Peaches id=10 [4,3,2,4] P2: Blushy top=5 > Peaches bottom=2 -> captured\n    // (0,1) Freckles id=11 [2,6,1,6] P2: Peaches right=3 vs Freckles left=6 -> NO chain\n    // But board_after falsely claims Freckles was captured -> should fail\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 10; board_before[1] = 2;  // (0,0) Peaches P2\n    board_before[2] = 11; board_before[3] = 2;  // (0,1) Freckles P2\n\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 10; board_after[1] = 1;   // captured\n    board_after[2] = 11; board_after[3] = 1;   // falsely claimed chain capture\n    board_after[6] = 2;  board_after[7] = 1;   // placed Blushy\n\n    // Scores as if both captured (wrong)\n    let scores_after: [Field; 2] = [7, 3];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        1, 2,\n        1, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        p1_card_ids(), P1_BLINDING,\n    );\n}\n","path":"/Users/zac/aztec-triple-triad-ui/repo/circuits/game_move/src/main.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\nglobal RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let num_extra_fields = in_len % RATE;\n            if num_extra_fields != 0 {\n                let remainder_start = in_len - num_extra_fields;\n                state[0] += input[remainder_start];\n                if num_extra_fields > 1 {\n                    state[1] += input[remainder_start + 1];\n                }\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4);\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/zac/nargo/github.com/noir-lang/poseidon/v0.2.6/src/poseidon2.nr"}}}