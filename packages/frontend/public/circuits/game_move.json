{"noir_version":"1.0.0-beta.18+2db78f8894936db05c53430f364360ac9cc5c61f","hash":"13126520192291947679","abi":{"parameters":[{"name":"card_commit_1","type":{"kind":"field"},"visibility":"public"},{"name":"card_commit_2","type":{"kind":"field"},"visibility":"public"},{"name":"start_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"end_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"game_ended","type":{"kind":"field"},"visibility":"public"},{"name":"winner_id","type":{"kind":"field"},"visibility":"public"},{"name":"encrypted_card_nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"current_player","type":{"kind":"field"},"visibility":"private"},{"name":"card_id","type":{"kind":"field"},"visibility":"private"},{"name":"row","type":{"kind":"field"},"visibility":"private"},{"name":"col","type":{"kind":"field"},"visibility":"private"},{"name":"board_before","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"board_after","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_before","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_after","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"current_turn_before","type":{"kind":"field"},"visibility":"private"},{"name":"player_secret","type":{"kind":"field"},"visibility":"private"},{"name":"player_address","type":{"kind":"field"},"visibility":"private"},{"name":"game_id","type":{"kind":"field"},"visibility":"private"},{"name":"player_card_ids","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"player_card_ranks","type":{"kind":"array","length":5,"type":{"kind":"array","length":4,"type":{"kind":"field"}}},"visibility":"private"},{"name":"player_nullifier_secrets","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"grumpkin_private_key","type":{"kind":"field"},"visibility":"private"},{"name":"opponent_pubkey_x","type":{"kind":"field"},"visibility":"private"},{"name":"opponent_pubkey_y","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"4286976953368078457":{"error_kind":"string","string":"Encrypted nullifier mismatch"},"4487758756370642245":{"error_kind":"string","string":"Start state hash mismatch"},"5077336431726014007":{"error_kind":"string","string":"Placed card ranks do not match database"},"5101543514421470893":{"error_kind":"string","string":"Card already placed on board"},"6511982886681245134":{"error_kind":"string","string":"Placed card not in committed hand"},"7317384265632011736":{"error_kind":"string","string":"Cell not empty (owner)"},"7370811245087594529":{"error_kind":"string","string":"Captured cell owner not updated"},"7520349170859696597":{"error_kind":"string","string":"Card not placed correctly"},"8084300406162371689":{"error_kind":"string","string":"Player 2 card commit mismatch"},"8749084135167576643":{"error_kind":"string","string":"Invalid player"},"9296992678443765102":{"error_kind":"string","string":"Non-placed cell card_id changed"},"9336663072722308931":{"error_kind":"string","string":"Owner not set correctly"},"9573161043312537276":{"error_kind":"string","string":"Should be a draw"},"9697039476693520435":{"error_kind":"string","string":"Player 2 should be winner"},"9715689440484907290":{"error_kind":"string","string":"Game should have ended"},"9915128275385804551":{"error_kind":"string","string":"Player 1 should be winner"},"11936972275297119974":{"error_kind":"string","string":"Invalid card ID for rank lookup"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12724384224350165649":{"error_kind":"string","string":"End state hash mismatch"},"14199193565343435108":{"error_kind":"string","string":"opponent public key not on Grumpkin curve"},"14336771847768869760":{"error_kind":"string","string":"Not this player's turn"},"14904510168980638594":{"error_kind":"string","string":"Cell not empty"},"14918566239196857362":{"error_kind":"string","string":"grumpkin_private_key must be non-zero"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15156018542597224275":{"error_kind":"string","string":"Player 1 card commit mismatch"},"15353634778740263988":{"error_kind":"string","string":"Game should not have ended"},"15521846062275453407":{"error_kind":"string","string":"Col out of bounds"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16309609255298369368":{"error_kind":"string","string":"Row out of bounds"},"16422110396685134300":{"error_kind":"string","string":"P1 score mismatch"},"17174323770794875209":{"error_kind":"string","string":"Non-captured cell owner changed"},"18125798406593280834":{"error_kind":"string","string":"No winner yet"},"18256603403857491958":{"error_kind":"string","string":"P2 score mismatch"}}},"bytecode":"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","debug_symbols":"tZ3dru22ka3fZV/7QvwrknmVg0bgpN0NA4YdOEkDB4Hf/YijfsZKHyxOWnP5xvqys3eVOCjWLJZK0r++/ecPf/nnf//5x5//65e/f/vT//nXt7/8+uNPP/3433/+6Ze/fv+PH3/5+f7Tf3271n+SfPtT/u5b6noY3/5U7sP89qf63bd8/4362/0//S82/b/6b/cfuqk//+PXH35Yf+GD7dvj377/9Yef//HtTz//86efvvv2P9//9E/8pb//7fufcfzH97/e/+/13bcffv7P+3gb/K8ff/ph0W/f8V9fn//Tkav941FH/PPU/+3fp8//vYjYv5feHvz7fhX79z1dj/599n+fP/W/Gf9Mzf79zOnJv2/D/32fn/17+fzfp3RVH8HN8mEM43wOu0/CyJMWWjq2UC6/hkZJ84mF3FtYyNejc4hLadSrPLFQR5xDfaZDu6ZbaM90aCWHhdIfWei00B9Z6HFRjlnqZxbS5rKUPj0uyLjaIxNj+lnITOl9E88GMkcEiOvKT0z0K9Uw0T4dSN5EqZyHDySXLFzj899N5I2JIR4p85jXpybK5yZqGm6i5s1Z7EyUy5dYLbU8MpHnfN9EetdELTGQKs+0aD3klGt+amLuJrVyUtunv79ls9iz0IS0T38Cy+bqTLO5iTT79cREvrIvs3zVz89iIyfVlI+ZwPgd5yCxyK756Y/5mvc/7hzS8Is73+fzSEqu0jdMXO+aKClFxGqfXhN1c2WmMn2JpZrKIxP38g4T9QtM9GcmWgoTIg9NXGFipLcH8tBEu2IgLV1vmygPTVSakPqpifnmOt2fQyyyJJ+vkJbejRXbyN0jVsjn8aqVtyP3zsRh5G7vRs39ORxF7tb/yHM4i9wvTJT3TVzvmjiL3JLfjtxbE2eR+9xEf2biKHK/MHESuY8H8tDEWeQ+NlEemjiK3P3dqLk/h6PI3csfGbn7CkW6xPr8VMre3l5iWxNnS+zcRH9m4miJvTBxssSOB/LQxNkSOzZRHpo4WmKjvnl578/haIkNefMctuWOWSMlmB93xucVk3KvMTNRUsvPTMTPcclF3jfxaZVgV2K+ovIzr/mkIDivLGGhPimMziR+Wc70qLQ6a/cVOtuj8u5sMsPCeFKcnRJRYoqkRxbmFfX+60mZe44adxyGjHct9EdKTolRfLxt8dDCfKJDuquqEbKv1MYzG3l+sPHpSO6bLLtfc6nxa/55wf2FjSq0MZ7ZGC12IKOnZzYmd3O70v/eRo/sZo5nmpYrVlq5qjy0EUXzkj5fa3sbvMju34CH55EvRvCUH9qIWzIl94djKcnntpRcH9qIm2yl9IdzW2Ptl/p5/NnbaMmvsfIxU/p9Nnqcx52xPLMh2X9bi5SH14fwF17mw/PoJa6P3tJDGzPGMq6HYxmRipf7htMzG/OKsXy8qf77bEgLGw/jab1izdXrYTytKdZcTbk9tBHVrfsO3MPzyBHX613VeWgjrtP7Btqzua13AOGdt/nQRsT1Wq+HetTomqi1PdSDu7V7D1sf2uA11p5eYxJr7t5AP5yXfsW89PRwXpgH1ad5UB05xjLKw7GMaGep42H+UWeJe7PzYf5RZ1SE2651YGejXZF/tKv1hzbihnlLD/OPluI3+/7lfTYvLbcYy33v4pmNO5NzG/d2+KGNnsLGeLZuW82ef7Q7CD20McJGe5ifthZ371t7mJ+2Fl0yTdKzGNSktbAhz35v7/gX89I/z0+3+7l8cT+X6zMbNVoCF/f3baT0zEbptFHnMxuZe+Tari+w0R7ZaLEFujnJs/MY/YON/r6NnB/ZkEwb0r7AhpRHNnq0nt788Fr/NxvybCwzQtDiR+eReqTrN/frmY0pYWNc6aGN9sGGvG8jPRvL4E2RNJ7Ny30zeXyw8egaS5NxLM1nay6NSIOWjfHsPMqH86gPbbDXIc1eH55H+mDjUSzMVw4b+SrzmY1I12/e5B8jb2uOvAu5qX3ubZzVPl+cx1Htc2vjsPa5tXFY+9zbOKt97myc1j73Ns5qn1sbh7XPrY3D2ufexlntc2vjsPa5t3FW+9zaOKx9bm0c1j73Ns5qn1sbh7XPvY2z2ufWxmHtc2/jrPa5tXFY+9zaOKx97m2c1T53Nk5rn1sbh7XPvY2z2ufWxmHtc2/jrPa5tXFY+9zbOKt9bm0c1j63Ng5rn3sbZ7XPrY3D2ufWxmHtc2/jrPa5tXFY+9zbOKt9bm0c1j73Ns5qnzsbp7XPvY2z2ufWxmHtc2vjsPa5tXFY+9zbOKt9bm0c1j73Ns5qn1sbh7XPvY2z2ufWxmHtc2vj/dpnTtyb5of9MDmxPvZv/eO/x0aOtPDm+myPnCOc3jwe1XJyEY6l9PzMxqSNej2zUT/s1R/Wgv/9PNLD82D9I1d5do3Ven2w8Wxu28W5ffaQ9O178lpvjx4Xv/9d+XAe7aGNWPo3d3l4HuWDjUc1tiwf1pzUZ9eYxNZj2fj0Gsu7h5oOa0ovbBzVlF6dx0lNaW/jrKa0t3FWU3ph46imtLVxWFN6YeOoprS3cVZT2ts4qym9sHFUU9rbOKspvbBxVFPa2zirKe1tnNWUXtg4qintbZzVlF7YOKop7W2c1ZRe2DiqKe1tnNWU9jbOakovbBzVlLY2DmtKextnNaUXNo5qSnsbZzWlFzaOakp7G2c1pRc2jmpKextnNaW9jbOa0gsbRzWlvY2zmtLexllN6YWNo5rS3sZZTemFjaOa0t7GWU3phY2jmtLWxmFN6YWNo5rS3sZZTWlv46ymtLdxVlN6YeOoprS3cVZTemHjqKa0t3FWU3ph46imtLdxVlPa2/iCmlL/sDft8myP3Nn/cf/iPatLjcx99qjP9shDWIcZ41E/zL0VY/3jYf9HufiQ783y0MZFG89qSv/LxsOxNKEN6c9ssH/stvHo+rijWNTH7l1ZfnYe8cq6ZaM8O4/y4TzaQxuRwtz86OnKdR6clzQerduSM2087KW99+fpg41Pr7GSr7drSi9sHNWUXp3HSU1pb+OsprS3cVZTemHjqKa0tXFYU3ph46imtLdxVlPa2zirKb2wcVRT2ts4qym9sHFUU9rbOKsp7W2c1ZRe2DiqKe1tnNWUXtg4qintbZzVlF7YOKop7W2c1ZT2Ns5qSi9sHNWUtjYOa0p7G2c1pRc2jmpKextnNaUXNo5qSnsbZzWlFzaOakp7G2c1pb2Ns5rSCxtHNaW9jbOa0t7GWU3phY2jmtLexllN6YWNo5rS3sZZTemFjaOa0tbGYU3phY2jmtLexllNaW/jrKa0t3FWU3ph46imtLdxVlN6YeOoprS3cVZTemHjqKa0t3FWU9rbeL+mVMqHvWl59lxSuZOOsPGwp6bcv5W08az/406TJ22MZ7Wc1rlHfthDUuRDTUke1pQksR4kD+tB/3Ye6eF5NNZQ5GE9SPhuqNvGsxpKZz9M6Q/rQcJnAcvT9cJtw83toY3G67Q/rAf1D7Wt/qwnrww+93qH9WfX2Ej5g43P4+mY79eU9jbOakovzuOoprS1cVhT2to4rCntbZzVlHY2TmtKextnNaWtjcOa0tbGYU1pb+OsprS1cVhT2ts4qyltbRzWlLY2DmtKextnNaWtjcOa0t7GWU1pa+OwprS3cVZT2to4rCltbRzWlPY2zmpKOxunNaWtjcOa0t7GWU1pa+OwprS3cVZT2to4rCntbZzVlLY2DmtKWxuHNaW9jbOa0tbGYU1pa+OwprS3cVZT2to4rCntbZzVlLY2DmtKextnNaWdjdOa0t7GWU1pa+OwprS1cVhT2to4rCntbZzVlLY2DmtKextnNaWtjcOa0t7GWU1pa+OwprS18QU1pflhbzrloY1Ig9L98/Koh6RefJ903Xzrb2+DPUb1Go96au6fuQ/fZXimx52tUw/Jz8Yi7YONZ/1S9UPtovbxbCwf3oVUx7N3qdXJ/rE6H73DPt0xNM6j5euZDW7F0h0FPr1O6+4jP3LFb5RcczyzkWIvJinLQxvCDz18rmltm29FHH4cs+4+/3T4dcy6srbP8/Wjz2PubZx9H3Nv4+wDma9spLdtnH0ic2/j7BuZVbbvxT/6SGaVzSdNDr+SWWX3qeazj61tbRx+ba3K2P3ennz8bn8WR99bq/36Q8/i7Itrr2yUL7BxvW3j8HOZX/BJqPoF34SqX/BRqPoFX4WqX/BZqPoF34WqX/BhqPoFX4aqX/BpqPr2t6HqF3wcqr79dagX8fzo25l1jPfj+c7GaTyfb0fS/VmcxfOZ/9CzOIznL2yUL7BxvW3jMJ7P/n4839o4jOfnNvpDG2fx/IWNo3h+PJanNg7j+bGN8tTGUTxv19uRdH8WZ19CvsYfGs/PvqjZ0vX2etvbOFtvv8NGf2jjaL29snGy3s7H8tTG2Xo7t1Ge2jhbb+ndD4+/OIuz9Zbf/Yjuvl5y9nnNrY3D72u+sHH0gc3fYePJFzbvKyM+qXjzs2f2PpTSU+vXpzZaHm/X9fY2zup6L2wc1fVaSW/X9VrJb9f18AquN+t6extndb29jbO63isb6W0bZ3W9vY2zul4r8+26XqvX23U9RP4394FbG4f7QNz1e++3ZX8WR/vAVtsfehZn+8BXNsoX2LjetnG2D2ztC/LS9gV5afuCvLR9QV7aviAvbV+Ql7YvyEvbF+Sl7Qvy0vZ2Xtq+IC+V9HbsuN6u6zUp78fznY3TeC5vR9L9WZzFc+l/6FkcxvMXNsoX2LjetnEYz3t+P55vbRzG83Mb/aGNs3j+wsZRPD8ey1Mbh/H82EZ5auMsno+3I+n+LM7i+Sh/aDw/rOuN9++L7m0crrfx/n3RFzbO1tt4/77o+Vie2jhcb+P9+6IvbJytt/nufdEXZ3G23ua71fx9veSsrre1cViT+x02ntXkeqRgNz/7Tmf78O3CNp/1hLbJZx7bLOOZDX4PoT1871z70N8q17P38N0X5kUb45Ee8uFdbXd9cT6zEY9x3CzpmY0PC+5O9B/ZyJVjySLPbESZ8y6aPvvGhBT2DEt51iMrH2rYUp+961Ean5mWh9/XlXutho2H36SV3jkvH/OG32Nj8Hl4GfmhjUJNx7PvlsocsfZlzvrQRvlg49Ga6x++W9qvkp7ZaB9sPOtL7xf1uG+TPFq3PTEm9/TsOfSeeqON+ej9APdPFG3kZ88L9Mzvyzy2wdsTNz+c2zzkbRsfYlCvz74D3aXz+ujP3g3y7zYejoWP9t/87H2zffD7yzc/W7cfvov91Ma4RqzbkT7/voyUTXY64pHp8eEpnyTnFtKI6l6an9+ZlDJ2mWWkH+Xjyv//zmO+XSHc2jisEEp9d5f/4iyOKoTy9n2n/VmcVQhf2ShfYON628ZZhVDqeLtisbdxVrH4HTb6QxtHFYtXNk4qFudjeWrjrGJxbqM8tXFUsZD2bl3/xVkcVSzk7ftOL34TmEJt3lwjsv3CRYon2MfHa1Se2pif2dj+yuYaP2+jfF4pkO3TTpWxtKX+uY1dN2XmG4XK508oi7z/VJ7I+0/libz/VN7exln3zt7GWffOKxvpbRtn3Tt7G2fdO0iiP5/bo+4d6e8/lSf9/afytjZOc7n+bg/0i7M4y+XG9YeexWEu199/Ku+VjettG4e53BfcfZIvuPskX3D3Sb7g7pN8wd0n+YK7T/IFd5/kC+4+yRfcfZK37z7JF9x9krfvPr2I50fdOzLffypva+Mwnvfr7Ug6338qr1/5Dz2Lw3g+338q75WN620bZ/G8X+8/lbe3cRbPf4eN/tDGUTx/ZeMknp+P5amNs3h+bqM8tXEUz3t6N5K+OIujeN7T+EPj+Vn3Ts/vdz/vbRyut3Mb/aGNs/WW3+9+Ph/LUxuH6+3YRnlq42y95XerUC/O4my9lber+fL+U3lbG4dP5b2wcdQB9DtsfF5j2NbCWtxyyu1Z580o7HgZ9X+9Hfc/7v/1/V9//PXPP/3y1+//8eMvP/99/dN83+D67lvBfyv+27796dZU8N+O/47b3G133of7ikjXfbyzuJTsmO1Y7Fjt2Owodux2HHacesxmLy97twI527HYsdqx2VHs2O047Dj1WC47mr2y7N26l2LHasdmx2Xvjtql23HYceqxXqtOeR/T+mG4j3kVge5jsWO1Y1uTfx9lvTL6Pvb1quT7ONbrfe/jXPW9W9/Ljre9FR1btuNtbzWTtGrHttpN76OsNu/72FdT3n0ca83dx7mKzfdMXXZMa9nfx2zH296qaUm1421v1Q9E7HjbW7ssGXa87a13PfbLjknH3bOOu9t4u423NzuKjrt3HXcfOu4+ddzDxjuSHW28o9jRxjuaHUXHPbqOewwd95g67mnjncmONt5Z7Gjjnc2ONt7Z7WjjnVOP6bIBpys5ZB16uoqOPV026HQ1B3HoOv50DRUgXVMVSGupLAlSsrGntVgUbPRpLRcFG39aC0ahqxJpLZkGg1O1SGvRLDFSNhXSWjYKpkNaC0fBlEhr6SiYFmktHgVXYy0fBVdjLSCFYrKsJQRZiqtRXI21ihSGybLWEWRZCwmyrJUEWaqrsdaSgquxVpOCq7HWk8IwWdaKgixrSUGWtaYgS3M11qpScDXWulJwNdbKUnA11toCiKuxVpeCq7HWl0I1WdYKgyziaoirsRaZwjRZ1jKDLGudQZa10CBLdzXWUlNwNdZiU3A11nJTmCbLWnCQZa04yLKWHGQZrsZadAquxlp2Cq7GWngKrsZaegquxlp8Cq7GWn4KzWRZCxCyTFdjuhprDS7Iaw0W/BgklSWvNbhkyWsNLlnyZWrktQYVTI281qCCqZHXGgSsNbhkyWsNLlnyWoNLlrzW4JIlJ1MjrzWoYGrktQYVTI281iAgmxp5rUEFUyOvNahgauS1BhVEZclrDWb8iamRs6ux1qBCMlnWGoQsaw1ClrUGIUtxNdYaVHA11hpUcDXWGlRIJstag5BlrUHIstYgZKmuxlqDCq7GWoMKrsZagwquxlqDCq7GWoMKrsZagwrdZFlrELI0V0NcjbUGFbLJstYgZFlrELKsNQhZxNVYa1DB1VhrENBdjbUGFbLJstYgZFlrELKsNQhZuqux1qCCq7HWIGC4GmsNKrgaaw0quBprDSq4GmsNKgyTZa1ByDJdjelqzOxQTJa1BiHLWoOQZa1ByDJdjbUGFUyNstaggqlR1hpUKCpLWWtwyVLWGlyylLUGlyzlMjXKWoMKpkZZa1DB1ChrDSqYGmWtQQVTo6w1qGBqlLUGFabKUtYaXLKUbGqUnB2KQ1VZylqDBf9KVJay1uCSpWRTo2TL0kpxNUpycDVKcagmy1qDkGWtQciy1iBkKa5GsXytVFejJgdXoxYHV6M2B1ejdgdXo1rmVpqlqqVZrlqaq9FcjVYdLF8tzRLW0ixjLc1S1tJcDbkcXA3JDq6GVAfLXItY6lrEctcilrwWcTX65eBq9OzgavTq4Gp0cXA1+nBwNcblYJlsGZbKluFqDFdjNAdLZ8uwfLYMS2jLsIy2TFdjJgdXYxYHV2M2B0tsy7TMtkxLbcu03LZepka9koOpUa/iYGrUqzmYGvXqDqZGvSyvq8nUqCk5ZN/YWJZbk29lUnMQB8tya7IstybLcmu2LLdmU6Pm7GBq1FwdTI2axcGy3Joty63ZstxaLMutxdUo2cHVKNXB1Sji4GqU4eBq1MvB1ajZwbLcWi3LrdXVqK5G7Q6W5dZqWW5tluXWZlluba5GKw6uRmsOrkbrDpbl1mZZbhXLcqtYllvF1ZDi4GpIc3A1pDu4GmJ5Xe2uRk8OrkYvDpbl1m5Zbu2uRnc1+nCwLLcOy3LrSL4btiy3DldjVAdXY4iDqzGGg2W5dVqWW6dluXVallunqzGrg6sxxcHVmMPB1GjX5WBqtCs7mBrtqg6W5bbLstx2mRrtGg6WybRkWW5LluW2ZFluS5bltlS9PNAcTI2WuoOp0ZLldS1bltuyZbktW5bbsmW5LZsaLTcHU6Pl7mBqtGx5XSuuRkkOrkYpDq5GaQ6W5bZiWW4rrkZxNerlYFluq5bltmpZbquW5bbqalRxcDXqcHA12uVgWW5rluW2Zllua5bltuZqNHFwNdpwcDXkcnA1JDu4GlIdXA0RB8tym1iW28TV6K5GTw6W5bZuWW7rluW2bllu665G7w6uRre8rg1XYyQHy3LbsCy3jerFJcty23A1RndwNYbldW26GjM5uBqzOLgaszm4GrM7WJbbpmW5cpkaciWH7GBZrlyW5cplWa5cluXKZWrINRxMDUmXg6khKTtYlivJslxJluVKsixXUvdq23CYXne7HEwNydnB1JBcHUwNyeJgakgeDpblSrEsV4qrUVyNUhwsy5ViWa4Uy3KlWJYrxdUoltdJdTVqcnA1anGwLFeqZblSLcuValmuVFejelWyuRrN65LN1WhemWyuRvPaZHM1mlcnm6vRLK8TsSxXxLJcEVdDXA2pDpbliliWK2JZrohluSKuRr8cXI2eHVyNXh0sy5VuWa50y3KlW5Yr3dUYXqQdrsbwMu1wNYYXaoerMbxUO6JW68Xa4WrMy8GyXJmW5cp0NaarMZuDZbkyLcuVaVmuTMty+2Vq9Cs5mBr9Kg6mRr+ag2W5/bIst1+W5fbLstyeTI2ekoOp0VNxMDV6ag6mRk/dwdToyfK6nr14nZND9jK2Zbk9ewE7ewU7i4NluT1bltuzZbm9WJbbi6tRsoOrUaqDq1HEwbLcXizL7cWy3F4ty+3V1ajZwdWo1cHVqOLgatTh4Gq0y8HVaNnBstzeLMvtzdVorkbrDpbl9mZZbhfLcrtYltvF1ZDi4GpIc3A1pDtYltvFstzeLcvt3bLc3l2NXhxcjd4cXI3eHVyNbnldH67GSA6uxigOluX2YVluH67GcDXGcLAst0/LcvtMfu/Dstw+XY1ZHVyNKQ6uxhwOluWOy7LccVmWOy7LcsdlaoyrOpga4xIHU2Ncw8HUGOlyMDVGyg6mxkjVwbLckSzLHcnUGGk4WCYzsmW5I1uWO7JluSNbljty9ZtBzcHUGLk7mBojW143imW5o1iWO4pluaNYljuKq1Gag6tRuoOrUSyvG9XVqMnB1ajFwdWozcGy3FEtyx3V1aiuRrscLMsdzbLc0SzLHc2y3NFcjSYOrkYbDq6GXA6W5Q6xLHeIZblDLMsd4mqIOLgaMhxcjX45uBo9O7gavTq4Gl0cLMsd3bLc0V2N4WqM5GBZ7hiW5Y5hWe4YluWO4WqM7uBqDMvrxnQ1ZnKwLHdMy3LHtCx3TMtyx3Q1ZndwNabldfMyNeaVHEyNeRUHU2NezcHUmFd3sCx3XpblzmRqzJQcsoNluTNZljuTZbkzWZY7k6kx03AwNWa+HEyNmbODZbkzW5Y7s2W5M1uWO3P3e6vDwdUol4OrUbKDq1Gqg6tRxMHVKMPBstxZLcud1dXwW+3T77XPalnurJblzmpZ7qyW5c7qavgd99lcDb/nPpur4XfdZ7MsdzbLcmezLHc2y3JnczX83vsUV8Pvvk9xNfz++xRXw+/AT3E1/B78FFfD78LPblnu7Jblzu5q+J346bfiZ7csd3bLcme3LHd2y3JndzX8hvwcrobfkp/D1fCb8nNYljuHZblzWJY7h2W5c7gacWt+uhpxc366GnF7froacYN+uhq8RT/9jjxv0l+W595kie5NpshNcaOed+ov8Tv0V/db9JeluzdZvnvf/jdhbkpBJs1NJcjEuakFWdp7k+W9N1nie5NlvunKJtFNKchEuqkEmUw3tSAT6qYeNLyLIe7gXyW0inv4V2FLQ/Q0lNAq7uNfcSP/KtHXUKKxoXhnw1W9teGqoVXczr9qaBU39K8aWsUt/at6h8NVvcXhqt7jcDVvcrhaaBU39q8WWsWt/auFVnFz/2qhVdzev1poFTf4Lwmt4hb/tdbwxNmvRTzhY61io9UkBR9rHU+1MoKm01rKRikoB5WgGrR84EzXgjbqQSNoOq1FPXHOI3yM8DHCxwgfa2UbSVD4GOFjhI+1vI2Se5vhY4aPGT5m+JjhY4ZWM3xM94FmHKMUlM0b+nHwb9GQY9SCJKgHjaDwkcJHCh9rnRsV97bW+erQT+jNSRe6dNDOZtiJ6JHLwBmI1jbDRMzEEhbQ5mZIb2h2s7/bifSW6a3QG3rf1ALa3wzpDU1w9ncbkd4KvRV6Q0+cWqgXkd4qx1YLkd4qvVV6q1SyDiK9NY6tUclGb43eGr01Ktk4b43eGsfWqKTQm9Cb0JtQSeG8Cb0JxyZUUuhN6K3TW6eSnfPW6a1zbJ1Kdnrr9NbprVPJwXkb9DY4tkElB70Nehv0NuCtAAdxBs6LmIiZWIiV2IhCpLcJb1jXczqii8gR3gSYiYUIbx3YiEKEN222G8QZiEbYawITMRMLcXlbTbQJPUaOQuzE5S1pc98MRCwxTMTlTbtwEUsMK7ER4U17BTtxEGcgYsnqjk3oQXLMxEKEN6iOWGIoxE6EN0wAYokiYolhIsIb5gKxxLASGxHeMC2IJYaDOAMRSxKmBbHEMBMLEc3MmBbEEkMhdiIamzEtiCWKiCWGiYimaUwLYolhJTYivGFaEEsMB3EGIpYgz0NPk2MmFiK8YVoQSwyF2InwhmlBLFFELDFMRHjDtCCWGFZiI8IbpgWxxHAQZyBiSca0IJYYZmIhomkc04JYYijETkQDOaYFsQSIbijHRFzetK0VscSwEhsR3gqwEwdxBiKWIMdGj5RjJhYivGmLbiMKsRPhTYAzELHEMBHhTTt+C7ESGxHeBrATB3EGakP+BCZiJhbi8rbesZyK9ucrCrETlzfsN9BbZYhYYpiIy1vFtCCWGFZiI8IbpgWxxHAQZyBiScW0IJYYZmIhwhumBbHEUIidCG+YFsQSRcQSw0SEN0wLYolhJTYivGFaEEsMB3EGIpZUTAtiiWEmFuLyhn0eerQchdiJy1vDtCCWKCKWGCbi8oa9Inq2HCuxEeEN04JYYjiIMxCxBDtP9HA5ZmIhwhumBbHEUIjdUfQhEgEO4gzE5WmYiJlYiJXYiEKkt0pvuDwb+tBxeRrC2wBmIrxN4PK2nh9KuB2bsPPGDdk78wUub9h746ZsWg8zJdyWTYLB4/IUnAMuT9Fe+OVN4A2XZ4cLXJ6Gjbi8dTjG5Wm4vGGDj1u1hrg8O04Hl6fh8oaNP27ZOsIbThKXpyG84XxxeRrCG04dl6ciLs+OUeDyNMxEeIOSuDwNG1GIy9vAiHF5Gi5vAyPG5WmYiJlYiJXYiELsxEEMb7jRi4feE271OmYivFVgJTaiEOGtAQdxBuKnbr19M+H2r2MmwlsHVmIjChHeBnAQZyB+6gzhDQ9Y4KfOsBArcXlD5Qc3hx07cRCXtwkl8VNnmIiZuLyheoSbxY6NKER4wwQglhjOQMQSQ3jDBCCWGBZiJcIb5gKxxLATBxHeMC2IJYaJmInwhmlBLDFsRCHCG6YFscRwBiKWGMIbpgWxxLAQK3EVMi99UkaInTiI68bDhWlBsd0wETNxFU2x58XNZ8dGFCK8YVpwA8xwBuImmCG8YVrQnGxYiJUIb5gW3JQ27MRBhDdMCx4YMEzETIQ3TAsaRQwbUYjwhmlB05bhdMQNa0d4m8BMLMRKXN6w/cXNa8dOHMTlDdtf3MR2TMRMXN70qVM0Nxs2ohDhDQ9F4aa24QzEwwaG8FaBmViIlQhvDSjEThxEeFvTgpvdjomYifDWgZXYiEKEN0wLGjENZyBuvhnCG6YFN+AMC7ESlzdsf/VmuGEnDuLyhu2v3hQ3TMRMXN6w/cXNccdGFCK86cNsgzgD0TBmCG+YFjSNGRZiJcIbpgWxxLATBxHeMC2IJYaJmInwhmlBLDFsRCHCG6YFscRwBiKWGMIbpgWxxLAQK3F5w/YXN9cdO3EQlzdsf3GT3TERM3F5w/YXN9sdG1GI8IZpQSwxnI648e4IbxWYiYVYA3HtYPuLm7qOjSjEThzEGYhrxzARM5HecO1gL41bvY5C7MRBnIG4dgwTMRMLkd5w7WBjjhvAjp04iPC2LhjcCHZMxEwsxEpsRCF24iDS26S3SW+T3ia9TXqb9DbpbdLbpLfp3vJ1XcREzER4w3Oleu0oNqIQ0dByAQcRjQsJD61eRNyezsBMRLtdAVYi2qoqUIjw1oCDCG+CJ2MvIrx1YCYWIrxhxPgdMhRiJ8IbRqytx0D8DunDtfgdMszEQqzERhRiJw7iDKz0ht8hfZgXv0OGhQhvUBK/Q4ZC7ER4g774HVLE75AhvEFq/A4ZFiK8QXXEEkMhdiK8YQIQSxQRSwwTEd4wAYglhpXYiPCGaUEsMRzEGYhYIlASscQwEwtxecPDrbj17CjETlzeBBOAWKKIWGKYiPCGCUAsMazERoQ3zAViieEgzkDEEsG0IJYYZmIhwhumBbHEUIidCG+YFsQSIO5JOyYivA1gIVZiI8LbBHbiIM5AxJJVDsm4Pe2YiYWI5t0EbEQhdiKa8TJwBuoDtIqJCG94EF7bphUrsRHhrQI7cRBnoD7I0ICJmImFCG8CbEQhdiK8YVoQSxQRSwwTEd4wLYglhpXYiPCGadEWT8VBnIHa6IlpQSwxzMRCROcNpkXbrhWF2IloKcW06CPxQH0oXjER4U1fYFCIldiI8IZp0ddUKA7iDNSHkzAt+niSYiYWIrxhWvQVMYpC7ER4w7RoiyhQm0QVExHeMC36+K5iJTYivGFatG1bcRBnIGLJxLQglhhmYiEubxPTglhiKMROXN4mpgWxBIhb1I6JCG8FWIiV2IjwVoGdOIgzELFkVXIyblE7ZmIhwpsAG1GInQhvHTgDEUsMExHeBrAQK7ER4W0CO3EQZyAeyFiVnKyvyTDMxEJcbaOrkpNxi9pRiJ24ut0uTAva3RTrRUxEeMO04JFFw0psgXgpw4VpwWsZDIXYiYM4HXFL0jERM7EQKxHeGlCInTiIMxAPqxomYiYWYiXSGxqVV40p45ak4yDOQDw0sGpMGbckHTOxECuxEYXYiYM4Awu9FXor9FbordBbobdCb4XeCr0Veqv0Vumt0lulN712BrARhdiJ8IZ3wODxc0U8gL4qZRm3JB2Xt1UTy7gl6bi84eVr+joIw+VNX8GGV0IYLm8JVxQeA1LEg0AJ041HgQzhDROLV7QYViK8YcR4MM+wEwcR3jBivDTJEN4wYjwoa1iIldiIQuzEQZyBeHjdkN70gQXIh0cWDCsRzdhQUl8modiJg4hHiKAvHiIyTER4g9T6ehfFSoQ3qK4P9Sl24iDC25qAqi9cUkzETIS3DqzERhQivA3gIM5AffBdEd4mMBMLsRKXt1WEyngRhWMnDuLytopQWV9IYZiImbi84U05eDGFYyMKEd4KcBBnIGKJIbxVYCYWYiXCWwMKsRMHEd4wLYglhomYifCGaUEsMWxEIcIbpgWxxHAGIpYYwhumBbHEsBArEQ9nYFr05TKKnTiIyxtKJ3jBhWMiZiIeEcK0IJYYNqIQ4Q3TglhiOAP1BWyK8IZpQSwxLMRKhDdMiz5sodiJgwhvmBZ9EYZiImYivGFaEEsMG1GI8IZpQSwxnIH6QKIivGFaEEsMC7ESlzcUX/CiDMdOHMTlbTVpZLwwwzERM3F5Q80GL85wbEQhwlsBDuIMRCwxhLcKzMRCrER4a0AhduIgwtuaFrxYwzERMxHeOrASG1GI8DaAgzgDEUsM4W0CM7EQK3F5QyWn6UP/ip04iHiEA9OCWGKYiJm4vKGSoy/iMGxEIcIbpgWxxHAG6otxFOEN04JYYliIlQhvmBbEEsNOHER4w7ToA8qKiZiJ8IZp0ZfHKTaiEOEN04JYYjgDEUsM4Q3TglhiWIiVuLyhkoMXeTh24iAub6jk4IUejomYHfG+iILqDN4Y4ZiJhViJjSjEThzEGVjpDZcRSj1oaXIsxEpsRCF24iDOQFxGhvSGywh1I7Q0OVZiI8KbADtxEGcgLiPDRMzEQqzERqQ3oTehN6G3Tm+d3jq9dXrr9NbprdNbp7dOb53e9DLqwETMRHgbwEqEtwkU4vKG4hZamhyXN5Sx0NLkuLyhYIWWJsflDaUptDQ5Lm8oQuk7KwzhDbOJnyTD6YiWpoIaE1qaHDOxEOGtAxsR3gawEwdxBuInyTARM7EQK7ER6Q0/SSg3oaXJcQbq+9YSMBEzsRCXN9SY0NLkKER4K8BBnIH63osKTMRMLER4wwQglhgKsRPhDROAWKKIWGKYiPCGaUEsMazERoQ3KKlPBCsO4gxELEE1qevb2hQzsRBvbxXVJLQ0OQqxE8dCTADeoKiIdygaJmJeiLnAmzMMK7ER4Q3TgreaGg7iDMS7bFAAQkuTYyYWIrxhWnojCrET4Q3TgieKFfFMsWEiwhumBW97M6zERoQ3TAue8jccxBmI9y+i2oGWJsdMLMTlDTUQtDQ5CrETlzdURtDSpDj0PTiKibi8oV6ClibHSmxEeCvAThzEGagPIVdgImZiIcJbAzaiEDsR3gQ4A/NFTER468BCrMRGhLcB7MRBnIEF3iYwETOxEJe31TiU0dLkKMROXN5QfEFLk+GKJY6JuLyh+IKWJsdKbER4w7TUThzEGYjX+uurelsiZmIhwhumBbHEUIidCG+YFsQSRcQSw0SEN0wLYolhJTYivGFaEEsMB3EGIpagJIOWJsdMLMTlDSUZtDQ5CrETlzeUZNDSZIhYYpiIyxtKMmhpcqzERoQ3TAtiieEgzkDEEpRk0NLkmImFCG+YFsQSQyF2IrxhWhBL9DXMiCWGiQhvHViIldiI8DaAnTiIMxCxRF/7jFhimImFuLyhJIM3jTgKsROXN315NGKJImKJYQrEtYOSDFqaHDOxECuxEYXYiYM4Awe94dpBfQctTY6FWImNKMROHMQZiGvHkN5w7aBYhJYmx0psRHhrwE4cxGlY0NLkmIiZWIiV2IhC7MRBpLdEb4neEr0lekv0lugt0Vuit0Rvid702hFgImYivE3g8qYvKsfvkOHytspNBS1Njsubvct8BhZ6K/RW6K3QW6G3Qm+F3gq9FXor9FbprdJbpbdKb5XeKr1Veqv0Vumt0lujt0Zvjd4avTV6a/TW6K3RW6O3Rm9Cb0JvQm9Cb0JvQm9Cb0JvQm9Cb53eOr11euv01umt01unt05vnd46vQ16G/Q26G3Q26C3QW+D3ga9DXob9DbpbdLbpLdJb5PeJr1Nepv0Nulthrd0hbd0JWImhje0NKkLtDQ5hje0NDkOuqA3xJIGY4glon+6vOHV72hpcqzE5W1V4ApamqqoheWtwxtiiX5GALFEvx+AWGK4vOk3BBBLDJc3/Y4AYonh8jbgArFkwgViycTpIJZMtbu8rT1kQUuTY1rvuoExvJfOsCyEXX0/pOLtrSW4wDsiDft6Mw70xXsiDedCaLZiiWMKURFLVNRKJSuVRCwxlBAVsURFRSxRURFLVNRGJRFLDKkkYokhlUQsMZQQFbFERUUsUVERS1RUoZKIJYZUEm+1M6SS+nZJRSqJN0waUkm8ZVKxU0n9+odiDlERS1TUTiU7lUQsMewhKmKJiopYoqIilqiog0oilhhSScQSQyqJWGLYQ1TEEhUVsURFRSxRUSeVRCwxpJJ4J54hldR3UypSSbyf0jCUREuTYyiZ9dshisVF1W/4iP5pKImWJsdOHC4qWppUVLQ0qahoaVJR0dKkSqKlyTGUREuTYyiJlibH4aKipUlFRUuTioqWJhUVLU2qJFqaHENJtDQ5hpJZ32ypGEqipcmwUEnEEkMqqV8eUawhKvISFbVQyUIlkZcYzhAVeYmKiliioiKWqKiVSiKWGFJJxBJDKolYYjhDVMQSFRWxREVFLFFRG5VELDGkkngfnyGV1PdiKlJJvBvTkEoilhhSSf1uiWILUZGXqKhCJYVKIi9RRF6ioiIvUVERS1RUxBIVtVNJxBJDKolYYkglEUsUEUtUVMQSFRWxREVFLFFRB5VELDGkknibnyGV1LdqAieVxJs1DakkYokhldSvnihKiIq8REWdVHKGkmhxc0wuKlrcVFS0uKmoaHFTUdHipkqixc0xlESLm2MoiRY3x+SiosVNRUWLm4qKFjcVFS1uqiRa3BxDSbS4OYaSRd/JqRhKosXNMZREi5tjKFn0mymK3UXVbxeJ/imVLFQSexzDHKJij6OiIpaoqIglKmqhkoglhlQSsUSxUknEEsMcoiKWqKiIJSoqYomKWqkkYokhlcR7ARUbldQ3eipSSbzV05BKIpYYUkn94oriCFGRl6ioQiWFSkomlhAVexwVFbFERUUsUVGFSiKWGFJJxBJDKolYYlhCVMQSFRWxREVFLFFRO5VELDGkkvg2hCGV1PeBKlJJvBPUkEoilhhSSf1ei+IMUZGXqKiTSk4qOQuxhqjY46ioiCUqKmKJijqp5Ix9AFrcVEm0uDmGkmhxc6wuKlrcVFS0uKmoaHFTUdHipkqixc0whZJocXMMJWsqxFASLW6OoSRa3BxDyZpiH4AWNxVVv7ok+qehJFrcHCsxdlRocVNR0eKmoqLFTUVFi5spWS4ilSyZSCVLJcaOCi1uJmqJHRVa3EzUQiXrRaSSNROpZK1EKlmFSCXrIFLJdhFjR6XfbFJRG5VsVLI1Yuyo0OJmorbYUaHFzUQVKimJSCWlEKmkNGLsqNDiZqJK7KjQ4maidirZE5FK9kKkkr0RqWTvRCrZYx9QB5UciRg7Kv3ik4o6qOSgkkOIsaNCi5uJOmJHhRY3E3VSyZmJVHJWIpWcQowdFVrcTNQZOyq0uKmoaHFTJdHi5hhKosXNMZRslxBDSbS4OYaSaHFzDCVbysTYUen3okT/NJRsSYidGDsqtLipqC3HjgotbioqWtxUSbS4OYaSLTdiKIkWN8fYUbUcO6pWYkeFFjcTtVDJUohUsjQilSydSCVL7ANapZI1EalkLcTYUenXplTUSiUrlayDGDsqtLiZqC12VGhxM1EblWyVSCWbEKlkG8TYUTWJHVWT2FGhxc1EFSoplUglRYhUUgaRSvaLSCV7JlLJXomxo9JvVamonUp2Ktkje0WLm4k6YkfVRuyo8OUqE3VQydGIVHJ0IpUcsQ/Ad6xM1Bk7qjZjR4WvWZmok0rORqSSsxOp5Ix9AL5tpUri61aOoSS+cOUYSsrViLGj0i9dif5pKClXKInvXTnGjkpS7KgkxY4K371SUfHlK1US375yDCUlDWIoiW9gOcaOSnLsqCTHjgrfwlJR8TUsVVKyEENJfBPLkUqWi0glSyZSyVKJVLIIMXZU+p0sFbVQyUolayLGjkpq7Kikxo4KfY4maqWStROpZI19APocTcmWiLGjkhY7Kmmxo0Kfo4naqGTrRCrZYh+APkdTUhKRSkohUklpRCopnRg7Kv3KloraqWSnkj0TY0clPXZU0mNHhT5HE7VTyT6IVHJcRCo5MjF2VDJiRyUjdlToczRRB5Ucg0gl50WkkjMTqeSsRCo5hUgl5yDGjkq/0QVR9Std9kndTCzE2FH1K3ZU/YodFfocVVT0OaqS6HM0TKFkT4kYSqLP0TF2VD3Fjqqn2FGhz1FFRZ+jKtlT7AN6DiXR5+gYSvZciKEk+hwdQ0n0OTqGkj3HPgB9jiZqiR2VfuNL5StUslRi7Kh6iR1VL7GjQp+jiVqoZL2IVLJmIpWslRg7ql5jR9Vr7KjQ52iiVirZLiKVbJlIJVslUskmRCrZBpFKykVEpoABae0V3hBL8Gll/UZY0T9d3gpOErHEsBOXt6p2l7cKC8hLcM8SfY4N9yzR59hwSxJ9jo7Lm+B8sccxXN50urHHMVzeRF0sbwIX2OMITgd7HJ1j1Es6JgD1EsPlbcAY6iWGy9uAXf2SiuLyNtTFDEQsmZAPscRweZvQDLHEsIaoiCUq6qSSk0oilhhOF1W/NQZR9WtjEBV9jioq+hxVSfQ5OoaS6HN0DCXR5+g4XVT0Oaqo6HNUUdHnqKKiz1GVRJ+jYyiJPkfHUHLoR1cUQ0n0OTqGkuhzdAwl0efo2FxU/T5Z0T8NJfUbZYYzUL9ThjNDXqKiIi9RUZGXqKiFSiIvMaSS2OMYUknscRSxx1FRscdRUbHHUVGxx1FRK5VEvcSQSqJeYkgl9ZsswEYlEUsMqSRiiSGVRCwxlBAVsURFbVSyUUnEEsMUoiKWqKiIJSoqYomKKlQSscSQSiKWGFJJxBLDFKIilqioiCUqKmKJitqpJGKJIZVELDGkkoglhlQSscSQSiKWGFJJxBLDHqIilqiog0pOKolYYphDVMQSFRWxREVFLFFRJ5VELDGkkoglwHmFkuhzdMwuKvocVVT0Oaqo6HNUUdHnqEqiz9ExlESfo2EKJdHn6BhKos/RMZREn6NjKIk+R8fhouqX1SCqflsN8unX1Qwzsbio+o01iKpfWYOo+M6aioovramS+NaaI5VELDGkkoglhiVERSxRURFLVFTEEhW1UEnEEkMqiVhiSCURSwypJGKJIZVELDGkkoglhjNERSxRURuVbFQSscSwhqiIJSoqYomKiliiojYqiViiKFQSscSQSiKWGNYQFbFERUUsUVERS1RUoZKIJYqdSiKWGFJJxBJDKolYYkglEUsMqSRiiSJiiYqKWKKiDio5qCRiiWELURFLVFTEEhUVsURFHVQSscSQSiKWGFJJxBLDFqIilqioiCUqKmKJijpdyYq+V0dXsqLv1dGVrOh7dXQlK/peHV3Jir5XR1eyou/VMZmoVT8DV/RPXcmqH4IzbEQxUat+C66qhWGiVvS9QtSKvlcoWdH36uhKVvS9OrqSFX2vjmKiVvS9QtSKvleIWtH3ClEr+l5NScQSQyqJWGJIJRFLDKkkYokhlUQsUaxUErHEMIeoiCUqaqWSlUpWIfYQFbFERUUsUVERS1TURiVbJlLJVolUsgmxh6iIJSoqYomKiliiogqVlEykklKJVFKESCVlEKlkv4hUsmdiCVF7DVE7lexUsnfiCFH7DFHHFaKOFKIOKjkKkUqORqSSoxNHiDpmiDqvEHWmEHVSyVmIVHI2IpWcnUglp+8DKvpeVUn0vTqGkuh7dfQdVUXfq4qKvleVD32vjoPoO6qKvlcVFX2vKir6XlVU9L2qkuh7dQwl0ffqGEqi79XRd1QVfa8qKvpeVVT0vaqo6HtVJdH36hhKou/VMZRE36sjlSwXkUqWTKSSpRJbiFokRC1UslDJMgPrFaLWFKLWHKLWEqJWKlkbkUrWTqSSdQa2K0RtKURtOURtJURtVLI1IpVsnUgl2wwUKimJSCWlEKmkNKKEqNJDVKGSQiX7RUwhas8hai8haq8haqeSXYhUsg8ilRwXMYWoI4eoo4Soo4aog0oOIVLJMYhUcl5EKjkzkUrOSqSSU4g9RJ0jRJ2hpPa9Giai76gq+l5VVPS9qqjoe1VR0feqSqLv1TGUzNcMTKFkTonoO6qKvlcVFX2vKir6XlVU9L2qkuh7dQwlc5qBOZRE36tjKIm+V8dQUvteDUNJ7Xs19B1V1b5XiKp9rypfoZIlE0uIWmqIWlqIWiRELVSyDCKVrBeRStZMLCFqrSFqbSFqlRC1Usk6iFSyXUQq2TKRSrZKpJJNiFSyDeIMUeUKUYVKCpWUQqwhqrQQVSRElR6iCpWUGdipZE9EKtkLsYaovYWoXULU3kPUTiV77APyoJIjEankKEQqORqRSo5OpJIj9gHa96qizhSiTio5qeSsxBaiTglRZw9R5whRZyiJvlfHULJcmRhKlqsSfUdVy+U7qlou31FV9L2qqOh7VSXR9+oYSpaUiaEk+l4dQ8mShBhKat+rYSipfa+GsaPSvteifxpKat+rYSPGjgp9ryoq+l5VVPS9qqjoezUlSyJSyVKIVLI0YuyoSokdVSmxo0Lfq4laqWRNRCpZC5FK1kakkrUTqWSNfYD2vaqSLRFjR6V9rypqo5KNSjYhxo4Kfa8maosdFfpeTVShkpKJVFIqkUqKEGNHVSR2VEViR4W+VxO1U8meiVSyVyKV7EKkkn0QqeS4iFRyZGLsqLTvVUUdVHJQydGJsaNC36uJOmNHhb5XE3VSyVmIVHI2IpWcnRg7qjJjR1Wv2FGh71VFRd+rKom+V8dQsl6NGEqi79UxlKxX7AO07xVKat+rYSipfa+GyBQm8PYmF85sxRK54HjFEsdBnIErljgmYiYWYiXCG0achdiJgzgDC70Veiv0Vgr/biXSW6G3Qm+F3gq9VXqr9FbprdJbpbdKb5XeKr1Veqv01uit0Vujt0Zvjd4avTV6a/TW6K3Rm9Cb0JvQm9Cb0JvQm9Cb0JvQm9Bbp7dOb53eOr11euv01umt01unt05vg94GvQ16G/Q26G3Q26C3QW+D3ga9TXjDgpyJmImFWImNCG9YphPesI7nIE5H9L06JmImFmIlNqIQOxHeOnAGpouYiJlYiJXYiELsRHrTWLKCY9NYopiImQhvE1iJy9t6X1BF36tjJw7iDEQsMVzeVjNFRd+r4/K23hdU0ffqCG8FCG8VCG8NOIgzELEkYcSIJYaZWPh3K7ERhX+3EwcR3iAUYolhImYivTV6a/SGWJJwaSCWGA7iDEQsMeTYhGNDLDGscQ6IJYZC7MRB5Ng6x9Y5NsQSPfXOsXWODbFET7JzbJ1j6xxb59gGx4ZYYsixDY4NscSQYxsc2+DYBsc2OLbJsU2ObXLeJsc2ObbJeZsc2+TYJsc2Y2zoe3VMxEyMsaHv1bERY2zoe3UcxBgb+l4dEzETCzHGhr5XRyHG2ND36sixZY4tc2yZY0MsMeTYMseWhcixZY4tc2yFYyscW+HYCsdWKpFjKxwbY4kUjq1wbJVjqxxb5dgqx6axRJFjYywRxhKpHBtjiTCWCGOJMJZI49gax9YakWNrHFsbRI6NsUSEYxOOTTg24dikETk24dhkEDk2xhJhLJHOsXWOrXNsnWPrXAGdY+scW4/fAGEsEcYSGRzb4NgGxzY4tiFEjm1wbBpLgIwlwlgijCUyObbJsU2ObXJskytAY8kETkf0vcrqPKzoe3XMxEJc3tbL3yr6Xh2F2InL2+pdrOh7NUQsWa95q+h7dYS3CixEeGvARoS3DoQ3jAKxpOAkEUsUEUsKHCOWFFhALKn6F5a3CmOIJdhOou/VcXlbr5Gu6Ht1XN5ELcxAxBJsJ9H3KgILiCVd/3R5w24Rfa+Ojbi8dZwOYklXC8vbgKiIJdhDou9VsHFE36vj8oaNI/peHZc3bBzR9+q4vGEPib7Xjj0k+l47EmT0vXZkmeh77cjl0PfqeHvruGjR9+pYF8LuiiWOt7eul8aKJY7Lm07WiiWGK5Z0nbcVSxyXN53CFUtuXX777tv/fP/rj9//5acf/v7tT/+6/+d//fPnv/7jx19+tv/5j//7N/9//vLrjz/99ON///lvv/7y1x/+85+//vDnn3756/r/vl3rP+vC/D/3dZfnf9x/OfGP+ncl/8dvv/32H7/9Pw==","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n//\n// IMPORTANT: Prefer `multi_scalar_mul()` over repeated `embedded_curve_add()`\n// for adding multiple points. This is significantly more efficient.\n// For adding exactly 2 points, use `embedded_curve_add()` directly.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// Elliptic curve addition\n/// IMPORTANT: this function is expected to perform a full addition in order to handle all corner cases:\n/// - points on the curve\n/// - point doubling\n/// - point at infinity\n/// As a result, you may not get optimal performance, depending on the assumptions of your inputs.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // avoid calling the black box function for trivial cases\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_inner(point1, point2)\n        }\n    } else {\n        embedded_curve_add_inner(point1, point2)\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// EC addition wrapper for the foreign function\nfn embedded_curve_add_inner(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    crate::assert_constant(separator);\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"/// Game Move circuit.\n/// Proves that a game move is valid: one card placed from correct player,\n/// board state correctly updated with capture logic.\n/// Also computes ECDH shared secret to encrypt the placed card's nullifier.\n///\n/// Public inputs:\n///   card_commit_1, card_commit_2 - player card commitments (include ranks)\n///   start_state_hash - hash of board state before this move\n///   end_state_hash - hash of board state after this move\n///   game_ended - 1 if game over, 0 otherwise\n///   winner_id - 0=not ended, 1=player1 wins, 2=player2 wins, 3=draw\n///   encrypted_card_nullifier - the placed card's nullifier secret, encrypted with ECDH shared key\n///\n/// The circuit verifies:\n/// 1. The placed card is in the current player's committed hand (card_commit binding)\n/// 2. Capture logic: rank comparison for all adjacent opponent cells\n/// 3. Non-placed, non-captured cells are unchanged between board_before/board_after\n/// 4. Scores are consistent with board ownership + hand counts\n/// 5. Game end detection and winner determination\n/// 6. ECDH encryption of placed card's nullifier secret\n\n/// Board cell: each cell is (card_id, owner) where owner 0=empty, 1=player1, 2=player2\n\nuse std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n// External poseidon dep removed; using stdlib pedersen_hash instead\n\n/// Grumpkin generator point G\nglobal G: EmbeddedCurvePoint = EmbeddedCurvePoint {\n    x: 0x083e7911d835097629f0067531fc15cafd79a89beecb39903f69572c636f4a5a,\n    y: 0x1a7f5efaad7f315c25a918f30cc8d7333fccab7ad7c90f14de81bcc528f9935d,\n    is_infinite: false,\n};\n\n/// Compute ECDH shared secret: shared_point = my_private_key * opponent_public_key\nfn compute_shared_secret(my_private_key: Field, opponent_pubkey: EmbeddedCurvePoint) -> Field {\n    let shared_point = multi_scalar_mul(\n        [opponent_pubkey],\n        [EmbeddedCurveScalar::from_field(my_private_key)],\n    );\n    shared_point.x\n}\n\n/// Key expansion for symmetric encryption using pedersen hash with move-index nonce.\n/// The nonce (current_turn_before) ensures a unique key per move, preventing\n/// an attacker who recovers one plaintext from decrypting all other moves.\nfn expand_secret(secret: Field, nonce: Field) -> Field {\n    std::hash::pedersen_hash([secret, nonce])\n}\n\n/// Symmetric encrypt a single field element using ECDH shared secret and move nonce.\nfn symmetric_encrypt_field(plaintext: Field, secret: Field, nonce: Field) -> Field {\n    let key = expand_secret(secret, nonce);\n    key + plaintext\n}\n\n// ====================== CARD DATABASE ======================\n/// Hardcoded card rank database: 50 cards with ranks [top, right, bottom, left].\nfn get_card_ranks(card_id: u32) -> [Field; 4] {\n    assert((card_id >= 1) & (card_id <= 50), \"Invalid card ID for rank lookup\");\n\n    // Level 1 - Common (IDs 1-10)\n    if card_id == 1 { [1, 4, 1, 5] }         // Mudwalker\n    else if card_id == 2 { [5, 1, 1, 3] }    // Blushy\n    else if card_id == 3 { [1, 3, 3, 5] }    // Snowdrop\n    else if card_id == 4 { [6, 1, 1, 2] }    // Sunny\n    else if card_id == 5 { [2, 3, 1, 5] }    // Inkwell\n    else if card_id == 6 { [2, 1, 4, 4] }    // Stripes\n    else if card_id == 7 { [1, 5, 4, 1] }    // Barkeeper\n    else if card_id == 8 { [3, 1, 5, 2] }    // Dotty\n    else if card_id == 9 { [2, 1, 6, 1] }    // Penny\n    else if card_id == 10 { [4, 3, 2, 4] }   // Peaches\n    // Level 2 - Uncommon (IDs 11-20)\n    else if card_id == 11 { [2, 6, 1, 6] }   // Freckles\n    else if card_id == 12 { [7, 1, 3, 1] }   // Camo\n    else if card_id == 13 { [6, 2, 2, 3] }   // Neon\n    else if card_id == 14 { [5, 3, 3, 4] }   // Glow Bug\n    else if card_id == 15 { [6, 1, 4, 3] }   // Limelight\n    else if card_id == 16 { [3, 4, 5, 3] }   // Marble\n    else if card_id == 17 { [5, 3, 2, 5] }   // Sapphire\n    else if card_id == 18 { [5, 1, 3, 5] }   // Jefferson\n    else if card_id == 19 { [5, 2, 5, 2] }   // Longfoot\n    else if card_id == 20 { [4, 2, 4, 5] }   // Featherfin\n    // Level 3 - Rare (IDs 21-30)\n    else if card_id == 21 { [3, 7, 2, 5] }   // Lilac\n    else if card_id == 22 { [5, 2, 5, 5] }   // Patches\n    else if card_id == 23 { [6, 6, 3, 3] }   // Faded\n    else if card_id == 24 { [6, 3, 6, 3] }   // Gold Dust\n    else if card_id == 25 { [3, 5, 5, 5] }   // Phantom\n    else if card_id == 26 { [7, 5, 1, 3] }   // Ash\n    else if card_id == 27 { [7, 1, 5, 3] }   // Cocoa\n    else if card_id == 28 { [5, 3, 6, 3] }   // Ringmaster\n    else if card_id == 29 { [5, 6, 2, 4] }   // Goldrush\n    else if card_id == 30 { [4, 4, 7, 2] }   // Swampling\n    // Level 4 - Epic (IDs 31-40)\n    else if card_id == 31 { [3, 6, 4, 7] }   // Glitter\n    else if card_id == 32 { [7, 2, 3, 7] }   // Starfield\n    else if card_id == 33 { [2, 3, 7, 7] }   // Specter\n    else if card_id == 34 { [6, 5, 5, 5] }   // Saffron\n    else if card_id == 35 { [4, 7, 6, 2] }   // Stardust\n    else if card_id == 36 { [2, 3, 7, 8] }   // Achoque\n    else if card_id == 37 { [1, 7, 6, 4] }   // Zacapu\n    else if card_id == 38 { [7, 3, 1, 6] }   // Laguna\n    else if card_id == 39 { [7, 4, 4, 4] }   // Streamwalker\n    else if card_id == 40 { [3, 7, 3, 6] }   // Digger\n    // Level 5 - Legendary (IDs 41-50)\n    else if card_id == 41 { [6, 7, 3, 7] }   // Eclipse\n    else if card_id == 42 { [6, 5, 8, 4] }   // Kaleidoscope\n    else if card_id == 43 { [6, 5, 6, 6] }   // Twinned\n    else if card_id == 44 { [3, 6, 7, 8] }   // Sparkletail\n    else if card_id == 45 { [7, 6, 5, 6] }   // Riddler\n    else if card_id == 46 { [3, 10, 2, 1] }  // Rosita\n    else if card_id == 47 { [6, 2, 6, 7] }   // Brooklet\n    else if card_id == 48 { [5, 5, 7, 6] }   // Whisper\n    else if card_id == 49 { [7, 7, 4, 2] }   // Misty\n    else { [7, 2, 7, 4] }                    // Lerma (50)\n}\n\n// ====================== HASH FUNCTIONS ======================\n\nfn hash_board_state(board: [Field; 18], scores: [Field; 2], current_turn: Field) -> Field {\n    let mut inputs: [Field; 21] = [0; 21];\n    for i in 0..18 {\n        inputs[i] = board[i];\n    }\n    inputs[18] = scores[0];\n    inputs[19] = scores[1];\n    inputs[20] = current_turn;\n    std::hash::pedersen_hash(inputs)\n}\n\n/// Compute card commitment hash (must match prove_hand format).\n/// Format: hash(player_secret, player_address, game_id,\n///              card_ids[5], card_ranks[5*4], nullifier_secrets[5])\nfn compute_card_commit(\n    player_secret: Field,\n    player_address: Field,\n    game_id: Field,\n    card_ids: [Field; 5],\n    card_ranks: [[Field; 4]; 5],\n    nullifier_secrets: [Field; 5],\n) -> Field {\n    let mut hash_inputs: [Field; 33] = [0; 33];\n    hash_inputs[0] = player_secret;\n    hash_inputs[1] = player_address;\n    hash_inputs[2] = game_id;\n    for i in 0..5 {\n        hash_inputs[3 + i] = card_ids[i];\n    }\n    for i in 0..5 {\n        for j in 0..4 {\n            hash_inputs[8 + i * 4 + j] = card_ranks[i][j];\n        }\n    }\n    for i in 0..5 {\n        hash_inputs[28 + i] = nullifier_secrets[i];\n    }\n    std::hash::pedersen_hash(hash_inputs)\n}\n\n// ====================== MAIN CIRCUIT ======================\n\nfn main(\n    // Public inputs\n    card_commit_1: pub Field,\n    card_commit_2: pub Field,\n    start_state_hash: pub Field,\n    end_state_hash: pub Field,\n    game_ended: pub Field,\n    winner_id: pub Field,\n    encrypted_card_nullifier: pub Field,\n    // Private inputs - move data\n    current_player: Field,       // 1 or 2\n    card_id: Field,              // ID of card being placed\n    row: Field,                  // 0-2\n    col: Field,                  // 0-2\n    // Private inputs - board state\n    board_before: [Field; 18],   // 9 cells x 2 fields (card_id, owner)\n    board_after: [Field; 18],\n    scores_before: [Field; 2],\n    scores_after: [Field; 2],\n    current_turn_before: Field,\n    // Private inputs - current player's hand commitment data\n    player_secret: Field,\n    player_address: Field,\n    game_id: Field,\n    player_card_ids: [Field; 5],\n    player_card_ranks: [[Field; 4]; 5],\n    player_nullifier_secrets: [Field; 5],\n    // Private inputs - ECDH encryption (FIX-3)\n    grumpkin_private_key: Field,\n    opponent_pubkey_x: Field,\n    opponent_pubkey_y: Field,\n) {\n    // ===== 1. Validate current player =====\n    assert(\n        (current_player == 1) | (current_player == 2),\n        \"Invalid player\",\n    );\n    assert(current_player == current_turn_before, \"Not this player's turn\");\n\n    // ===== 2. Validate position =====\n    let r = row as u32;\n    let c = col as u32;\n    assert(r < 3, \"Row out of bounds\");\n    assert(c < 3, \"Col out of bounds\");\n\n    // ===== 3. Verify card_commit binding (FIX-1) =====\n    // Recompute the current player's card_commit from their hand data\n    let recomputed_commit = compute_card_commit(\n        player_secret,\n        player_address,\n        game_id,\n        player_card_ids,\n        player_card_ranks,\n        player_nullifier_secrets,\n    );\n\n    // Verify it matches the correct card_commit (1 or 2 based on current_player)\n    if current_player == 1 {\n        assert(recomputed_commit == card_commit_1, \"Player 1 card commit mismatch\");\n    } else {\n        assert(recomputed_commit == card_commit_2, \"Player 2 card commit mismatch\");\n    }\n\n    // ===== 4. Verify placed card is in committed hand =====\n    let mut card_found: bool = false;\n    let mut placed_card_ranks: [Field; 4] = [0; 4];\n    let mut placed_card_nullifier_secret: Field = 0;\n    for i in 0..5 {\n        if player_card_ids[i] == card_id {\n            card_found = true;\n            placed_card_ranks = player_card_ranks[i];\n            placed_card_nullifier_secret = player_nullifier_secrets[i];\n        }\n    }\n    assert(card_found, \"Placed card not in committed hand\");\n\n    // ===== NEW: Verify card has not already been placed (C2 fix) =====\n    for i in 0..9 {\n        if board_before[i * 2 + 1] != 0 {\n            // Cell is occupied -- verify it's not the same card\n            assert(board_before[i * 2] != card_id, \"Card already placed on board\");\n        }\n    }\n\n    // Verify the committed ranks match the hardcoded card database\n    let db_ranks = get_card_ranks(card_id as u32);\n    for i in 0..4 {\n        assert(\n            placed_card_ranks[i] == db_ranks[i],\n            \"Placed card ranks do not match database\",\n        );\n    }\n\n    // ===== 5. Verify the cell was empty before the move =====\n    let cell_idx = r * 3 + c;\n    assert(board_before[cell_idx * 2] == 0, \"Cell not empty\");\n    assert(board_before[cell_idx * 2 + 1] == 0, \"Cell not empty (owner)\");\n\n    // ===== 6. Verify the card was placed in board_after =====\n    assert(board_after[cell_idx * 2] == card_id, \"Card not placed correctly\");\n    assert(\n        board_after[cell_idx * 2 + 1] == current_player,\n        \"Owner not set correctly\",\n    );\n\n    // ===== 7. Capture logic (FIX-2) =====\n    // Determine the opponent\n    let opponent: Field = if current_player == 1 { 2 } else { 1 };\n\n    // Track which cells are captured (1 = captured, 0 = not)\n    let mut captured: [bool; 9] = [false; 9];\n\n    // Check all 4 adjacent directions:\n    // Direction 0: Top    (row-1, col)   - placed card's top vs adjacent card's bottom\n    // Direction 1: Right  (row, col+1)   - placed card's right vs adjacent card's left\n    // Direction 2: Bottom (row+1, col)   - placed card's bottom vs adjacent card's top\n    // Direction 3: Left   (row, col-1)   - placed card's left vs adjacent card's right\n\n    // placed_card_ranks: [top, right, bottom, left]\n    // adjacent ranks:    [top=0, right=1, bottom=2, left=3]\n    // Facing rank pairs: placed_top vs adj_bottom, placed_right vs adj_left,\n    //                    placed_bottom vs adj_top, placed_left vs adj_right\n\n    // Direction 0: Top (row-1, col)\n    if r > 0 {\n        let adj_idx = (r - 1) * 3 + c;\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's top vs adjacent card's bottom\n            let placed_rank = placed_card_ranks[0] as u32;\n            let adj_rank = adj_ranks[2] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 1: Right (row, col+1)\n    if c < 2 {\n        let adj_idx = r * 3 + (c + 1);\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's right vs adjacent card's left\n            let placed_rank = placed_card_ranks[1] as u32;\n            let adj_rank = adj_ranks[3] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 2: Bottom (row+1, col)\n    if r < 2 {\n        let adj_idx = (r + 1) * 3 + c;\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's bottom vs adjacent card's top\n            let placed_rank = placed_card_ranks[2] as u32;\n            let adj_rank = adj_ranks[0] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 3: Left (row, col-1)\n    if c > 0 {\n        let adj_idx = r * 3 + (c - 1);\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's left vs adjacent card's right\n            let placed_rank = placed_card_ranks[3] as u32;\n            let adj_rank = adj_ranks[1] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // ===== 8. Verify board_after matches expected state =====\n    // For each cell, verify:\n    // - Placed cell: already verified above (card_id and owner)\n    // - Captured cell: card_id unchanged, owner changed to current_player\n    // - All other cells: identical to board_before\n    for i in 0..9 {\n        if i as u32 != cell_idx {\n            let before_card = board_before[i * 2];\n            let before_owner = board_before[i * 2 + 1];\n            let after_card = board_after[i * 2];\n            let after_owner = board_after[i * 2 + 1];\n\n            // Card ID must never change for non-placed cells\n            assert(after_card == before_card, \"Non-placed cell card_id changed\");\n\n            if captured[i] {\n                // Captured cell: owner must change to current_player\n                assert(\n                    after_owner == current_player,\n                    \"Captured cell owner not updated\",\n                );\n            } else {\n                // Non-captured cell: owner must stay the same\n                assert(after_owner == before_owner, \"Non-captured cell owner changed\");\n            }\n        }\n    }\n\n    // ===== 9. Verify start_state_hash matches board_before =====\n    let computed_start = hash_board_state(board_before, scores_before, current_turn_before);\n    assert(computed_start == start_state_hash, \"Start state hash mismatch\");\n\n    // ===== 10. Compute and verify end state =====\n    let next_turn: Field = if current_player == 1 { 2 } else { 1 };\n    let computed_end = hash_board_state(board_after, scores_after, next_turn);\n    assert(computed_end == end_state_hash, \"End state hash mismatch\");\n\n    // ===== 11. Verify game ended flag =====\n    let mut filled: u32 = 0;\n    for i in 0..9 {\n        if board_after[i * 2] != 0 {\n            filled += 1;\n        }\n    }\n\n    if filled == 9 {\n        assert(game_ended == 1, \"Game should have ended\");\n        let p1_score = scores_after[0] as u32;\n        let p2_score = scores_after[1] as u32;\n        if p1_score > p2_score {\n            assert(winner_id == 1, \"Player 1 should be winner\");\n        } else if p2_score > p1_score {\n            assert(winner_id == 2, \"Player 2 should be winner\");\n        } else {\n            assert(winner_id == 3, \"Should be a draw\");\n        }\n    } else {\n        assert(game_ended == 0, \"Game should not have ended\");\n        assert(winner_id == 0, \"No winner yet\");\n    }\n\n    // ===== 12. Verify scores are exactly correct (C1 fix) =====\n    let mut p1_board: u32 = 0;\n    let mut p2_board: u32 = 0;\n    for i in 0..9 {\n        let owner = board_after[i * 2 + 1];\n        if owner == 1 {\n            p1_board += 1;\n        } else if owner == 2 {\n            p2_board += 1;\n        }\n    }\n    // Player 1 goes first, so P1 has placed ceil(filled/2) cards, P2 has placed floor(filled/2)\n    let p1_played = (filled + 1) / 2;\n    let p2_played = filled / 2;\n    let p1_hand = 5 - p1_played;\n    let p2_hand = 5 - p2_played;\n    let expected_p1_score = p1_board + p1_hand;\n    let expected_p2_score = p2_board + p2_hand;\n    assert(scores_after[0] == expected_p1_score as Field, \"P1 score mismatch\");\n    assert(scores_after[1] == expected_p2_score as Field, \"P2 score mismatch\");\n\n    // ===== 13. Validate Grumpkin private key is non-zero (V6 Fix 3.1) =====\n    assert(grumpkin_private_key != 0, \"grumpkin_private_key must be non-zero\");\n\n    // ===== 14. Validate opponent public key is on Grumpkin curve (V6 Fix 3.3) =====\n    // Grumpkin curve equation: y^2 = x^3 - 17 (a=0, b=-17)\n    let x3 = opponent_pubkey_x * opponent_pubkey_x * opponent_pubkey_x;\n    let y2 = opponent_pubkey_y * opponent_pubkey_y;\n    assert(y2 == x3 - 17, \"opponent public key not on Grumpkin curve\");\n\n    // ===== 15. ECDH encryption of card nullifier =====\n    let opponent_pubkey = EmbeddedCurvePoint {\n        x: opponent_pubkey_x,\n        y: opponent_pubkey_y,\n        is_infinite: false,\n    };\n    let shared_secret = compute_shared_secret(grumpkin_private_key, opponent_pubkey);\n    // Use current_turn_before as nonce for per-move unique key (V6 Fix 3.2)\n    let computed_encrypted = symmetric_encrypt_field(placed_card_nullifier_secret, shared_secret, current_turn_before);\n    assert(\n        computed_encrypted == encrypted_card_nullifier,\n        \"Encrypted nullifier mismatch\",\n    );\n}\n\n// ====================== TEST HELPERS ======================\n\n/// Helper: create a card_commit for test use\nfn test_card_commit(\n    player_secret: Field,\n    player_address: Field,\n    game_id: Field,\n    card_ids: [Field; 5],\n    card_ranks: [[Field; 4]; 5],\n    nullifier_secrets: [Field; 5],\n) -> Field {\n    compute_card_commit(player_secret, player_address, game_id, card_ids, card_ranks, nullifier_secrets)\n}\n\n/// Helper: compute encrypted nullifier for tests (with move nonce)\nfn test_encrypt_nullifier(nullifier_secret: Field, player_grumpkin_key: Field, opponent_pubkey: EmbeddedCurvePoint, nonce: Field) -> Field {\n    let shared_secret = compute_shared_secret(player_grumpkin_key, opponent_pubkey);\n    symmetric_encrypt_field(nullifier_secret, shared_secret, nonce)\n}\n\n/// Helper: derive Grumpkin public key\nfn test_derive_pubkey(private_key: Field) -> EmbeddedCurvePoint {\n    multi_scalar_mul([G], [EmbeddedCurveScalar::from_field(private_key)])\n}\n\n// Default hand data for Player 1 in tests: cards 1-5\n// Mudwalker[1,4,1,5], Blushy[5,1,1,3], Snowdrop[1,3,3,5], Sunny[6,1,1,2], Inkwell[2,3,1,5]\nglobal P1_SECRET: Field = 111;\nglobal P1_ADDRESS: Field = 0xaaa;\nglobal TEST_GAME_ID: Field = 1;\nglobal P1_GRUMPKIN_KEY: Field = 42;\n\nfn p1_card_ids() -> [Field; 5] { [1, 2, 3, 4, 5] }\nfn p1_card_ranks() -> [[Field; 4]; 5] {\n    [[1, 4, 1, 5], [5, 1, 1, 3], [1, 3, 3, 5], [6, 1, 1, 2], [2, 3, 1, 5]]\n}\nfn p1_nullifier_secrets() -> [Field; 5] { [100, 200, 300, 400, 500] }\n\n// Default hand data for Player 2 in tests: cards 10-14\n// Peaches[4,3,2,4], Freckles[2,6,1,6], Camo[7,1,3,1], Neon[6,2,2,3], Glow Bug[5,3,3,4]\nglobal P2_SECRET: Field = 222;\nglobal P2_ADDRESS: Field = 0xbbb;\nglobal P2_GRUMPKIN_KEY: Field = 77;\n\nfn p2_card_ids() -> [Field; 5] { [10, 11, 12, 13, 14] }\nfn p2_card_ranks() -> [[Field; 4]; 5] {\n    [[4, 3, 2, 4], [2, 6, 1, 6], [7, 1, 3, 1], [6, 2, 2, 3], [5, 3, 3, 4]]\n}\nfn p2_nullifier_secrets() -> [Field; 5] { [600, 700, 800, 900, 1000] }\n\nfn get_p1_commit() -> Field {\n    test_card_commit(P1_SECRET, P1_ADDRESS, TEST_GAME_ID, p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets())\n}\n\nfn get_p2_commit() -> Field {\n    test_card_commit(P2_SECRET, P2_ADDRESS, TEST_GAME_ID, p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets())\n}\n\nfn get_p1_pubkey() -> EmbeddedCurvePoint {\n    test_derive_pubkey(P1_GRUMPKIN_KEY)\n}\n\nfn get_p2_pubkey() -> EmbeddedCurvePoint {\n    test_derive_pubkey(P2_GRUMPKIN_KEY)\n}\n\n/// Helper: compute encrypted nullifier for P1 placing a card (P1 encrypts for P2 to decrypt)\nfn p1_encrypt_nullifier(nullifier_secret: Field, nonce: Field) -> Field {\n    test_encrypt_nullifier(nullifier_secret, P1_GRUMPKIN_KEY, get_p2_pubkey(), nonce)\n}\n\n/// Helper: compute encrypted nullifier for P2 placing a card (P2 encrypts for P1 to decrypt)\nfn p2_encrypt_nullifier(nullifier_secret: Field, nonce: Field) -> Field {\n    test_encrypt_nullifier(nullifier_secret, P2_GRUMPKIN_KEY, get_p1_pubkey(), nonce)\n}\n\n// ====================== TESTS ======================\n\n#[test]\nfn test_first_move_no_capture() {\n    // Player 1 places card 1 (Mudwalker) at (0,0) on empty board - no captures possible\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; // card_id = 1 (Mudwalker)\n    board_after[1] = 1; // owner = player1\n    let scores_after: [Field; 2] = [5, 5]; // 1 on board + 4 in hand = 5\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 1 (Mudwalker) has nullifier_secret = 100, nonce = current_turn_before = 1\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,       // game not ended\n        enc_null,\n        1,          // current_player\n        1,          // card_id (Mudwalker)\n        0, 0,       // row, col\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        // Player 1 hand data\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        // ECDH data\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_second_move_no_capture() {\n    // Player 2 places card 10 (Peaches) at (1,1)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; // card at (0,0): card_id=1, owner=player1\n    board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    board_after[8] = 10; // card at (1,1): card_id=10, owner=player2\n    board_after[9] = 2;\n    let scores_after: [Field; 2] = [5, 5]; // p1: 1+4=5, p2: 1+4=5\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 10 (Peaches) has nullifier_secret = 600, nonce = current_turn_before = 2\n    let enc_null = p2_encrypt_nullifier(600, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,          // current_player = player2\n        10,         // card_id = Peaches\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        // Player 2 hand data\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        // ECDH data\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n#[test]\nfn test_capture_one_card() {\n    // Player 1 has card 1 (Mudwalker [1,4,1,5]) at (0,0)\n    // Player 2 has card 10 (Peaches [4,3,2,4]) at (0,1)\n    // Player 1 places card 4 (Sunny [6,1,1,2]) at (1,1)\n    // (1,1) is adjacent to (0,1) - placed card's top=6 vs Peaches's bottom=2 -> 6>2 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, player 1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, player 2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;     // (0,0) unchanged\n    board_after[2] = 10; board_after[3] = 1;    // (0,1) CAPTURED - owner changed to player 1\n    board_after[8] = 4; board_after[9] = 1;     // (1,1) placed card 4, player 1\n    let scores_after: [Field; 2] = [6, 4];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 4 (Sunny) has nullifier_secret = 400, nonce = current_turn_before = 1\n    let enc_null = p1_encrypt_nullifier(400, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1,          // current_player\n        4,          // card_id = Sunny\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_capture_multiple_cards() {\n    // P1 places card 1 Mudwalker [1,4,1,5] at (1,1):\n    // Right (1,2): Card 12 Camo left=1 vs placed right=4 -> 4>1 CAPTURE!\n    // Left (1,0): Card 10 Peaches right=3 vs placed left=5 -> 5>3 CAPTURE!\n    // Top (0,1): Card 11 Freckles bottom=1 vs placed top=1 -> NO (equal)\n    // Bottom (2,1): Card 13 Neon top=6 vs placed bottom=1 -> NO\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;   // (0,1) Freckles\n    board_before[6] = 10; board_before[7] = 2;   // (1,0) Peaches\n    board_before[10] = 12; board_before[11] = 2; // (1,2) Camo\n    board_before[14] = 13; board_before[15] = 2; // (2,1) Neon\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;     // (0,1) unchanged\n    board_after[6] = 10; board_after[7] = 1;     // (1,0) CAPTURED\n    board_after[8] = 1; board_after[9] = 1;      // (1,1) placed\n    board_after[10] = 12; board_after[11] = 1;   // (1,2) CAPTURED\n    board_after[14] = 13; board_after[15] = 2;   // (2,1) unchanged\n    // filled=5, p1_board=3, p2_board=2, p1_played=3, p2_played=2\n    // p1_score = 3 + (5-3) = 5, p2_score = 2 + (5-2) = 5\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 1 (Mudwalker) has nullifier_secret = 100, nonce = current_turn_before = 1\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1,\n        1,          // card_id = Mudwalker\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_no_capture_higher_adjacent() {\n    // P1 card 3 Snowdrop [1,3,3,5] at (0,0). (0,1) has P2 card 14 Glow Bug [5,3,3,4].\n    // Placed right=3 vs adj left=4. 3<4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 3 (Snowdrop) has nullifier_secret = 300, nonce = current_turn_before = 1\n    let enc_null = p1_encrypt_nullifier(300, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1,\n        3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p1_wins() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    board_before[2] = 10; board_before[3] = 2;\n    board_before[4] = 2; board_before[5] = 1;\n    board_before[6] = 11; board_before[7] = 2;\n    board_before[8] = 3; board_before[9] = 1;\n    board_before[10] = 12; board_before[11] = 1;\n    board_before[12] = 4; board_before[13] = 1;\n    board_before[14] = 13; board_before[15] = 2;\n\n    let scores_before: [Field; 2] = [6, 4];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    board_after[16] = 5;\n    board_after[17] = 1;\n    // (2,1) card 13 Neon: placed left=5 vs adj right=2 -> 5>2 CAPTURE!\n    board_after[15] = 1;\n\n    let scores_after: [Field; 2] = [7, 3];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 5 (Inkwell) has nullifier_secret = 500, nonce = current_turn_before = 1\n    let enc_null = p1_encrypt_nullifier(500, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 1,       // game ended, player 1 wins\n        enc_null,\n        1,\n        5,\n        2, 2,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_game_ends_draw() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    // Board where no captures happen on final move -> draw\n    let mut board_before2: [Field; 18] = [0; 18];\n    board_before2[0] = 1; board_before2[1] = 1;\n    board_before2[2] = 10; board_before2[3] = 2;\n    board_before2[4] = 2; board_before2[5] = 1;\n    board_before2[6] = 13; board_before2[7] = 2;\n    board_before2[8] = 3; board_before2[9] = 1;\n    board_before2[10] = 12; board_before2[11] = 2;\n    board_before2[12] = 4; board_before2[13] = 1;\n    board_before2[14] = 11; board_before2[15] = 2; // Freckles [2,6,1,6]\n    let scores_before2: [Field; 2] = [5, 5];\n    let current_turn_before2: Field = 1;\n    let start_hash2 = hash_board_state(board_before2, scores_before2, current_turn_before2);\n\n    let mut board_after2: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after2[i] = board_before2[i];\n    }\n    board_after2[16] = 5;  // Inkwell at (2,2)\n    board_after2[17] = 1;\n    // (1,2) card 12 Camo: placed top=2 vs adj bottom=3 -> NO\n    // (2,1) card 11 Freckles: placed left=5 vs adj right=6 -> NO\n    let scores_after2: [Field; 2] = [5, 5];\n    let end_hash2 = hash_board_state(board_after2, scores_after2, 2);\n\n    // Card 5 (Inkwell) has nullifier_secret = 500, nonce = current_turn_before2 = 1\n    let enc_null = p1_encrypt_nullifier(500, 1);\n\n    main(\n        cc1, cc2,\n        start_hash2, end_hash2,\n        1, 3,       // game ended, draw\n        enc_null,\n        1,\n        5,\n        2, 2,\n        board_before2, board_after2,\n        scores_before2, scores_after2,\n        current_turn_before2,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p2_wins() {\n    // P2 places the 9th card and wins with a higher score\n    // Board has 8 cards, it's P2's turn. P2 places card 14 (Glow Bug [5,3,3,4]) at (2,2)\n    // capturing (2,1) which has P1's card 5 (Inkwell [2,3,1,5]) - placed bottom=3 vs adj top=1 -> NO\n    // but (1,2) has P1's card 3 (BiteBug [1,3,3,5]) - placed left=4 vs adj right=3 -> 4>3 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    // Row 0: P1 card 1, P2 card 10, P1 card 2\n    board_before[0] = 1; board_before[1] = 1;    // (0,0) Mudwalker P1\n    board_before[2] = 10; board_before[3] = 2;   // (0,1) Peaches P2\n    board_before[4] = 2; board_before[5] = 1;    // (0,2) Blushy P1\n    // Row 1: P2 card 11, P2 card 12, P1 card 3\n    board_before[6] = 11; board_before[7] = 2;   // (1,0) Freckles P2\n    board_before[8] = 12; board_before[9] = 2;   // (1,1) Camo P2\n    board_before[10] = 3; board_before[11] = 1;  // (1,2) BiteBug P1\n    // Row 2: P2 card 13, P1 card 5, empty (2,2)\n    board_before[12] = 13; board_before[13] = 2; // (2,0) Neon P2\n    board_before[14] = 5; board_before[15] = 1;  // (2,1) Inkwell P1\n\n    // Scores: P1 has 4 on board + 1 in hand = 5, P2 has 4 on board + 1 in hand = 5\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2; // P2's turn\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    // P2 places card 14 (Glow Bug [5,3,3,4]) at (2,2)\n    board_after[16] = 14; board_after[17] = 2;\n\n    // Check captures:\n    // (1,2) BiteBug P1 [1,3,3,5]: placed top=5 vs adj bottom=3 -> 5>3 CAPTURE!\n    board_after[11] = 2; // BiteBug captured by P2\n    // (2,1) Inkwell P1 [2,3,1,5]: placed left=4 vs adj right=3 -> 4>3 CAPTURE!\n    board_after[15] = 2; // Inkwell captured by P2\n\n    // filled=9, p1_board=2, p2_board=7, p1_played=5, p2_played=4\n    // p1_score = 2 + (5-5) = 2, p2_score = 7 + (5-4) = 8\n    let scores_after: [Field; 2] = [2, 8];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 14 (Glow Bug) has nullifier_secret = 1000, nonce = current_turn_before = 2\n    let enc_null = p2_encrypt_nullifier(1000, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 2,       // game ended, player 2 wins\n        enc_null,\n        2,          // current_player = P2\n        14,         // card_id = Glow Bug\n        2, 2,       // row=2, col=2\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n// ====================== FAILURE TESTS ======================\n\n#[test(should_fail_with = \"Cell not empty\")]\nfn test_fail_place_on_occupied_cell() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 10;\n    board_before[1] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,       // (0,0) is occupied\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Not this player's turn\")]\nfn test_fail_wrong_player_turn() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1; // P1's turn\n\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 10;\n    board_after[1] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    let enc_null = p2_encrypt_nullifier(600, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,          // P2 trying to play on P1's turn\n        10,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Row out of bounds\")]\nfn test_fail_row_out_of_bounds() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n    let end_hash = start_hash;\n\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        3, 0,       // row=3 out of bounds\n        board_before, board_before,\n        scores_before, scores_before,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Placed card not in committed hand\")]\nfn test_fail_card_not_in_hand() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 20;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 20,      // card 20 not in P1's hand\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Player 1 card commit mismatch\")]\nfn test_fail_wrong_player_secret() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        999,        // WRONG player secret\n        P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Non-captured cell owner changed\")]\nfn test_fail_false_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 1;      // FALSE CAPTURE\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(300, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Captured cell owner not updated\")]\nfn test_fail_missing_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;      // NOT captured (WRONG!)\n    board_after[8] = 4; board_after[9] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(400, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 4,\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Non-placed cell card_id changed\")]\nfn test_fail_card_id_changed() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 99; board_after[3] = 2;      // card_id CHANGED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_player2_move_with_capture() {\n    // P2 places card 12 (Camo [7,1,3,1]) at (1,0)\n    // (0,0) has P1 card 1 (Mudwalker [1,4,1,5]).\n    // Placed top=7 vs adj bottom=1 -> 7>1 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 2;      // CAPTURED by P2\n    board_after[6] = 12; board_after[7] = 2;\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 12 (Camo) has nullifier_secret = 800\n    let enc_null = p2_encrypt_nullifier(800, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,\n        12,\n        1, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n#[test]\nfn test_equal_ranks_no_capture() {\n    // P1 card 1 Mudwalker right=4 at (0,0), (0,1) has P2 card 10 Peaches left=4.\n    // 4 == 4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 10; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;      // NOT captured (equal ranks)\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 1 (Mudwalker) has nullifier_secret = 100\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Encrypted nullifier mismatch\")]\nfn test_fail_wrong_encrypted_nullifier() {\n    // Correct move but wrong encrypted nullifier\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Use a wrong encrypted nullifier value\n    let wrong_enc_null: Field = 0xdeadbeef;\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        wrong_enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_ecdh_symmetric_encryption() {\n    // Verify that P1 encrypting with P2's pubkey produces something P2 can decrypt\n    // P1 encrypts: shared = P1_priv * P2_pub\n    // P2 decrypts: shared = P2_priv * P1_pub\n    // Both shared secrets should be equal (ECDH property)\n    let p1_pub = get_p1_pubkey();\n    let p2_pub = get_p2_pubkey();\n\n    let shared_1 = compute_shared_secret(P1_GRUMPKIN_KEY, p2_pub);\n    let shared_2 = compute_shared_secret(P2_GRUMPKIN_KEY, p1_pub);\n    assert(shared_1 == shared_2, \"ECDH shared secrets should match\");\n\n    // Encrypt and verify with nonce\n    let plaintext: Field = 12345;\n    let nonce: Field = 3; // example move index\n    let ciphertext = symmetric_encrypt_field(plaintext, shared_1, nonce);\n    // Decrypt: plaintext = ciphertext - key\n    let key = expand_secret(shared_2, nonce);\n    let decrypted = ciphertext - key;\n    assert(decrypted == plaintext, \"Decrypted value should match plaintext\");\n}\n\n// ====================== C1 FIX TESTS: Exact Score Verification ======================\n\n#[test(should_fail_with = \"P1 score mismatch\")]\nfn test_score_fabrication_rejected() {\n    // Valid first move (P1 places card 1 at (0,0) on empty board) but with fabricated scores.\n    // Correct scores: p1=5, p2=5 (1 on board + 4 in hand, 0 on board + 5 in hand)\n    // Fabricated: p1=8, p2=2 (would pass the old weak check since 8+2=10, 8>=1, 2>=0)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    // Fabricated scores: should be [5, 5] but attacker claims [8, 2]\n    let scores_after: [Field; 2] = [8, 2];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_exact_scores_after_capture() {\n    // P2 places card 13 (Neon [6,2,2,3]) at (0,1).\n    // (0,0) has P1 card 5 (Inkwell [2,3,1,5]). Placed left=3 vs adj right=3 -> NO (equal)\n    // (1,1) has P1 card 1 (Mudwalker [1,4,1,5]). Placed bottom=2 vs adj top=1 -> 2>1 CAPTURE!\n    // After: filled=4, p1_board=1, p2_board=3(card 10 + card 13 + captured card 1)\n    // p1_played=(4+1)/2=2, p2_played=4/2=2\n    // p1_score=1+(5-2)=4, p2_score=3+(5-2)=6\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 5; board_before[1] = 1;    // (0,0) Inkwell P1\n    board_before[4] = 10; board_before[5] = 2;   // (0,2) Peaches P2\n    board_before[8] = 1; board_before[9] = 1;    // (1,1) Mudwalker P1\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 5; board_after[1] = 1;      // (0,0) Inkwell P1 - unchanged\n    board_after[2] = 13; board_after[3] = 2;     // (0,1) Neon P2 - placed\n    board_after[4] = 10; board_after[5] = 2;     // (0,2) Peaches P2 - unchanged\n    board_after[8] = 1; board_after[9] = 2;      // (1,1) Mudwalker CAPTURED by P2\n    // Exact scores: p1_board=1, p2_board=3, p1_hand=3, p2_hand=3\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 13 (Neon) has nullifier_secret = 900\n    let enc_null = p2_encrypt_nullifier(900, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,\n        13,\n        0, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n// ====================== C2 FIX TESTS: Card Replay Prevention ======================\n\n#[test(should_fail_with = \"Card already placed on board\")]\nfn test_card_replay_rejected() {\n    // P1 already has card 1 (Mudwalker) on board at (0,0).\n    // P1 tries to place card 1 AGAIN at (1,1). Should be rejected.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;\n    board_after[8] = 1; board_after[9] = 1;    // (1,1) card 1 REPLAYED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,          // card_id = 1 (already on board!)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_different_card_after_same_id_on_board() {\n    // P1 has card 1 on board. P1 places card 2 (different card). Should succeed.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 1;   // (0,1) CAPTURED: Blushy top=5 > Peaches bottom=2\n    board_after[8] = 2; board_after[9] = 1;    // (1,1) card 2, different card\n    // filled=3, p1_board=3, p2_board=0, p1_played=2, p2_played=1\n    // p1_score=3+3=6, p2_score=0+4=4\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 2 (Blushy) has nullifier_secret = 200\n    let enc_null = p1_encrypt_nullifier(200, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 2,          // card_id = 2 (different, valid)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n","path":"/home/ec2-user/aztec-triple-triad/circuits/game_move/src/main.nr"}}}