{"noir_version":"1.0.0-beta.18+2db78f8894936db05c53430f364360ac9cc5c61f","hash":"2931878935822136390","abi":{"parameters":[{"name":"card_commit_1","type":{"kind":"field"},"visibility":"public"},{"name":"card_commit_2","type":{"kind":"field"},"visibility":"public"},{"name":"start_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"end_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"game_ended","type":{"kind":"field"},"visibility":"public"},{"name":"winner_id","type":{"kind":"field"},"visibility":"public"},{"name":"encrypted_card_nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"current_player","type":{"kind":"field"},"visibility":"private"},{"name":"card_id","type":{"kind":"field"},"visibility":"private"},{"name":"row","type":{"kind":"field"},"visibility":"private"},{"name":"col","type":{"kind":"field"},"visibility":"private"},{"name":"board_before","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"board_after","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_before","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_after","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"current_turn_before","type":{"kind":"field"},"visibility":"private"},{"name":"player_secret","type":{"kind":"field"},"visibility":"private"},{"name":"player_address","type":{"kind":"field"},"visibility":"private"},{"name":"game_id","type":{"kind":"field"},"visibility":"private"},{"name":"player_card_ids","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"player_card_ranks","type":{"kind":"array","length":5,"type":{"kind":"array","length":4,"type":{"kind":"field"}}},"visibility":"private"},{"name":"player_nullifier_secrets","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"grumpkin_private_key","type":{"kind":"field"},"visibility":"private"},{"name":"opponent_pubkey_x","type":{"kind":"field"},"visibility":"private"},{"name":"opponent_pubkey_y","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"4286976953368078457":{"error_kind":"string","string":"Encrypted nullifier mismatch"},"4487758756370642245":{"error_kind":"string","string":"Start state hash mismatch"},"5077336431726014007":{"error_kind":"string","string":"Placed card ranks do not match database"},"5101543514421470893":{"error_kind":"string","string":"Card already placed on board"},"6511982886681245134":{"error_kind":"string","string":"Placed card not in committed hand"},"7317384265632011736":{"error_kind":"string","string":"Cell not empty (owner)"},"7370811245087594529":{"error_kind":"string","string":"Captured cell owner not updated"},"7520349170859696597":{"error_kind":"string","string":"Card not placed correctly"},"8084300406162371689":{"error_kind":"string","string":"Player 2 card commit mismatch"},"8749084135167576643":{"error_kind":"string","string":"Invalid player"},"9296992678443765102":{"error_kind":"string","string":"Non-placed cell card_id changed"},"9336663072722308931":{"error_kind":"string","string":"Owner not set correctly"},"9573161043312537276":{"error_kind":"string","string":"Should be a draw"},"9697039476693520435":{"error_kind":"string","string":"Player 2 should be winner"},"9715689440484907290":{"error_kind":"string","string":"Game should have ended"},"9915128275385804551":{"error_kind":"string","string":"Player 1 should be winner"},"11936972275297119974":{"error_kind":"string","string":"Invalid card ID for rank lookup"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12724384224350165649":{"error_kind":"string","string":"End state hash mismatch"},"14336771847768869760":{"error_kind":"string","string":"Not this player's turn"},"14904510168980638594":{"error_kind":"string","string":"Cell not empty"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15156018542597224275":{"error_kind":"string","string":"Player 1 card commit mismatch"},"15353634778740263988":{"error_kind":"string","string":"Game should not have ended"},"15521846062275453407":{"error_kind":"string","string":"Col out of bounds"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16309609255298369368":{"error_kind":"string","string":"Row out of bounds"},"16422110396685134300":{"error_kind":"string","string":"P1 score mismatch"},"17174323770794875209":{"error_kind":"string","string":"Non-captured cell owner changed"},"18125798406593280834":{"error_kind":"string","string":"No winner yet"},"18256603403857491958":{"error_kind":"string","string":"P2 score mismatch"}}},"bytecode":"H4sIAAAAAAAA/8ydBXQUy/b1yUyUGK4XCO7u7u7uEoJLggTX4E46weXiEIK7u0NCsODu7hI0XzV8l2mg/szumjov/dZbd9WqdajeVfWrc2rPdBJzkDJ9cVfvjr7hcWpcjTcjILR6265+PfpV9u3oHxzraqx4rm7uHp5x4saLnyBhosRJkiZL/s/SHxG/RNqxyBQpU3mlTpM2XfoMGTNlzpI1W/Yc/0WuKNOjY5cuHduX9e7SZYpJCVhat6Nv+y5tgwOVoINesf7+Pzung1652tTocSv3/Mxba5XfHBDQqHmmvA8r9dvWTSl7613wSxbzfcSu3bq0bRQcGGh9xIDQ0j17tu3h36RtD79gJRiQ0CgoyLqKRsBkGlsfRr+6xgqgrrHVgWKR7tOL6Ojon/vUhGifmljbJ1VFE2AyTSn2qakCqGsK7NPvT7a6902DEDYJ1iUQebATgG9evfiag/Th6wI84OeAf4fXTv1P0H+sN/uv0RyDfm2ZLt4+ncv49a3Qy9dHnUrAkjqla1QsHxSwrGFHf9+2PXs2C7sORDX3+nUngpFF+PtOBLGdsGsG7FZznRAHIvkVeXCLHw/+WxiwdC3YAv81F1qVal3Gz1zYUiwXWpXQ8r+j97fIlgAUrQRyoVV1rRRAXSuBXGhtNs1bWUtJniwLtwI22RtQZ501by/b8lZsqrzV+r+Gj6y81RrKWz4CeSs2kLdaA1vqQ5G3kAe3kZK32tiat1rryFttafJW67ZI3moLQNGOIG+1bofkrXYEecunHZK32gGb3F5K3mpvY96yckVgc/kqlrc6/NfoKCtvdRTISM2BjNQB2KyOwDL9Ig455h2oL9M+VJvb6b9GZ1mb21lgc32Aze0E7ENnis3tpHdzY+k0+vmsP+DnfnX5r9FVf7WAtiIfsCJd/oxp9luMXVfqj0e6/qnhQ8TMyBmjT7Ufr6y55jt42eKfpdWX5uORrr6c68ofKnyByfgRfDzS1U8B1PnZSvfvur3Mw1LGK10qKqLnku4tBi9bwnnA7//kJ93d/mt0l5WNuoUNBaK6s6g/TorViQEnpRtwUrpbX6Bfd8Au6K+5/vfx9R2rbtZ5+HmsesjapR521peft7S/P+r3Z/cAxulpdQWR21tPhKDfx+0OxCBT8AcIsj4FfzaF/+ukBwH5xq8LcN/36wrmdishlorY679Gb1k09oJyRu/fdhxZoi5+wBJ19UPqdFeAi15A9umtN/+TZp9eOrJPH1n73Ucg+/QCsk8fYJy+UrJPX5Hs0xuIQabQT0r26fd79rELkl646FjsL4vF/r+xOAWZuSRe+wPjDAAuqtZnOeB3XpFpdpfENDLNgVI+0hn4l4oKIZhfRx0c9F9jMJEzzA+s2yCg4gymdoaDdTjDITTOcPAQxBkOASYTNpTAGg4OG4p4Q/XZVoay0RzynvB/usOwgJ+tYbLybVgAdNkLGybiEMOGAkcmLAA4M2HDDGUSwwJ01Maw4dI2a7jATe37+v7+sN+fHjYcGWmElMta2AiR21rYMCQImsZIKRe2sJE2+sWwoYMANxQ2dDCY862EWCpl2KifrdHS0ByF5ZHRAq5xUNhQYKFYTkeq+GCEkFFIShptKOcYNkpPShojbd/HiKSkUUhKGoOMNFZOShorlJJGI0HQNMbJSUnjbDWRSGGj5HK8NC7HCxhJ3lVEEN7xyEgTpJjJsAkibhKrpxDh0FwnSnGUYRNttZQF9BTKST9bk4lMZQFk7SYh5Wgyta1UnwD7yrBAGmMZNjksELGWLAoYTCHwlkyhAplLhdxcKnrMpaUVLC0JB2GXwmAhc4m8uxAWhBydYGOZyyA9FXOKtM2aInKTC0KK4RRkpKlybnJThW5yUBA0jWlybnLTbDWXStgkxF0qYZPR3G8lRlM2p/9szZBG53QslcwQ8Jdhk8KQVzXVxB4MrRXCyXQkMc0wlsWcricxzZS29TNFEtN0JDHNREaaJScxzRJKTDOQIGgas+Ukptk2W0ygvFFyOUcal3NELGaQNHjnICPNlWMx5wpZTHmEQ3P9V47F/NdWi1lQT62c97M1n8hiFkTWbh5SjuaTW8z5eizmAiKLOT9sAWQxFyAzWkhhMeeHLYQs5kJyi7lQj8Vc9LO1WFoSXoTdCxcLWcyFyNFZhBydxcaymIv0VMwl0jZrichNbhFSDJcgIy2Vc5NbKnSTW4wEQdNYJucmt8xWi7kwbB5imxaGzUdzv5UYTdkM+dlaLo3OECyVLBexmPPCFiJrxRI7ZDHnI5yEIIlpubEsZoiexBQqbetDRRJTCJKYQpGRVshJTCuEEtNyJAiaxko5iWmlzRYTKG+UXK6SxuUqEYu5SBq8q5CRVsuxmKuFLOZiaYRDc10jx2KusdViFtJTK9f+bK0jspiFkLVbi5SjdeQWc50ei7meyGKuC1sPWcz1yIw2UFjMdWEbIIu5gdxibtBjMTf+bG2SloQ3YvfCTUIWcwNydDYiR2eTsSzmRj0Vc7O0zdoscpPbiBTDzchIW+Tc5LYI3eQ2IUHQNLbKuclttdVibghbi9imDWHr0NxvJUZTNrf9bG2XRuc2LJVsF7GYa8M2IGvFEjtkMdchnGxDEtN2Y1nMbXoS0w5pW79DJDFtQxLTDmSknXIS006hxLQdCYKmsUtOYtpls8UEyhsll7ulcblbxGJulAbvbmSkPXIs5h4hi7lJGuHQXPfKsZh7bbWYhfXUyn0/W/uJLGZhZO32IeVoP7nF3K/HYh4gspj7ww5AFvMAMqODFBZzf9hByGIeJLeYB/VYzEM/W4elJeFD2L3wsJDFPIgcnUPI0TlsLIt5SE/FPCJts46I3OQOIcXwCDLSUTk3uaNCN7nDSBA0jWNybnLHbLWYB8P2IbbpYNh+NPdbidGUzeM/Wyek0XkcSyUnRCzmvrCDyFqxxA5ZzP0IJ8eRxHTCWBbzuJ7EFCZt68NEEtNxJDGFISOFy0lM4UKJ6QQSBE3jpJzEdNJmiwmUN0ouI6RxGSFiMQ9JgzcCGemUHIt5SshiHpZGODTX03Is5mlbLWYRPbXyzM/WWSKLWQRZuzNIOTpLbjHP6rGY54gs5tmwc5DFPIfMKJLCYp4Ni4QsZiS5xYzUYzHP/2xdkJaEz2P3wgtCFjMSOTrnkaNzwVgW87yeinlR2mZdFLnJnUeK4UVkpEtybnKXhG5yF5AgaBqX5dzkLttqMSPDziC2KTLsLJr7rcRoyuaVn62r0ui8gqWSqyIW80xYJLJWLLFDFvMswskVJDFdNZbFvKInMV2TtvXXRBLTFSQxXUNGui4nMV0XSkxXkSBoGjfkJKYbNltMoLxRcnlTGpc3RSzmeWnw3kRGuiXHYt4SspgXpBEOzfW2HIt521aLWVRPrbzzs3WXyGIWRdbuDlKO7pJbzLt6LOY9Iot5N+weZDHvITO6T2Ex74bdhyzmfXKLeV+PxXzws/VQWhJ+gN0LHwpZzPvI0XmAHJ2HxrKYD/RUzEfSNuuRyE3uAVIMHyEjPZZzk3ssdJN7iARB03gi5yb3xFaLeT/sDmKb7ofdRXO/lRhN2Xz6s/VMGp1PsVTyTMRi3gm7j6wVS+yQxbyLcPIUSUzPjGUxn+pJTM+lbf1zkcT0FElMz5GRXshJTC+EEtMzJAiaxks5iemlzRYTKG+UXL6SxuUrEYv5QBq8r5CRXsuxmK+FLOZDaYRDc30jx2K+sdViFtNTK9/+bL0jspjFkLV7i5Sjd+QW850ei/meyGK+C3sPWcz3yIw+UFjMd2EfIIv5gdxiftBjMaN+tj5KS8JR2L3wo5DF/IAcnSjk6Hw0lsWM0lMxP0nbrE8iN7kopBh+Qkb6LOcm91noJvcRCYKm8UXOTe6LrRbzQ9hbxDZ9CHuH5n4rMZqy+fVn65s0Or9iqeSbiMV8G/YBWSuW2CGL+Q7h5CuSmL4Zy2J+1ZOYoqVtfbRIYvqKJKZoYKRwu1hSMhMbRyg1fUOCsInYSclNbBybbSZQ4gjZDLczyYKTDSViNKNkIcyeD229WYrVZOMIec2PskBHp2svxW2ycWy1m8V11M1wOwdL05HIcBaH1s8BqE5MI7Xl/P4I2HOG2znRmE4mg42N2E41DBnPmcB4flfprEAqnam9J/cR/6f5DLdzsTRjy8vNLtClkT1SxICyKUJnyQU6S7EN5UGZal311FXenrkK3PZ+LPLvj/v9+WxsaCw3Sfc9N5H7HiMBisKm4i7pxuduox1lZ4UVlWBEMgt0hGuDlSBtbfWwND3l0eoBZhhPAV/KVowtB7RoauYPxhYN4sYDylmehrKnTLWunBVHHgVxhHKWB5Sz4kBjxZWUs+KK5SxPKAqbSjxJOSuerS4VKoK0jMaXx2h8AZ/KvbwIkxwfGiuBJKeaQMSpotUX4x2bcEJJXjWhrV61hK56msjSTEzkVUtA65cIqlWJ6b1qYl1eNQmVV03Mxsa8ahJoWklJvCpTmRTzqknpvWpSXV41maWZXF5+TgbeJJOLedWk0FlKBp2l5Abzqsl01dR/5O3ZP0L3vmRQtfwHGiuFpHtfCrF7X3IoCptKSkn3vpQ2e9WkrKhAtosFJoZrg5UgbW1NZWl6yaM1FZhhvIS8aiK2HNCiqZkf86qJIW5SQTnLy2BeNZWunJVaHgWphXJWKihnpYbGSiMpZ6URy1leUBQ2lbSSclZa270qUARpGU0nj9F0Ql41mUSS00FjpZfkVdOLedXkEnnHJpxBklfNYKtXLamrnma0NDMRedWS0PplhGpVJnqvmkmXV81M5VUzsbExr5oZmlYWEq/KVGbBvGoWeq+aRZdXzWppZpOXn7OCN8lsYl41C3SWskJnKZvBvGpWXTU1u7w9yy5078sKVcvs0Fg5JN37cojd+7JBUdhUckq69+W02atmYUUFsl0sMBNcG6wEaWtrLksztzxac4EZJreQV83IlgNaNDXzY141E8RNLihn5TaYV82lK2flkUdBHqGclQvKWXmgsfJKyll5xXJWbigKm0o+STkrn+1eFSiCtIzml8dofiGvmlUiyfmhsQpI8qoFxLxqNom8YxMuKMmrFrTVq5bSVU8LWZqFibxqKWj9CkG1qrDeWqXfqxbW5VWLUHnVwmxszKsWgaZVlMSrMpVFMa9aVO/O6feqRXV51WKWZnF5+bkYeJMsLuZVi0JnqRh0loobzKsW01VTS8jbsxJC975iULXEXiopKeneV1Ls3of9lAY2lVKS7n2lbPaqRVlRgWwXCywM1wYrQdraWtrSLCOP1tJghikj5FULseWAFk3N/JhXLQxxUxrKWWUM5lVL68pZZeVRUFYoZ5WGclZZaKxyknJWObGcVQaKwqZSXlLOKm+7VwWKIC2jFeQxWkHIqxaTSHIFaKyKkrxqRTGvWlwi79iEK0nyqpVs9aqlddXTypZmFSKvWhpav8pQrapC71Wr6PKqVam8ahU2NuZVq0LTqkbiVZnKaphXrUbvVavp8qrVLc0a8vJzdfAmWUPMq1aDzlJ16CzVMJhXra6rptaUt2c1he591aFqWRMaq5ake18tsXtfDSgKm0ptSfe+2jZ71WqsqEC2iwVWgWuDlSBtba1jadaVR2sdMMPUFfKqldlyQIumZn7Mq1aBuKkD5ay6BvOqdXTlrHryKKgnlLPqQDmrHjRWfUk5q75YzqoLRWFTaSApZzWw3asCRZCW0YbyGG0o5FWrSyS5ITRWI0letZGYV60hkXdswo0ledXGtnrVMrrqaRNLsymRV8U+EWgC1aqm9F61qS6v2ozKqzZlY2NetRk0reYkXpWpbI551eb0XrW5Lq/awtJsKS8/twBvki3FvGpz6Cy1gM5SS4N51Ra6amoreXvWSuje1wKqlq2gsbwl3fu8xe59LaEobCqtJd37WtvsVZuzogLZLhbYFK4NVoK0tdXH0mwjj1YfMMO0EfKqTdhyQIumZn7MqzaFuPGBclYbg3lVH105q608CtoK5SwfKGe1hcZqJylntRPLWW2gKGwq7SXlrPa2e1WgCNIy2kEeox2EvGoLiSR3gMbqKMmrdhTzqi0l8o5NuJMkr9rJVq9aVlc97WxpdiHyqth7GJ2hWtWF3qt20eVVu1J51S5sbMyrdoWm5UviVZlKX8yr+tJ7VV9dXtXP0uwmLz/7gTfJbmJe1Rc6S37QWepmMK/qp6umdpe3Z92F7n1+ULXsDo3VQ9K9r4fYva8bFIVNpaeke19Pm72qLysqkO1igV3g2mAlSFtb/S3NXvJo9QczTC8hr9qZLQe0aGrmx7xqF4gbfyhn9TKYV/XXlbN6y6Ogt1DO8odyVm9orD6SclYfsZzVC4rCptJXUs7qa7tXBYogLaP95DHaT8ir+kkkuR80Vn9JXrW/mFftJpF3bMIDJHnVAbZ61XK66ulAS3MQkVctB63fQKhWDaL3qoN0edXBVF51EBsb86qDoWkNIfGqTOUQzKsOofeqQ3R51aGWZoC8/DwUvEkGiHnVIdBZGgqdpQCDedWhumrqMHl7Nkzo3jcUqpbDoLGGS7r3DRe79wVAUdhURki6942w2asOYUUFsl0scBBcG6wEaWvrSEtzlDxaR4IZZpSQVx3IlgNaNDXzY151EMTNSChnjTKYVx2pK2eNlkfBaKGcNRLKWaOhscZIylljxHLWKCgKm8pYSTlrrO1eFSiCtIyOk8foOCGvOlQiyeOgscZL8qrjxbxqgETesQlPkORVJ9jqVcvrqqcTLc1JRF61PLR+E6FaNYneq07S5VUnU3nVSWxszKtOhqYVSOJVmcpAzKsG6t05/V41UJdX1WxikLz8rIA3ySAxrxoInSUFOktBBvOqiq6aGixvz4KF7n0KVC2xsaZIuvdNEbv3BUFR2FhTJd37ptrsVQNZUYFsFwucBNcGK0Ha2jrN0pwuj9ZpYIaZLuRVJ7LlgBZNzfyYV50EcTMNylnTDeZVp+nKWTPkUTBDKGdNg3LWDGismZJy1kyxnDUdisKmMktSzpplu1cFiiAto7PlMTpbyKsqEkmeDY01R5JXnSPmVYMk8o5NeK4krzrXVq9aQVc9/dfSnEfkVbHfTfUvVKvm0XvVebq86nwqrzqPjY151fnQtBaQeFWmcgHmVRfQe9UFurzqQktzkbz8vBC8SS4S86oLoLO0EDpLiwzmVRfqqqmL5e3ZYqF730KoWi6Gxloi6d63ROzetwiKwqayVNK9b6nNXnUBKyqQ7WKB8+DaYCVIW1uXWZoh8mhdBmaYECGv+i9bDmjR1MyPedV5EDfLoJwVYjCvukxXzlouj4LlQjlrGZSzlkNjhUrKWaFiOSsEisKmskJSzlphu1cFiiAtoyvlMbpSyKsulEjySmisVZK86ioxr7pIIu/YhFdL8qqrbfWqFXXV0zWW5loir1oRWr81UK1aS+9V1+ryquuovOpaNjbmVddB01pP4lWZyvWYV11P71XX6/KqGyzNjfLy8wbwJrlRzKuuh87SBugsbTSYV92gq6Zukrdnm4TufRugarkJGmuzpHvfZrF730YoCpvKFkn3vi02e9X1rKhAtosFroVrg5UgbW3damluk0frVjDDbBPyqmvYckCLpmZ+zKuuhbjZCuWsbQbzqlt15azt8ijYLpSztkI5azs01g5JOWuHWM7aBkVhU9kpKWfttN2rAkWQltFd8hjdJeRVN0gkeRc01m5JXnW3mFfdKJF3bMJ7JHnVPbZ61Uq66uleS3MfkVetBK3fXqhW7aP3qvt0edX9VF51Hxsb86r7oWkdIPGqTOUBzKseoPeqB3R51YOW5iF5+fkgeJM8JOZVD0Bn6SB0lg4ZzKse1FVTD8vbs8NC976DULU8DI11RNK974jYve8QFIVN5aike99Rm73qAVZUINvFAvfBtcFKkLa2HrM0j8uj9RiYYY4LedW9bDmgRVMzP+ZV90HcHINy1nGDedVjunLWCXkUnBDKWcegnHUCGitMUs4KE8tZx6EobCrhknJWuO1eFSiCtIyelMfoSSGvelAiySehsSIkedUIMa96SCLv2IRPSfKqp2z1qpV11dPTluYZIq9aGVq/01CtOkPvVc/o8qpnqbzqGTY25lXPQtM6R+JVmcpzmFc9R+9Vz+nyqpGW5nl5+TkSvEmeF/Oq56CzFAmdpfMG86qRumrqBXl7dkHo3hcJVcsL0FgXJd37Lord+85DUdhULkm6912y2aueY0UFsl0s8AxcG6wEaWvrZUvzijxaL4MZ5oqQVz3NlgNaNDXzY171DMTNZShnXTGYV72sK2ddlUfBVaGcdRnKWVehsa5JylnXxHLWFSgKm8p1STnruu1eFSiCtIzekMfoDSGvGimR5BvQWDcledWbYl71vETesQnfkuRVb9nqVfX9vfLbluYdIq+K/S3w21CtukPvVe/o8qp3qbzqHTY25lXvQtO6R+JVmcp7mFe9R+9V7+nyqvctzQfy8vN98Cb5QMyr3oPO0n3oLD0wmFe9r6umPpS3Zw+F7n33oWr5EBrrkaR73yOxe98DKAqbymNJ977HNnvVe6yoQLaLBd6Ba4OVIG1tfWJpPpVH6xMwwzwV8qq32XJAi6Zmfsyr3oG4eQLlrKcG86pPdOWsZ/IoeCaUs55AOesZNNZzSTnruVjOegpFYVN5ISlnvbDdqwJFkJbRl/IYfSnkVe9LJPklNNYrSV71lZhXfSCRd2zCryV51de2etWquurpG0vzLZFXrQqt3xuoVr2l96pvdXnVd1Re9S0bG/Oq76BpvSfxqkzle8yrvqf3qu91edUPlmaUvPz8AbxJRol51ffQWfoAnaUog3nVD7pq6kd5e/ZR6N73AaqWH6GxPkm6930Su/dFQVHYVD5Luvd9ttmrvmdFBbJdLPAtXBusBGlr6xdL86s8Wr+AGearkFd9w5YDWjQ182Ne9S3EzRcoZ301mFf9oitnfZNHwTehnPUFylnfoLGiJeWsaLGc9RWKgqZiiiUnZ5li2e5VgSJIyqjJThqjJjshr/pBHskmO2j7TXK8qskk5lWj5PEOTtgsx6uazLZ61Wp66qnJ3tJ0IPKq1aD1s0dqlcmB3Kuqj8C9qsmRyKuaHNjYkFdlYch4ThReVVXpBHlV9flWhrPVq/Ie8X97VZOzpekiLz87YzdJk4uQVzU5QWfJGTpLLsbyqiZnXTU1trw9iy1y7/u+yL8/7vfns7GhsVzl3PtMrkL3PpMLFIVNxU3Svc/NVq9qcmJFBbFdaqADXBusBGlrq7ul6SGPVncww3iIeFWTPVsOaNHUzB+MLRrEjTuUszyM5VVN7rpylqc8CjyFcpY7lLM8obHiSMpZccRylgcUhU0lrqScFddmr4oUQVpG48ljNJ6IV+VdXoRJjgeNFV+SV40v5FXB6ovxjk04gSSvmsBWr1pdVz1NaGkmIvKq1aH1SwjVqkT0XjWRLq+amMqrJmJjY141MTStJCRelalMgnnVJPReNYkur5rU0kwmLz8nBW+SycS8ahLoLCWFzlIyg3nVpLpqanJ5e5Zc6N6XFKqWyaGx/pF07/tH7N6XDIrCppJC0r0vhc1eNQkrKpDtYoGJ4NpgJUhbW1Namqnk0ZoSzDCphLxqQrYc0KKpmR/zqokgblJCOSuVwbxqSl05y0seBV5COSsllLO8oLFSS8pZqcVyViooCptKGkk5K43tXhUogrSMppXHaFohr5pUIslpobHSSfKq6cS8ajKJvGMTTi/Jq6a31avW0FVPM1iaGYm8ag1o/TJAtSojvVfNqMurZqLyqhnZ2JhXzQRNKzOJV2UqM2NeNTO9V82sy6tmsTSzysvPWcCbZFYxr5oZOktZoLOU1WBeNYuumppN3p5lE7r3ZYGqZTZorOyS7n3Zxe59WaEobCo5JN37ctjsVTOzogLZLhaYEa4NVoK0tTWnpZlLHq05wQyTS8irZmDLAS2amvkxr5oR4iYnlLNyGcyr5tSVs3LLoyC3UM7KCeWs3NBYeSTlrDxiOSsXFIVNJa+knJXXdq8KFEFaRvPJYzSfkFfNIpHkfNBY+SV51fxiXjWrRN6xCReQ5FUL2OpVa+qqpwUtzUJEXrUmtH4FoVpViN6rFtLlVQtTedVCbGzMqxaGplWExKsylUUwr1qE3qsW0eVVi1qaxeTl56LgTbKYmFctAp2lotBZKmYwr1pUV00tLm/Pigvd+4pC1bI4NFYJSfe+EmL3vmJQFDaVkpLufSVt9qpFWFGBbBcLLATXBitB2tpaytIsLY/WUmCGKS3kVQuy5YAWTc38mFctBHFTCspZpQ3mVUvpylll5FFQRihnlYJyVhlorLKSclZZsZxVGorCplJOUs4qZ7tXBYogLaPl5TFaXsirFpVIcnlorAqSvGoFMa9aTCLv2IQrSvKqFW31qrV01dNKlmZlIq9aC1q/SlCtqqy3Vun3qpV1edUqVF61Mhsb86pVoGlVJfGqTGVVzKtW1btz+r1qVV1etZqlWV1efq4G3iSri3lV6PeUmapBZ6m6wbxqNV01tYa8PashdO+rBlVL7KWSmpLufTXF7n3YT2lgU6kl6d5Xy2avWpUVFch2scDKcG2wEqStrbUtzTryaK0NZpg6Ql61ElsOaNHUzI95Vehv1plqQzmrjsG8am1dOauuPArqCuWs2lDOqguNVU9SzqonlrPqQFHYVOpLyln1bfeqQBGkZbSBPEYbCHnVahJJbgCN1VCSV20o5lWrS+Qdm3AjSV61ka1etbauetrY0mxC5FVrQ+vXGKpVTei9ahNdXrUplVdtwsbGvGpTaFrNSLwqU9kM86rN6L1qM11etbml2UJefm4O3iRbiHnVZtBZag6dpRYG86rNddXUlvL2rKXQva85VC1bQmO1knTvayV272sBRWFT8ZZ07/O22as2Y0UFsl0ssAlcG6wEaWtra0vTRx6trcEM4yPkVRuz5YAWTc38mFdtAnHTGspZPgbzqq115aw28ihoI5SzWkM5qw00VltJOautWM7ygaKwqbSTlLPa2e5VgSJIy2h7eYy2F/KqzSWS3B4aq4Mkr9pBzKu2kMg7NuGOkrxqR1u9ah1d9bSTpdmZyKtinwh0gmpVZ3qv2lmXV+1C5VU7s7Exr9oFmlZXEq/KVHbFvGpXeq/aVZdX9bU0/eTlZ1/wJukn5lW7QmfJFzpLfgbzqr66amo3eXvWTeje5wtVy27QWN0l3fu6i937/KAobCo9JN37etjsVbuyogLZLhbYGa4NVoK0tbWnpekvj9aeYIbxF/KqndhyQIumZn7Mq3aGuOkJ5Sx/g3nVnrpyVi95FPQSylk9oZzVCxqrt6Sc1VssZ/lDUdhU+kjKWX1s96pAEaRltK88RvsKeVVfiST3hcbqJ8mr9hPzqn4Seccm3F+SV+1vq1etq6ueDrA0BxJ5Vew9jAFQrRpI71UH6vKqg6i86kA2NuZVB0HTGkziVZnKwZhXHUzvVQfr8qpDLM2h8vLzEPAmOVTMqw6GztIQ6CwNNZhXHaKrpgbI27MAoXvfEKhaBkBjDZN07xsmdu8bCkVhUxku6d433GavOpgVFch2scCBcG2wEqStrSMszZHyaB0BZpiRQl51AFsOaNHUzI951YEQNyOgnDXSYF51hK6cNUoeBaOEctYIKGeNgsYaLSlnjRbLWSOhKGwqYyTlrDG2e1WgCNIyOlYeo2OFvOoQiSSPhcYaJ8mrjhPzqkMl8o5NeLwkrzreVq9aT1c9nWBpTiTyqvWg9ZsA1aqJ9F51oi6vOonKq05kY2NedRI0rckkXpWpnIx51cn0XnWyLq8aaGkq8vJzIHiTVMS86mToLAVCZ0kxmFcN1FVTg+TtWZDQvS8QqpZB0FjBku59wWL3PgWKwqYyRdK9b4rNXnUyKyqQ7WKBE+HaYCVIW1unWprT5NE6Fcww04S86gS2HNCiqZkf86oTIW6mQjlrmsG86lRdOWu6PAqmC+WsqVDOmg6NNUNSzpohlrOmQVHYVGZKylkzbfeqQBGkZXSWPEZnCXnVQIkkz4LGmi3Jq84W86qKRN6xCc+R5FXncEvR6uq9uvh3rOvj3cW7B2tOuRqrXUBIWT/fnv7evv4HvZxL9It7Mb9L78wvHXvl/pLw+Nd+IbOfnygcWLJjw2w+flWaaGOTDWnxadWQ3M3SL0/yxu3ohbwlw1b0v3DMM8H1gJ2HMn0Mbq6NtTojTaxDlZBOPU+My1enRdPd5+8WXZB00ijPloVrZZjc/UZ5ZdddkzbWa27EnmyfG358b+9X7kKyw5+ietRbc6TUQPsnrZO1Hn18XwZRDf+Ue73Ea2DA/nHDUy8JaPZwXe446XY8i58k6Y7L7xauCqlYSRtrDn1e4H6ZLCnsFJ8shxvPevRkycpsiUOOeYUWWzN+7KGoEFENGS6uS+TWIfUit7bvT1SMV+Wb3f55ZQu9rV4l3rEvEWk++63/Zc2OuBWd455+8b5YdxYOeBNWsOW4qPBLlScddJ41rLh/m+PRohq8ns3plCJjxn/Kzdhz0qFv5Nx1q3aHjs734VOYy4DZM2tG+GpjM4cPKuhSaEOjw9mqxPpQxD3OimX3QudXtJ/fveTYlLu3pe0uqsGULmTF4aNbI809z1c7s2BFwvZ7CmYtmmrAqBRD7NJ3q3N2uDY2baPWswMff848t12tRXEfzEywNnWLtcsCA1wzXG4yrH2GC3FFNXjG8etaYWdglTqB9dIFrn9dqE/LNwfLr4/6YH+wXduWFWJn+WUdVow41+PV2ZJlvrkcHDC5T5yXSb3OJ6xTK1773HdHjR4QkVF4HWa8vpum8svac8aN26U0GLzbzreSZ+rZE5JWSNGpcbMDBab9wmTTp1VHei1+entAZOin3Xdu3Crs7l/4YNKQQ01OrncKPVpUVEO2aZkqzr2bJOWywQNc4oe9TZHFP2HTFHOGPV7otT9J31R+v4ybcfKorV+n1nFtvrDo82Qt8lc/dHXtibLnt/i2nnglep3dhd6iGlxvKX6FcuTPE1p3Wbtv/uuWD+9bLXSbKXD1sj3enQ90/1z6l31rW6+Ww8Npr8pUnupT7tPHVdd6Z+3Vc/HoTZOHNimQIii2l6iGzNEjCq5u+nTsjASl1+cqsDDrkMjdj168fFjMPXLrgM9Nz3toY1OdqZg/a5/b7TunuZI2YuC5YRVr1iuRb+imRXPKRBVe5Lg7jqiGnEXPPZo8YUSj8EZjRld++e7esMX52/buOePmpFqPqs5OuvjSLxrqVnY8HTq+6rIql+5ENbkTlblF7cdrTjdtHreD3TafVl5NRTVk7BU44236LW0q7j+UMVPDDuYFK5vfGbB9dJODA69G1521Lbc2Nvbiwferx7vYIGJr8sbNUrQ6+XRz8Muvq9tUrBCdt0Th9ym2iGqwaxZyflSirw+7KM53rti/G3PzjfN99wKDpxUdVMHz0dIWXX7h92OSWHMvT8lyLHKmOTy7acrFnpODx8efkth9bBbTIM98A0Q1uCceHrm+Qe/6Cd8cmzHx46vtg/1ark03YWz3z4fM0ZFJ+iTQxubYUbbm25FDDrROVfTA4a2xsiY+lX2OV41er2ZPdp35uEOpbKIacnl6TclRcMW6qV4fc3/YM7Dz9mMlynkv6zutz8dRd8qdfndPGxu3x9LN/oc7ry0YZ96O6sHnjg+tt2PuZefhs7zHPmk4Mm7crqIa4i/dELDUJ3Rcr0FnRy0KmTKofAf/RQ3e5Rz3atHFqgscB4dqY9NUqhfLc/kRj9El11W5sPdUioiu796YvPMW7+xzZNygJYsqiWrIWvBqi40Hok4szRlr5NP4ceo+vp8kWYmeITkG9etdxZR3Stgv/B5NvK9g60yLlr9b2WV1ZN+Gi7YvGTp/35bYiT806bTldsGBwrV79T8H617e8DqiUpywkls/xGtYKG/e0JpFTk7aPGf84k/NF2hjM+3ZM7Re8usFH12JW+TWE/s5r3yiayxvW937bZapO3O4Jt4lqsEjc+tOm3f7lx7kvH7C5El7TF+7pcx0+tyApN4PEj3IfzN7vF94mFf//J7PnbcH9Pl3zYw3cQ61SzGy8ACXmp+v7Sj9OUNVZ+Fc7dDsct0HAW+eX+vtuvDghK4Fzsz3rleteN4H3rF2VWv7cPove5ypcMqxc9s43TVN+bTkXoNkG3vcLbEkslrCfEVnVTzRf+gzF+E7TLFSaTs+XL8zW6GMO4ct7Hs2W+2rs7a1qH8yYbuHm9Nv2fngF3Ze109/bmnOeHXy1298rXLnDtur+y5tWbXd7A2Xex5MV//lIlEN6Tr0nPPs8e7Fc3dW2J+/c2REvmSLG5bpsb3uYvehle89nzLvl30b33Pnys7ZIj4tvOd5cmb2dclcK1y9Mu7c1jx1gz+aF9YrIqwh+7hTzQ/fDln61cev0vOjATdbPDyzZFKGuolLVq73dFTver/k6m/u/ZeMWXT1g/IqVfi7aimcIo46HFrtaoqTKvTTthP1XwrzcKDvqcadPn5cWDH5vaz9T8XNXulF/mYFvcY8cd/qW2bM4F/yZPIFr1Zt9m2/c8y+DY+/TV1vCshkDtnyz9Lsj545Ht32JuKNqAb7e/vjP98THb4xa5eCKeu8jJzRpsvL41nyF606c0yg/6GFO39Zh/vlsh4p6pk1e/lh8y5+ypNs86bn4WdnjCv88tBIh3LXaw0Tv0f1blBr18Ciz+3iVg2cvrbAbfdmfap8y7os8rzLvMqTK379xZP1OxbWYvDj6a8+Ji2R6tT4iebAPHbTr9+euSbl5iFBhxyFmUwdf4a9/Y0xsT+caZJx9T5f7yPdvGfGK9vUe2yCy0MWhAwfqY2N0yFjksJTLl5OaO5b23+8Q+EMXrVb99kTK1bUhknT311plUW4Xmw89KrZ4VlR3belHJV961r7SvkOPbzcJNMgpyn5sm4b8mWpNjbxlFTx8xXKv6nHrYkFVxSaHuVh7/1xS5bNKZYmzfhlRuzOZ0Q1ODfz7LjuX4cZHYZfPRaZN9+O9jOnjRoT3Dx4wpNzG8u3VEb/coayjmuy1v/UvxnKDEjeLu+yWcO2lz5frXrboYnfJOnaMUOP5KIakq+Le3lN9/t5Fh9LV6VA1mu3OrX40mLgoMtl1nvmCdzfp+svd4Ks5R33+CfPfmhe9w/m9omO763qN3R8tQUV/l3/dUBYdKNhe0U1JOu9fcLSrbcPN05YJ3ni5ssDCt44/nLTp+g4Sd/0//Jg4MzH2tgkU44e+bfjvSyVm77/VqH/4ne7drdqE3h+aPE36ef3OrTWaZbwnfZxqeV71tfZPjhp1vulFzvED5iRMemWQQ0Grr7ddkiBLXYrtLEph0Y+7rcpdo8cbU9mrDp+4YK816dsafii+8Y6SUo8anTY65aohuxR20rdG+tRI36fm3V7fro/K0Wvmh3z3182dHO7Kf65X4eH/3KXCx9zunH7nXW3jlRyuCca5V1v5ebQ/WejWmQ8PvjF+n2Bw/VouBqr3M+Pb7r8bHX92Rr0szX4ZytskqU52dKcZ2nOtzTXWprrLM19luZ+S/OMpXnW0rxjad61NN9amu8sH0DZOWjajpp2Ik07saadUdPOpGkX0rQLa9qVNe0qmnYTTbuppt1Z0+6iaQ/UtAdp2hM17Uma9r+a9jxNe42mvVbT3qtp79O0T2vaZzTt25r2HU37jab9VvNBn72mrVlzU0JNW7PmpgyatmbNTQU1bc2amypp2po1NzXWtDVrbuqkaWvW3DRA09asuWmCpj1Rx4FJLXrArYTaBYeb5oab/g03zdP90kVj9k+hj4zd5gKaf3+6tVFjNYa+dBB6trVR7RojXw3ZQR+6zyVZQei7K2dAYEHoc/z59G9DAY/QfHm0gOptqPlsbEzwQpL3nNjzFwbGFAzYHydaRA/DIl0wLKaCYREbGxO8hAQG9vwlumHA3p5ZAkUtJVjWYoxw7JvIZQSpvTj89BCCp5eAn76c4Okl4aeHEjy9Fvz0FTGV/wpD8lbS57+VuvLfKqr8t5KNjQleTZL/2PNXE+W/1VDUGoFltT7qQpZ+sTfaFmLFB5rLWp0LibzGV0qdCSJxKcvm2OFfRyCztA6ZIZjM9QQyy+iQuRyTuYFAZlkdMkMxmRsJZNbWIXMFJnNTTBUm7C8db6YvTJt1FaYtVIVpMxsbE7yVpDCx528lKkxboahtJMu6hlWJIKzeQyq3Exzrcuzh6GTWYcd6B4HM8jpkrsdk7iSQWUGHzA2YzF0EMivqkLkRk7mbQGYdHTI3YTL3xFTJwf7y7F76krNXV8nZR1Vy9rKxMcH7SUoOe/5+opKzH4o6QLKs21iVwEoOVhgPEhzrSuzh6GR2YMf6EIHMyjpk7sRkHiaQWUWHzF2YzCMEMqvqkLkbk3mUQGZdHTL3YDKPEXz4x9IHO5vy8qdNNcVNV0U5TlNR3NjI2HqcIKgn7OknYuxrJlcIwzD6q0WYLhDCqa4WYWxsTPBJkqsFe/7JQIFDb30PT7CR4ZlZfb5Nu+2ha68jaPbag42Mrccpgp1mTz8VY4feHTr0p+kP/WldIJyhOvSn2diY4LMkh549/yzNoT/FRoZnZvX5Nu12HF17fY5mr+OwkbH1iCTYafb0yBg79J7QoT9Pf+jP6wLhAtWhP8/GxgRfJDn07PkXaQ59JBsZnpnV59u02/F07fUlmr2Ox0bG1uMywU6zp1+OsUMfFzr0V+gP/RVdIFylOvRX2NiY4Gskh549/xrNob/MRoZnZvX5Nu12Al17fZ1mrxOwkbH1uEGw0+zpN2Ls0MeHDv1N+kN/UxcIt6gO/U02Nib4NsmhZ8+/TXPob7CR4ZlZfb5Nu51I117fodnrRGxkbD3uEuw0e/rdGDv0CaFDf4/+0N/TBcJ9qkN/j42NCX5AcujZ8x/QHPq7bGR4Zlafb9NuJ9G11w9p9joJGxlbj0cEO82e/ijGDn1i6NA/pj/0j3WB8ITq0D9mY2OCn5Icevb8pzSH/hEbGZ6Z1efbtNvJdO31M5q9TsZGxtbjOcFOs6c/j7FDnxQ69C/oD/0LXSC8pDr0L9jYmOBXJIeePf8VzaF/zkaGZ2b1+Tbt9j+69vo1zV7/w0bG1uMNwU6zp7+JsUOfHDr0b+kP/VtdILyjOvRv2diY4Pckh549/z3NoX/DRoZnZvX5v+y2WedvJnYGHvC3X7StHUv9j+bXpH+wNKPk/fLhD2HXobgoL/1/0cT57ycw6MfvKv8AndMovWkEe3kUe/jHHw//WyC0iB/ZYv81mQCCrUvRJJNPYskEkMHG/u/F179Fq2HIwfwskHIglZ8VSOVngcRkfVZRbGBrrwd7RkdHq2HIfL4AKhEOv3j9PcvZehzV1JVHNM99tTS/yctz37xEfnt+FJTBvkJjfQOWzMabRpSum0Y01U2DYR8dqPNAg9x9BQTbvojWdFgW0RyLbhHNsaAaxsKA8cx2JJc6ptIO2jn1+VaGi0W8cy9YptXsnIlw56z+ESBVixqG7JyZaufMCqTSbISd+6bZOXvCnbMHdu6bGobsnAPVzjkokEoHiluNWUUyGDvzUJQZinKM8czP1vSrhkInQgqdAAq/qmHIfjlTUeisQCqdBSi0zoMDQwL60TsWhoznYoQs90XDV2xCvmIDfH1Rw5D1daXiy1WBVLqS8OXMkMD4coH4cjMCX581fLkT8uUO8PVZDUPW14OKLw8FUulBwpcrQwLjyw3iy9MIfH3S8BWHkK84AF+f1DBkfeNS8RVXgVTGJeHLgyGB8QX9mIM5nhH4+qjhKz4hX/EBvj6qYcj6JqDiK4ECqUxAwldchgTGVzyIr4RG4CtKw1ciQr4SAXx9D0PWNzEVX4kVSGViEr4SMCQwvqD3OM1JjMDXBw1fSQn5Sgrw9UENQ9Y3GRVfyRRIZTISvhIzJDC+kkB8JTcCX+81fP1DyNc/AF/v1TBkfVNQ8ZVCgVSmIOErGUMC4wt6UcWc0gh8vdPwlYqQr1QAX+/UMGR9vaj48lIglV4kfKVgSGB8pYT4Sm0Evt5q+EpDyFcagK+3ahiyvmmp+EqrQCrTkvDlxZDA+EoN8ZXOCHy90fCVnpCv9ABfb9QwZH0zUPGVQYFUZiDhKy1DAuMrHcRXRiPw9VrDVyZCvjIBfL1Ww5D1zUzFV2YFUpmZhK8MDAmMr4wQX1mMwNcrDV9ZCfnKCvD1Sg1D1jcbFV/ZFEhlNhK+MjMkML6yQHxlNwJfLzV85SDkKwfA10s1DFnfnFR85VQglTlJ+MrGkMD4yg7xlcsIfL3Q8JWbkK/cAF8v1DBkffNQ8ZVHgVTmIeErJ0MC4ysXxFdeI/D1XMNXPkK+8gF8PVfDkPXNT8VXfgVSmZ+ErzwMCYyvvBBfBYzA1zMNXwUJ+SoI8PVMDUPWtxAVX4UUSGUhEr7yMyQwvgpAfBU2Al9PNXwVIeSrCMDXUzUMWd+iVHwVVSCVRUn4KsSQwPiC/u6euZgR+Hqi4as4IV/FAb6eqGHI+pag4quEAqksQcJXUYYExlcxiK+SRuDrsYavUoR8lQL4eqyGIetbmoqv0gqksjQJXyUYEhhfJSG+yhiBr0cavsoS8lUW4OuRGoasbzkqvsopkMpyJHyVZkhgfJWB+CpvBL4eaviqQMhXBYCvh2oYsr4VqfiqqEAqK5LwVY4hgfFVHuKrkhH4eqDhqzIhX5UBvh6oYcj6VqHiq4oCqaxCwldFhgTGVyWIr6pG4Ou+hq9qhHxVA/i6r4Yh61udiq/qCqSyOglfVRgSGF9VIb5qGIGvexq+ahLyVRPg654ahqxvLSq+aimQylokfFVnSGB81YD4qm0Evu5q+KpDyFcdgK+7ahiyvnWp+KqrQCrrkvBViyGB8VUb4queEfi6o+GrPiFf9QG+7qhhyPo2oOKrgQKpbEDCV12GBMZXPYivhkbg67aGr0aEfDUC+LqthiHr25iKr8YKpLIxCV8NGBIYXw0hvpoYga9bGr6aEvLVFODrlhqGrG8zKr6aKZDKZiR8NWZIYHw1gfhqbgS+bmr4akHIVwuAr5tqGLK+Lan4aqlAKluS8NWMIYHx1Rziq5UR+Lqh4cubkC9vgK8bahiyvq2p+GqtQCpbk/DVkiGB8dUK4svHCHxd1/DVhpCvNgBf19UwZH3bUvHVVoFUtiXhqzVDAuPLB+KrnRH4uqbhqz0hX+0Bvq6pYcj6dqDiq4MCqexAwhfbgXYYX+0gvjoaga+rGr46EfLVCeDrqhqGrG9nKr46K5DKziR8dWBIYHx1hPjqYgS+rmj46krIV1eArytqGLK+vlR8+SqQSl8SvjozJDC+ukB8+RmBr8savroR8tUN4OuyGoasb3cqvrorkMruJHz5MiQwvvwgvnoYga9LGr56EvLVE+DrkhqGrK8/FV/+CqTSn4Sv7gwJjK8eEF+9jMDXRQ1fvQn56g3wdVENQ9a3DxVffRRIZR8SvvwZEhhfvSC++hqBrwsavvoR8tUP4OuCGoasb38qvvorkMr+JHz1YUhgfPWF+BpgBL7Oa/gaSMjXQICv82oYsr6DqPgapEAqB5Hw1Z8hgfE1AOJrsBH4itTwNYSQryEAX5FqGLK+Q6n4GqpAKoeS8DWIIYHxNRjiK8AIfJ3T8DWMkK9hAF/n1DBkfYdT8TVcgVQOJ+FrKEMC4ysA4muEEfg6q+FrJCFfIwG+zqphyPqOouJrlAKpHEXC13CGBMbXCIiv0Ubg64yGrzGEfI0B+DqjhiHrO5aKr7EKpHIsCV+jGBIYX6MhvsYZga/TGr7GE/I1HuDrtBqGrO8EKr4mKJDKCSR8jWVIYHyNg/iaaAS+Tmn4mkTI1ySAr1NqGLK+k6n4mqxAKieT8DWBIYHxNRHiS+RPb1uJd2BzZwMDKk1qGKJSkbyWL77/HTxQpROqMki+ymhYpT2qMphkx0Eu4bWcQqYS+rukbrvkP5+dyUCGMvbXW6ciZ5xOZRCmchqLyrB5SaaNGTfUC+7ZKar9rFWJ6zbbdnbKlCbuEQ8+LJ8QFhZBqDIYUzmdRcVvWmdKk/iXQitv2zQwb3iD8ctXN3t0vEp2xwdvPp873K5dBxKVjj/uAxhx+0hWaSI7StgqzYCII1M5FVM5k0V5lbn+odSJvclP5R8eYRfrXnC3NLMufz71bnP20jVaz6dVOQ1TOStm13I6pnI2i8pUd9qmON/WpjlY5u7+faVTRlXLWlrZfihv2q3Kgs+V1ApNodL8w4dh5+IwySqNU4GHVmkOtJdkKmdiKudaPxf2hCpnYSr/ZVFxUvsNmN/2pvvDZPseDB3a49jWuNW7DnrY/0qi+cty16Jdy9mYynlQjiFQ6fTj8y/sXJwgWaXRKvDQKs2HzgWZyrmYygUsKnP/Ca373Gqz2XX9iHvBwd1qXqodp0Sq3EUfF8nZ5sjryummEKr8F1O5kEWlCTxex0PJXKZlgoMJliwZU2acb6G8B5c7lc018Oznt0GVMxCqnIepXBRTa2n+8b0Ddi5OkazSCBV4aJUWQ+eCTOUCTOUSxJ3TqVyIqVxqPRObCVUuwlQus17VaFQ6/vi+FzsXkSSrFKACD61SCHQuyFQuwVQuZ1HOcbbsOpXnpeNb91Zv9pYq3Oaq89LNu98W7zq+Vt0ZIbQql2IqQ2N2LZdhKlfElErHH+/ZYOfiMskqDVaBh1ZpJbRKZCqXYypXQeeCTGUopnK19XphIlS5AlO5BnJBl0nOhfp+I3YubpCs0gAVeGiV1kLngkzlKkzlOugzFDKVqzGV61lUkjwZC3ebcSrB1UxprpTauzLHlKRv0xW7urXSgpefjkXRruUaTOWGmFpL84/3yrFzcZdklfqqwEOrtBE6F2Qq12EqN0E3dzKV6zGVm2N2LTdgKrdAXo1ApdOPn+fBzsUjklXqpQIPrdJWaC/JVG7CVG5jUcmXOZdeUurZyfV9zGW3bJmfv+j4Vpk7eZ2Zk+F42Zzvr3TdSqhyM6Zye8yq3IKp3BFTKp1+/Bwldi6ek6xSDxV4aJV2QueCTOU2TOUuFpVgV4XcRV+ub+pwqUyPY8e2ZnwaMiaV54y571IkXu/zMV1QFUKV2zGVu1mU46P9cTrWKtpz5dy9p549e+he4/bF2E3G5Fvmsj7wxNfNV3wJVe7AVO6BPqelUan+/Dp2Lt6QPN9PBR5apb3QuSBTuQtTuQ95p4ZO5W5M5X7rKh0JVe7BVB5A3qKiUGn68XtDsHMRRbJKXVTgoVU6CJ0LMpX7MJWHrDtaE6HK/ZjKw9ZV2hOqPICpPAKdCwKV9j9+XxN2Lr6SrFJHFXholY5C54JM5SFM5TEW5ZY0/pyt1TrE9k0Qt+v8Vg0SV3H7FC+lb7N0taIGtfny/VyQqTyMqTwOnV4ylUcwlSegT80IVDr++D150LlwN5GsUjsVeGiVwpBzQafyGKYyHPn+gk7lcUzlyZhVeQJTGRFTKk0/fj8pdi6cSFbJRwUeWqVT0LkgUxmOqTyNZGI6lScxlWeQexSdyghM5dmYUun04/dCY+fCjWSVWqnAQ6t0DjoXZCpPYyojWZT72RFeZ+b3ftC4aMCCK1dOJZt7aG2CTXE61ojfNvX0z103XyVUeQZTeR751IxO5VlM5YWY2nHzj9/Hj52LuCSr1FwFHlqli9AqkamMxFReQr6LolN5HlN5GXkPhE7lBUzlFeQ7UgqV9j/+Dgp2LhKRrFITFXhola5C54JM5SVM5bWYVXkZU3kd+XSATuUVTOUNxHdTqHT48fensHORnGSVGqrAQ6t0EyKOTOU1TOWtIOBnL+lUXsdU3g6y+nOsJwlV3sBU3mFRKZw/Xx+d4vAQ32mBRapvtDs9eOT4Fmv8yo5r+uzjnswzZ84mUenw4+/+YefCi2SV6qnAQ6t0FzoXZCpvYSrvsSiXVcurZHd5Gpnu6uXdSe+vKH/uQg7/e+kTDe/58etjn7x58xGqvI2pvA+dXjKVdzCVD2JqLZ1+/L1V7FykJ1ml2irw0Co9hM4Fmcp7mMpHyBsWdCrvYyofBwE/r0en8gGm8gn06UB6knOh/p1r7FxkIVmlGirw0Co9hc4FmcpHmMpnEHFkKh9jKp9Dp5dM5RNM5QvoXBCoZJ9HVQw3V8LORU6SVaqqAg+t0kvoXJCpfIapfBVk9WdpTIQqn2MqX8esyheYyjcxpZJ9310u3FweOxf5SFapkgo8tEpvoXNBpvIVpvId9BkKmcrXmMr3MbuWbzCVH2JqLdm5KB1uLoOdi8Ikq1ReBR5apShoL8lUvsNUfoxZle8xlZ8g4shUfsBUfo4plezzqBLh5pLYuShBskplVOChVfoCEUem8iOm8iv0CSiZyk+Yym8xu5afMZXRMaWS+Yui4eZi2LkoS7JKJVXgkefbx4JWiUzlV0ylHfQdLZnKb5hKUxDwGwXoVEZjKs2QvyBQyb7vLhRuLoydi0okq1RMBR5aJXvoXJCptMNUOkC1n0ylCVPpGLNracZUOrGodFWLnM90r1CqKsXyVbqV2lT+eobnBZpWTdDl9aO+Od5+PxcEKtk9Kn+4uQB2LqqTrFJhFXholZyhvSRT6YCpdIHuUWQqHTGVsWN2LZ0wla4xtZbsXOQJN+fFzkUdklUqoAIPrZIbtJdkKl0wle7Wv0luT6gyNqbSA/ommUylK6bSM6Z2nJ2LnOHmXNi5aEiySnlV4KFVigOtEplKd0xlXIg4MpUemMp4UCYmU+mJqYwfUzvOfHe2cHN27Fw0I1mlXCrw0ColgFaJTGVcTGXCIOQNbjKV8TCViSBHS6YyPqYycUztOPv+InO4OQt2LrxJVim7Cjy0SkmgVSJTmRBTmTTI6u/Io1SZCFOZDPo8ikxlYkxlcugzDAKV7B6VIdycETsX7UhWKYsKPLRK/0DngkxlUkxlCugeRaYyGaYyZcyqTI6pTBWEvGfejqRepA03p8PORWeSVcqoAg+tkhd0LshUpsBUpg4C/pYJncqUmMo0MasyFaYyLVQvCFQ6hZu9ws2psXPRjWSV0qnAQ6uUDjoXZCpTYyrTByFvqpKpTIOpzBCEvKlKpjItpjJjTK2lKdycItycEjsXvUhWKbUKPLRKmaBzQaYyPaYys3WVZkKVGTCVWaBMTKYyI6Yya0ytJfu+O1m4OTl2LvqTrFJKFXholbJB54JMZWZMZfYgqz85TakyC6YyB3QuyFRmxVTmjKkdZ/Uicbg5CXYuhpCsUnIVeGiVckGrRKYyO6YyN0QcmcocmMo8UCYmU5kTU5k3ptaSfX+RINycEDsXI0hWKYkKPLRK+aBzQaYyN6YyP+RoyVTmwVQWgL6/IFOZF1NZEPo0mUZl3HBzPOxcjCV5fkIVeGiVCkHngkxlfkxlYesqHQhVFsBUFrGu0p5QZUFMZdGY2nF2j/IIN3ti52ISySrFU4GHVqkYtEpkKgtjKotDtZ9MZRFMZYkggA06lUUxlSVjSiU7F67hZjfsXASTrJKnCjy0SqWgc0GmsjimsnQQ8vtpyVSWwFSWgU4vmcqSmMqy1lWaSVSy7/Wcw80u2LmYQbJKbirw0CqVg84FmcrSmMry0HsgZCrLYCorxKzKspjKipBXo1HpEG52xM7FXJLnu6jAQ6tUCToXZCrLYyorQ5/0kKmsgKmsErMqK2Iqq0JeTa/KQOyHaO0gidWsz/iPJfrbqC+io7+wZ4ebzdihXEiyRY7stAUji282Q6tUHTq6ZHOpHIw8H5xLjSDkB0nI5lJF5lxqxuxcqgYjaQicSy3o1TaKuVQLN+3HTusyipU0HQg3HcKeHyLwfCAHsgMeDOdUq/NxXwZFhRCsZXV4J0OpdvIw9vwVVDtZw9pOsgr1Fd3JUChqBcFa1oB3chXVTh7Bnr+aaidryjyTq6Co1QRrWRPeybVUO3kUe/46qp2sBZzJL+hOroWi9M7l+6Xayj8wN4cKeW3g0WvLdPH26VzGr2+FXr4+Zb27dAlYUqd0jYrlgwKWNezo79u2Z082jtevCpGLkw+yOPa1oXnUkTSPOl66V9rE/hWksS6gMaR6265+PfrV7BYUKzg4MND6vwgOVKBlrCtvqHp6cSUaNgibOLQ39QFrSbY39eUN1YBmbxroQtfOsOg2FGHMGj3O0h5NtoQSCWtEsYRO0h69okyPjl26dGyv5vcpJiVgad2Ovu27tMVm19z6A76P2LVbl7bh9o2RLbLTfQtqzkbGtqKJ9YUVeXqTQJ1bjNyt1HGRS0FzbOZQUm8KrA9yKWjqpfdjxW9MIvt3yD1NDUMmg/zENjKZZr9OJgjYOx917xCNbM7N5N38mkHr0lzSujTXvcnR3yfcHLsiYtfxFpIm08JLwPywybTA7lQtoMm0jMn7bkt5Q7UisZrqakMfGnxPdtZVYnviDRQsBDBvQcC8McC8ocm0jknAWssbyof6XgMxrLnZtKG52TAZbGxMcFuCu83357fVe7sJRE5pY2yjIazbAVO3EYd2unBoT4VDOzY2JrgDCQ7s+R104xAEJ23rUR0FltX6qGzLOmB5tgOkspPe/GQOIshPliH/vmV26n+CLPR2tjS7YCAjBbBz2HUorovAB6NsOf6+L0Evv0d1hnavCw3g2MO7/nj43wKhZezKlvuvOQ8QbF2KJuf5iuU8QAYb+7/D+bdoNQxBxU8gM0Iq/RRIpR/FF0H2XdjA1lKY53cL5gdtPvL7CBAOu3nZWnq76Cq93alKL1vg7pjgHiSllz2/R6CtdcXW5KeWijyidaWnpekvr670xML8vfTfUdlqQGWlJzSWP7Cy+rHoyG4b2M6S/L4H+x5sYIqPP9mqspGxA9dL77EQSkLWFGuSUG/CJNQbu230hqbVhypV9cGY7BPjO6d+LKnZub6EO9fX2s79+Ii0LzStflQ710+BVPYjOfO9GBKYEesF8dXfCHx90/A1gJCvAQBf39QwZLyBVHwNVCCVA0n46seQwPjqD/E1yAh8fdXwNZiQr8EAX1/VMGS8IVR8DVEglUNI+BrIkMD4GgTxNdQIfH3R8BVAyFcAwNcXNQwZbxgVX8MUSOUwEr6GMCQwvoZCfA03Al+fNXyNIORrBMDXZzUMGW8kFV8jFUjlSBK+hjEkML6GQ3yNMgJfnzR8jSbkazTA1yc1DBlvDBVfYxRI5RgSvkYyJDC+RkF8jTUCXx81fI0j5GscwNdHNQwZbzwVX+MVSOV4Er7GMCQwvsZCfE0wAl9RGr4mEvI1EeArSg1DxptExdckBVI5iYSv8QwJjK8JEF+TjcDXBw1fgYR8BQJ8fVDDkPEUKr4UBVKpkPA1iSGB8TUZ4ivICHy91/AVTMhXMMDXezUMGW8KFV9TFEjlFBK+FIYExhf2LcNUI/D1TsPXNEK+pgF8vVPDkPGmU/E1XYFUTifhawpDAuNrKsTXDCPw9VbD10xCvmYCfL1Vw5DxZlHxNUuBVM4i4Ws6QwLjawbE12wj8PVGw9ccQr7mAHy9UcOQ8eZS8TVXgVTOJeFrFkMC42s2xNe/RuDrtYaveYR8zQP4eq2GIePNp+JrvgKpnE/C11yGBMbXvxBfC4zA1ysNXwsJ+VoI8PVKDUPGW0TF1yIFUrmIhK/5DAmMrwUQX4uNwNdLDV9LCPlaAvD1Ug1DxltKxddSBVK5lISvRQwJjK/FEF/LjMDXCw1fIYR8hQB8vVDDkPGWU/G1XIFULifhaylDAuNrGcRXqBH4eq7hawUhXysAvp6rYch4K6n4WqlAKleS8LWcIYHxFQrxtcoIfD3T8LWakK/VAF/P1DBkvDVUfK1RIJVrSPhayZDA+FoF8bXWCHw91fC1jpCvdQBfT9UwZLz1VHytVyCV60n4WsOQwPhaC/G1wQh8PdHwtZGQr40AX0/UMGS8TVR8bVIglZtI+FrPkMD42gDxtdkIfD3W8LWFkK8tAF+P1TBkvK1UfG1VIJVbSfjaxJDA+NoM8bXNCHw90vC1nZCv7QBfj9QwZLwdVHztUCCVO0j42sqQwPjaBvG10wh8PdTwtYuQr10AXw/VMGS83VR87VYglbtJ+NrBkMD42gnxtccIfD3Q8LWXkK+9AF8P1DBkvH1UfO1TIJX7SPjazZDA+NoD8bXfCHzd1/B1gJCvAwBf99UwZLyDVHwdVCCVB0n42seQwPjaD/F1yAh83dPwdZiQr8MAX/fUMGS8I1R8HVEglUdI+DrIkMD4OgTxddQIfN3V8HWMkK9jAF931TBkvONUfB1XIJXHSfg6wpDA+DoK8XXCCHzd0fAVRshXGMDXHTUMGS+ciq9wBVIZTsLXcYYExtcJiK+TRuDrtoavCEK+IgC+bqthyHinqPg6pUAqT5HwFc6QwPg6CfF12gh83dLwdYaQrzMAX7fUMGS8s1R8nVUglWdJ+DrFkMD4Og3xdc4IfN3U8BVJyFckwNdNNQwZ7zwVX+cVSOV5Er7OMiQwvs5BfF0wAl83NHxdJOTrIsDXDTUMGe8SFV+XFEjlJRK+zjMkML4uQHxdNgJf1zV8XSHk6wrA13U1DBnvKhVfVxVI5VUSvi4xJDC+LkN8XTMCX9c0fF0n5Os6wNc1NQwZ7wYVXzcUSOUNEr6uMiQwvq5BfN00Al9XNXzdIuTrFsDXVTUMGe82FV+3FUjlbRK+WOG9ifF1E+LrjhH4uqLh6y4hX3cBvq6oYch496j4uqdAKu+R8MU++LiD8XUH4uu+Efi6rOHrASFfDwC+LqthyHgPqfh6qEAqH5Lwxb54uo/xdR/i65ER+Lqk4esxIV+PAb4uqWHIeE+o+HqiQCqfkPD1kCGB8fUI4uupEfi6qOHrGSFfzwC+LqphyHjPqfh6rkAqn5Pw9YQhgfH1FOLrhRH4uqDh6yUhXy8Bvi6oYch4r6j4eqVAKl+R8PWcIYHx9QLi67UR+Dqv4esNIV9vAL7Oq2HIeG+p+HqrQCrfkvD1iiGB8fUa4uudEfiK1PD1npCv9wBfkWoYMt4HKr4+KJDKDyR8vWVIYHy9g/iKMgJf5zR8fSTk6yPA1zk1DBnvExVfnxRI5ScSvj4wJDC+oiC+PhuBr7Mavr4Q8vUF4OusGoaM95WKr68KpPIrCV+fGBIYX58hvr4Zga8zGr6iCfmKBvg6o4YB4znEIuLLIZaCqFSfb2U4Eb6+MiQwvr4hfDnYGYGv0xa+HEx0fDmYAL5Oq2EIX2YqvswKpNJMwZeDigTEFwtDxrM3Al+nNHw5EPLlAPB1Sg1D1teRii9HBVLpSMKXmSGB8WUP8eUkWeUL9W/HOTiygQGVTmoYotJZp8qgYOTZ6loim+7AYp2hP6fp4CJfqOOPpAIJtWcKMKGx5Qs1/aiukFD2/9iYUFf5Qh1+XDOh885gdsWEulEw+t1vQUI/MwWYUHcKRr9/8AAJjWIKMKEe8oU6//gEDhL6jinAhHrKF2r+8VE0JPQ1U4AJjUMiVP1OBhL6ginAhMaVL9T+x5eTkNCnTAEmNJ58oXY/vqWHAh8xBZjQ+CSnXn1dBRJ6nynAhCYgyaPqe1uQ0DtMASY0IcmKqi8wQkJvMgWY0EQkJVR9kxcSeo0pwIQmJtl69ZV2SOhlpgATmoQkj6o/2wEJvcAUYEKTkuRR9YecIKHnmAJMaDKSrVd/2g8Syj4PSIYJTU5ycVZ/7BUSepIpwIT+Q5Ke1J//hoSeYAowoSlI0pP6ixAgoUeZAkxoSpJavy/cfj8UeIgpwISmIllR9VfjQEL3MwWYUC8SRtXfEQUJ3cMUYEJTkyR89ZelQUJ3MgWY0DQkW6/+1kBI6DamABOaliSPqr8+ExK6mSnAhKYjKaHq75GFhG5gCjCh6Um2fmW4/SpI6FqmABOageQwqb9ZHBK6iinAhGYkYVT9FfuQ0FCmABOaiWTr1b81AQldxhRgQjOTHKb54fYLIKGLmQJMaBYSRtW/PgQJXcAUYEKzkjCq/hkuSOi/TAEmNBvJiqp/jw4SOpspwIRmJ7nmqX+YEQqcwRRgQnOQbL36F0ohoVOZAkxoTpJrnvqneiGhQUwBJjQXSR5V/2Y1JHQyU4AJzU2SR9U/3g4JncAUYELzkAgdGW4/ChI6linAhOYlOfXDwu2HQ4GjmAJMaD4SoUPC7YdCgcOZAkxofpKEPzDcfhAkdChTgAktQLKi/cLt+0OBg5gCTGhBQOgvL4OYg36+DAKJNu2vBoUdCDcdCgTE/HwT5e/Bdup/gizvmBSyNAtjr5usLdPF26dzGb++FXr5+qhTD1hSp3SNiuWDApY17Ojv27ZnTzZq2HUorrDXL7sdOOXvexP08vs32oWgHSyMvLrhvgyKCtGJbSD0F8XBiRT58fC/BUKLXYRtyl/fXwIEW5eieX+pqNj7S4AMNvZ/77z8LVoNA7bXoZjA+0uQymIKpLKYTryg96ccCrOBrb0Z5BkdHa2GIfMpDqhEOCzuZVvmtO8Vbt8HCuzP8jhh7ixhaZaUlztLgLmzpJdApdS1dEFQNi4BwVOSJoNiDy8lKYOWsj2DltCVQUtTZdASbGwsg5aGMmgZkgzKVJbBMmgZkgxakg2MZdAy0OaXlZRBy/7fGRQ8N9DlyMqh/Z4ORXNnOUuzvLzcWQ4LK6/v2qlvzaCkWQ56Ynlg/X+ZCJaDKiCHpXrbrn49+lX27egf7DyT/Zv/6/9LfwTqP92sFrFlgF6b7wVNqyJFDrBvzgbGlrUS8PyQH6tVs1uQczCCfSzwJwuQh6NDVRZYR2B32MDB0PMrYiqhPalCsCd2MbAnVWKSrQryhqqq9xqIHb1qQP0gW55q8oaqTrM8Nax/GUG3PDXkDVWTZnlqWf8wlG55askbqjbN8tSx/jUB3fLUkTdUXZrlqWf9eym65aknb6j6NMvTwPr3i3TL00DeUA1plqeR1WGd6JankbyhGtMsTxOrwzrTLU8TeUM1teHrJOgRPn8PYR9SfBO16s0szebyrHozLKz5b1YdsRA+kAVvBgHYHFhXvT+021x9uPV5mJtDCltI+lCphZduV+fDJiJhQ/7/RLANaSmJv5Z/fnwOSGTLhAa2xNxuCyiqJbQ2rSSh0MpLL9PR36fcCqDapIYhk/GWNBlvL4FPK9hkvLGf/feGJtNal3+PJbeOtZY3lA/JZ0PqagfDOcK6SmxP2kjKJG0EAWuDAdYGmkzbmASsrbyh2um9KOn+JSwIw5qv4NoT/RIWB1Y822OCO1D8ehX1+R0CdR7nQOSUNsY2GsK6IzB1G3HoqAuHTlQ4dGRjY4I7k+DAnt9ZNw5BEi92XQSW1fqoHdi0sDzbGVLZldrIYTVW0Mr5Wpp+8qycL/jGip+Al2PLAbk5X2j3/GgAxx7e7cfDbX4LpZvtb6H4WpeiyXndqd5C8WVjY2+hdIdQ6UHyFgpT2QN7C6WHwO3Y+qz82MDYWyg9oM3vKclY9fSytfT66Sq9/lSlly2wPya4F0npZc/vFWhrXbE1+amlIo9oXeltafaRV1d6Y2F9vPTfUdlqQGWlNzRWH2Bl9WPRhd02sJ3tS5J3erGBAwVGtq63NxsZO3B99R4LoSRkTbEmCfUjTEL9sNtGP2ha/alSVX+Myf4xvnPqx5KanRtAuHMDgN+mGq2GIeMNpNq5gQqkciDJme/LkMCMWF+Ir0FG4Oubhq/BhHwNBvj6poYh4w2h4muIAqkcQsLXQIYExtcgiK+hRuDrq4avAEK+AgC+vqphyHjDqPgapkAqh5HwNYQhgfE1FOJruBH4+qLhawQhXyMAvr6oYch4I6n4GqlAKkeS8DWMIYHxNRzia5QR+Pqs4Ws0IV+jAb4+q2HIeGOo+BqjQCrHkPA1kiGB8TUK4musEfj6pOFrHCFf4wC+PqlhyHjjqfgar0Aqx5PwNYYhgfE1FuJrghH4+qjhayIhXxMBvj6qYch4k6j4mqRAKieR8DWeIYHxNQHia7IR+IrS8BVIyFcgwFeUGoaMp1DxpSiQSoWEr0kMCYyvyRBfQUbg64OGr2BCvoIBvj6oYch4U6j4mqJAKqeQ8KUwJDC+sE+BpxqBr/cavqYR8jUN4Ou9GoaMN52Kr+kKpHI6CV9TGBIYX1MhvmYYga93Gr5mEvI1E+DrnRqGjDeLiq9ZCqRyFglf0xkSGF8zIL5mG4Gvtxq+5hDyNQfg660ahow3l4qvuQqkci4JX7MYEhhfsyG+/jUCX280fM0j5GsewNcbNQwZbz4VX/MVSOV8Er7mMiQwvv6F+FpgBL5ea/haSMjXQoCv12oYMt4iKr4WKZDKRSR8zWdIYHwtgPhabAS+Xmn4WkLI1xKAr1dqGDLeUiq+liqQyqUkfC1iSGB8LYb4WmYEvl5q+Aoh5CsE4OulGoaMt5yKr+UKpHI5CV9LGRIYX8sgvkKNwNcLDV8rCPlaAfD1Qg1DxltJxddKBVK5koSv5QwJjK9QiK9VRuDruYav1YR8rQb4eq6GIeOtoeJrjQKpXEPC10qGBMbXKoivtUbg65mGr3WEfK0D+HqmhiHjrafia70CqVxPwtcahgTG11qIrw1G4Ouphq+NhHxtBPh6qoYh422i4muTAqncRMLXeoYExtcGiK/NRuDriYavLYR8bQH4eqKGIeNtpeJrqwKp3ErC1yaGBMbXZoivbUbg67GGr+2EfG0H+HqshiHj7aDia4cCqdxBwtdWhgTG1zaIr51G4OuRhq9dhHztAvh6pIYh4+2m4mu3AqncTcLXDoYExtdOiK89RuDroYavvYR87QX4eqiGIePto+JrnwKp3EfC126GBMbXHoiv/Ubg64GGrwOEfB0A+HqghiHjHaTi66ACqTxIwtc+hgTG136Ir0NG4Ou+hq/DhHwdBvi6r4Yh4x2h4uuIAqk8QsLXQYYExtchiK+jRuDrnoavY4R8HQP4uqeGIeMdp+LruAKpPE7C1xGGBMbXUYivE0bg666GrzBCvsIAvu6qYch44VR8hSuQynASvo4zJDC+TkB8nTQCX3c0fEUQ8hUB8HVHDUPGO0XF1ykFUnmKhK9whgTG10mIr9NG4Ou2hq8zhHydAfi6rYYh452l4uusAqk8S8LXKYYExtdpiK9zRuDrloavSEK+IgG+bqlhyHjnqfg6r0Aqz5PwdZYhgfF1DuLrghH4uqnh6yIhXxcBvm6qYch4l6j4uqRAKi+R8HWeIYHxdQHi67IR+Lqh4esKIV9XAL5uqGHIeFep+LqqQCqvkvB1iSGB8XUZ4uuaEfi6ruHrOiFf1wG+rqthyHg3qPi6oUAqb5DwdZUhgfF1DeLrphH4uqbh6xYhX7cAvq6pYch4t6n4uq1AKm+T8MUS402Mr5sQX3eMwNdVDV93Cfm6C/B1VQ1DxrtHxdc9BVJ5j4QvZkzvYHzdgfi6bwS+rmj4ekDI1wOArytqGDLeQyq+HiqQyockfLEvBu5jfN2H+HpkBL4ua/h6TMjXY4Cvy2oYMt4TKr6eKJDKJyR8PWRIYHw9gvh6agS+Lmn4ekbI1zOAr0tqGDLecyq+niuQyuckfD1hSGB8PYX4emEEvi5q+HpJyNdLgK+Lahgy3isqvl4pkMpXJHw9Z0hgfL2A+HptBL4uaPh6Q8jXG4CvC2oYMt5bKr7eKpDKtyR8vWJIYHy9hvh6ZwS+zmv4ek/I13uAr/NqGDLeByq+PiiQyg8kfL1lSGB8vYP4ijICX5Eavj4S8vUR4CtSDUPG+0TF1ycFUvmJhK8PDAmMryiIr89G4Ouchq8vhHx9Afg6p4Yh432l4uurAqn8SsLXJ4YExtdniK9vRuDrrIavaEK+ogG+zqphwHiOsYj4coylICrV51sZToSvrwwJjK9vCF+Odkbg64yFL0cTHV+OJoCvM2oYwpeZii+zAqk0U/DlqCIB8cXCkPHsjcDXaQ1fDoR8OQB8nVbDkPV1pOLLUYFUOpLwZWZIYHzZQ3w5GYGvUxq+nAn5cgb4OqWGIevrQsWXiwKpdCHhy5EhgfHlBPEVW7LKF+rfJnR0YQMDKu3VMESlq06VQdb30vHHWiKb7hibKYD+nKajm3yhTj+SCiSUxbphQt3lC7X7UV2hQLbz7phQD4qt/37NhISy/3tgQj3lC3X+4begxPSNKcCExiFZUfWDB0joZ6YAExpXvlD7H5/AQUKjmAJMaDyKU//9o2hI6DumABMan2Tr1e9kIKGvmQJMaAKSrVe/nISEvmAKMKEJSVZU/ZYeEvqUKcCEJiJZUfV1FUjoI6YAE5qYJI+q721BQu8zBZjQJPKFmn68wAgJvcMUYEKTyhfq8ONNXkjoTaYAE5qMJI+qr7RDQq8xBZjQ5CRC1Z/tgIReZgowof+QCFV/yAkSeoEpwISmIDlM6k/7QULPMQWY0JQkeVT9sVdIKPvgIiUmNJV8oeYfP/8NCT3JFGBCvUiEqr8IARJ6ginAhKYmEar+RhBI6FGmABOahiTh7wt32A8JPcQUYELTkqyo+juiIKH7mQJMaDoSoeovS4OE7mEKMKHpSbZe/a2BkNCdTAEmNAOJUPXXZ0JCtzEFmNCMJELV3yMLCd3MFGBCM5GU0DXhDmshoRuYAkxoZpIVVX+zOCR0LVOACc1CIlT9FfuQ0FVMASY0K0l6Uv/WBCQ0lCnAhGYjEar+0RVI6DKmABOaneSaNz/cYQEkdDFTgAnNQbKi6p/hgoQuYAowoTkpPnH+/vfooMB/mQJMaC6Sj3TUP8wICZ3NFGBCc5Mwqv6FUkjoDKYAE5qHZOvVP9ULBU5lCjCheUlKqPo3qyGhQUwBJjQfyYqqf7wdCpzMFGBC85MwOibcYSwkdAJTgAktQFLrR4Y7jIKEjmUKMKEFSRgdFu4wHBI6iinAhBYiWdEh4Q5DIaHDmQJMaGGSEjow3GEQJHQoU4AJLQII/eVlEHPQz5dBoAxg2l8dCjsQbjocCIj5+SbK34Pt1P8EWd4xKWppFsNeN1lbpou3T+cyfn0r9PL1UacesKRO6RoVywcFLGvY0d+3bc+ebNSw61BcMa9fdjtwyt/3Jujl9y+Ki0I7WAx5dcM9FIpaoRPbQOgv1oMTKf7j4X8LhBa7ONuUv76/BAi2LkXz/lIJsfeXABls7P/eeflbtBoGbK9jSYH3lyCVJRVIZUmdeEHvTzkWYwNbezPI8/s7RCWhzS8FqEQ4LOVlS+ZkdalvuEN/KN0PYnmcMHeWtjTLyMudpcHcWcZLoKTrWrogKBuXhuApQ5NBsYeXlZRBy9qeQUvryqDlqDJoaTY2lkHLQRm0PEkGZSrLYxm0PEkGLcMGxjJoeWjzK0jKoBX+7wwKnhvocmTl0H5Ph6K5s6KlWUle7qyIhVXSd+3Ut2ZQ0qwIPbESsP66qXaoGO5QFUtWlSlOlfr86tjzq1A9vyb2/KpUz6+NPb8a1fPrYs+vTvX8+tjza1A9vyH2/JpUz2+MPb8W1fObYs+vjTy/etuufj36Vfbt6B/sMpPlDHZs2clh8DJ+2BayVWQTYWMt/RGo/xrALq0sX0I/X9MXmlYdkmVtxQbGlrUu8PyQH6tVs1uQSzBSH2OBP4KEPBwdqp7AOgK7wwYOhp5fB1MJ7Ul9gj2xi4E9qR+DbDlUkDePBjE5j2ry5tEwJudRQ948GsXkPGrJm0fjmJxHHXnzaBKT86gnbx5NY3IeDeTNo1lMzqORvHk0j8l5NJE3jxY2fH8HPcLKQrFPhb6JfjbS0tJsJe+zkZZYWKvfPhtBrmLNoc88WkIXsVbAuuq9VDZnD5cwj/+vEJuHt6Rt8/bS+0Ph35hE9u8Ax2RWw5DJtJb0wWXrP7+zsPZwH3XvoG1hwyOb7APlj9bQuvhIWhcf3Zsc/X3CPsAmm9QwZDJtJE2mjZeA62OTaYP9soU20GTa6qpjseR67LbyhmpH4rHV1Q6Gk511ldietJeUEtsLAtYeA6w9NJkOMQlYB3lDddR7UdL9W28QhjXfeXYi+q03ju3Y2JjgzhS/z0Z9fudAncc5EDmljbGNhrDuAkzdRhy66MKhKxUOXdjYmGBfEhzY83114xAk8YbqJ7Cs1kftzKaF5VlfSGU3aiOH1VhBK9fd0uwhz8p1B18R6iHg5dhyQG6uO7R7PWgAxx7e88fDbX7tp6ftr/10ty5Fk/P8qV776c7Gxl778YdQ6UXy2g9T2Qt77aeXwO3Y+qx6sIGx1356QZvfW5Kx6u1la+ntoav09qEqvWyB+2CC+5KUXvb8voG21hVbk59aKvKI1pV+lmZ/eXWlHxbW30v/HZWtBlRW+kFj9QdWVj8Wfuy2ge3sAJK805cNHCgwsnW9/djI2IEboPdYCCUha4o1SWggYRIaiN02BkLTGkSVqgZhTA6K8Z1TP5bU7Nxgwp0bDPz62mg1DBlvCNXODVEglUNIzvwAhgRmxAZAfA01Al/fNHwFEPIVAPD1TQ1DxhtGxdcwBVI5jISvIQwJjK+hEF/DjcDXVw1fIwj5GgHw9VUNQ8YbScXXSAVSOZKEr2EMCYyv4RBfo4zA1xcNX6MJ+RoN8PVFDUPGG0PF1xgFUjmGhK+RDAmMr1EQX2ONwNdnDV/jCPkaB/D1WQ1DxhtPxdd4BVI5noSvMQwJjK+xEF8TjMDXJw1fEwn5mgjw9UkNQ8abRMXXJAVSOYmEr/EMCYyvCRBfk43A10cNX4GEfAUCfH1Uw5DxFCq+FAVSqZDwNYkhgfE1GeIryAh8RWn4CibkKxjgK0oNQ8abQsXXFAVSOYWEL4UhgfGFfUo31Qh8fdDwNY2Qr2kAXx/UMGS86VR8TVcgldNJ+JrCkMD4mgrxNcMIfL3X8DWTkK+ZAF/v1TBkvFlUfM1SIJWzSPiazpDA+JoB8TXbCHy90/A1h5CvOQBf79QwZLy5VHzNVSCVc0n4msWQwPiaDfH1rxH4eqvhax4hX/MAvt6qYch486n4mq9AKueT8DWXIYHx9S/E1wIj8PVGw9dCQr4WAny9UcOQ8RZR8bVIgVQuIuFrPkMC42sBxNdiI/D1WsPXEkK+lgB8vVbDkPGWUvG1VIFULiXhaxFDAuNrMcTXMiPw9UrDVwghXyEAX6/UMGS85VR8LVcglctJ+FrKkMD4WgbxFWoEvl5q+FpByNcKgK+Xahgy3koqvlYqkMqVJHwtZ0hgfIVCfK0yAl8vNHytJuRrNcDXCzUMGW8NFV9rFEjlGhK+VjIkML5WQXytNQJfzzV8rSPkax3A13M1DBlvPRVf6xVI5XoSvtYwJDC+1kJ8bTACX880fG0k5GsjwNczNQwZbxMVX5sUSOUmEr7WMyQwvjZAfG02Al9PNXxtIeRrC8DXUzUMGW8rFV9bFUjlVhK+NjEkML42Q3xtMwJfTzR8bSfkazvA1xM1DBlvBxVfOxRI5Q4SvrYyJDC+tkF87TQCX481fO0i5GsXwNdjNQwZbzcVX7sVSOVuEr52MCQwvnZCfO0xAl+PNHztJeRrL8DXIzUMGW8fFV/7FEjlPhK+djMkML72QHztNwJfDzV8HSDk6wDA10M1DBnvIBVfBxVI5UESvvYxJDC+9kN8HTICXw80fB0m5OswwNcDNQwZ7wgVX0cUSOUREr4OMiQwvg5BfB01Al/3NXwdI+TrGMDXfTUMGe84FV/HFUjlcRK+jjAkML6OQnydMAJf9zR8hRHyFQbwdU8NQ8YLp+IrXIFUhpPwdZwhgfF1AuLrpBH4uqvhK4KQrwiAr7tqGDLeKSq+TimQylMkfIUzJDC+TkJ8nTYCX3c0fJ0h5OsMwNcdNQwZ7ywVX2cVSOVZEr5OMSQwvk5DfJ0zAl+3NXxFEvIVCfB1Ww1DxjtPxdd5BVJ5noSvswwJjK9zEF8XjMDXLQ1fFwn5ugjwdUsNQ8a7RMXXJQVSeYmEr/MMCYyvCxBfl43A100NX1cI+boC8HVTDUPGu0rF11UFUnmVhK9LDAmMr8sQX9eMwNcNDV/XCfm6DvB1Qw1DxrtBxdcNBVJ5g4SvqwwJjK9rEF83jcDXdQ1ftwj5ugXwdV0NQ8a7TcXXbQVSeZuELwbuTYyvmxBfd4zA1zUNX3cJ+boL8HVNDUPGu0fF1z0FUnmPhC9mHO5gfN2B+LpvBL6uavh6QMjXA4Cvq2oYMt5DKr4eKpDKhyR8sQ9u72N83Yf4emQEvq5o+HpMyNdjgK8rahgy3hMqvp4okMonJHyxL84fYXw9gvh6agS+Lmv4ekbI1zOAr8tqGDLecyq+niuQyuckfD1hSGB8PYX4emEEvi5p+HpJyNdLgK9Lahgy3isqvl4pkMpXJHw9Z0hgfL2A+HptBL4uavh6Q8jXG4Cvi2oYMt5bKr7eKpDKtyR8vWJIYHy9hvh6ZwS+Lmj4ek/I13uArwtqGDLeByq+PiiQyg8kfL1lSGB8vYP4ijICX+c1fH0k5OsjwNd5NQwZ7xMVX58USOUnEr4+MCQwvqIgvj4bga9IDV9fCPn6AvAVqYYh432l4uurAqn8SsLXJ4YExtdniK9vRuDrnIavaEK+ogG+zqlhwHhOsYj4coqlICrV51sZToSvrwwJjK9vCF9Odkbg66yFLycTHV9OJoCvs2oYwpeZii+zAqk0U/DlpCIB8cXCkPHsjcDXGQ1fDoR8OQB8nVHDkPV1pOLLUYFUOpLwZWZIYHzZQ3w5GYGv0xq+nAn5cgb4Oq2GIevrQsWXiwKpdCHhy5EhgfHlBPEVW7LKF+rfjnNyYQMDKp3UMESlq06VQdb30vHHWiKb7hSbKYD+3KGTm3yh5h9JBRLKFtQNE+ouX6jTj+oKCbVnCjChHhQr+v2aCQll//fAhHpSMPrdb0GJ6RtTgAmNQyJU/eABEvqZKcCExiURqn4CBwmNYgowofFIGFU/ioaEvmMKMKHxKU799+9kIKGvmQJMaIKD1oYTEap+OQkJfcEUYEITyhdq9+NbeijwKVOACU0kX6jpx+sqkNBHTAEmNLF8ofY/3tuChN5nCjChSUjSk/oCIyT0DlOACU1KsvXqm7yQ0JtMASY0GcmpV19ph4ReYwowoclJEr76sx2Q0MtMASb0H5LDpP6QEyT0AlOACU0hX6jDj5/2g4SyzzNTYEJTkghVf+wVEsqMZUpMaCqSw6T+/Dck9CRTgAn1IhGq/iIESOgJpgATmprk1Ku/EQQSepQpwISmIalM+8Id90NCDzEFmNC0JELV3xEFCd3PFGBC05GcevWXpUFC9zAFmND0JIyqvzUQErqTKcCEZiCpTOqvz4SEbmMKMKEZSbZ+fbjjBkjoZqYAE5qJRKj6C5UhoRuYAkxoZhKh6m8Wh4SuZQowoVlIDpP6K/YhoauYAkxoVpI8qv6tCUhoKFOACc1GsvXqH12BhC5jCjCh2UlWdH644wJI6GKmABOag+T2pP4ZLkjoAqYAE5qTxIWqf48OEvovU4AJzUVSmdQ/zAgJnc0UYEJzk6yo+hdKIaEzmAJMaB6SPKr+qV5I6FSmABOal+TTPPVvVkOBQUwBJjQfydarf7wdEjqZKcCE5icROibccSwkdAJTgAktQJLwR4Y7joKEjmUKMKEFSRgdFu44HAocxRRgQguR1Poh4Y5DIaHDmQJMaGFA6C/vWJiDfr5jAa2uaX8NKOxAuOlIICDm5wsefw+2U/8TZHl1o4ilWRR7i2NtmS7ePp3L+PWt0MvXR516wJI6pWtULB8UsKxhR3/ftj17slHDrkNxRb1+2e3AKX/fm6CX379/LQLtYFHkjQj3VVDUap3YBkJ/CB6cSLEfD/9bILTYxdim/PW1IECwdSma14KKi70WBMhgY//3KsnfotUwYHudSgi8FgSpLKFAKkvoxAt6LcmpKBvY2gs3nt9fzSkBbX5JQCXCYUkv2zKn44Bwx0FQ4FCWxwlzZylLs7S83FkKzJ2lvQRKuq6lC4KycSkIntI0GRR7eBlJGbSM7Rm0lK4MWpYqg5ZiY2MZtCyUQcuRZFCmshyWQcuRZNDSbGAsg5aDNr+8pAxa/v/OoOC5gS5HVg7t93QomjsrWJoV5eXOClhYRX3XTn1rBiXNCtATKwLr/3sNsP7jNJXDHetANaBOuGMD7OduKkPTqSRg/qxPp4qO6TTEplMFmk5lkulU1TGdRth0qkLTqUIynWo6ptMYm041aDpVSaZTXcd0mmDTqQ5NpxrJdGromE5TbDo1oOlUJ5lOTR3TaYZNpyY0nRok06mlYzrNsenUgqZTk2Q6tXVMpwU2ndrQdGoh06netqtfj36VfTv6B8eeyWoVy+8sJ7I8ws4e45XtMVsXNtbSH4H6b7PMe7GyD01rADSt2hR3XkcfNjBmZeoAzw/5sVo1uwXFDkauebHAH1BDHo4OVVdgHYHdYQMHQ8+vjamE9qQewZ7YxcCe1ItBthwqyJtH/ZicRzV582gQk/OoIW8eDWNyHrXkzaNRTM5D4jlvHJPzqCdvHk1ich4N5M2jaUzOo5G8eTSLyXk0kTeP5sA8bPpRfx/rD9B8Ht2C5gf92Z2zBbYeLQl+gJ89vSXyLZHOH3n/1pyNC9z3zc2hm10rSZ8dt/LSfZlVFwi5yvpgWwhN1xvYaGS63l76napTS7ZMaKA3dslvBUV5Q2vTWhIKrb30Mh39fcqtAapNahgyGR9Jk/HxEjBpbDI+2G/O8IEm00ZX2Ykl1xK3kTdUWxJLrK52MLSOLSXuSTtJ3y21EwSsHQZYO2gy7WMSsPbyhupAfa+BGNbcbDoS/QojJ3VsTHAnil9OpD6/k97bTSByShtjGw1h3RmYuo04dNaFQxcqHDqzsTHBXUlwYM/vqhuHIDhpW4/yFVhW66N2YtPC8mxXSKWf3vykfQVDXo0VfLmim6XZXd7LFd3AF9O6e/2ZTKwJYMsBvTfRDdq97jSAYw/v8ePhNr9s1sP2l826WZeiyXk9qV4268bGxl426wmh4k/yshlT6Y+9bOYvcDu2PqvubGDsZTN/aPN7STJWvbxsLb3ddZXe3lSlly1wb0xwH5LSy57fJ9DWumJr8lNLRR7RutLX0uwnr670xcL6eem/o7LVgMpKX2isfsDK6sfCl902sJ3tT5J3+rCBZX/8+UNvXzYyduD66z0WQknImmJNEhpAmIQGYLeNAdC0BlKlqoEYkwNjfOfUjyU1OzeIcOcGAb+LOFoNQ8YbTLVzgxVI5WCSM9+fIYEZsf4QX0OMwNc3DV9DCfkaCvD1TQ1Dxgug4itAgVQGkPA1mCGB8TUE4muYEfj6quFrOCFfwwG+vqphyHgjqPgaoUAqR5DwFcCQwPgaBvE10gh8fdHwNYqQr1EAX1/UMGS80VR8jVYglaNJ+BrBkMD4GgnxNcYIfH3W8DWWkK+xAF+f1TBkvHFUfI1TIJXjSPgazZDA+BoD8TXeCHx90vA1gZCvCQBfn9QwZLyJVHxNVCCVE0n4GseQwPgaD/E1yQh8fdTwNZmQr8kAXx/VMGS8QCq+AhVIJc1nRhMZEhhfkyC+FCPwFaXhK4iQryCAr6hw8G8FBVPxFaxAKoNJ+ApkSGDzxz7/mmIEvj5o+JpKyNdUgK8Pahgy3jQqvqYpkMppJHyxrwenYHxhv3RguhH4eq/hawYhXzMAvt6rYch4M6n4mqlAKmeS8DWNIYHxNR3ia5YR+Hqn4Ws2IV+zAb7eqWHIeHOo+JqjQCrnkPA1kyGB8TUL4muuEfh6q+HrX0K+/gX4equGIePNo+JrngKpnEfC1xyGBMbXXIiv+Ubg642GrwWEfC0A+HqjhiHjLaTia6ECqVxIwtc8hgTG13yIr0VG4Ou1hq/FhHwtBvh6rYYh4y2h4muJAqlcQsLXQoYExtciiK+lRuDrlYavZYR8LQP4eqWGIeOFUPEVokAqQ0j4WsKQwPhaCvG13Ah8vdTwFUrIVyjA10s1DBlvBRVfKxRI5QoSvkIYEhhfyyG+VhqBrxcavlYR8rUK4OuFGoaMt5qKr9UKpHI1CV8rGBIYXyshvtYYga/nGr7WEvK1FuDruRqGjLeOiq91CqRyHQlfqxkSGF9rIL7WG4GvZxq+NhDytQHg65kahoy3kYqvjQqkciMJX+sYEhhf6yG+NhmBr6cavjYT8rUZ4OupGoaMt4WKry0KpHILCV8bGRIYX5sgvrYaga8nGr62EfK1DeDriRqGjLediq/tCqRyOwlfWxgSGF9bIb52GIGvxxq+dhLytRPg67Eahoy3i4qvXQqkchcJX9sZEhhfOyC+dhuBr0cavvYQ8rUH4OuRGoaMt5eKr70KpHIvCV+7GBIYX7shvvYZga+HGr72E/K1H+DroRqGjHeAiq8DCqTyAAlfexkSGF/7IL4OGoGvBxq+DhHydQjg64Eahox3mIqvwwqk8jAJXwcYEhhfByG+jhiBr/savo4S8nUU4Ou+GoaMd4yKr2MKpPIYCV+HGRIYX0cgvo4bga97Gr5OEPJ1AuDrnhqGjBdGxVeYAqkMI+HrGEMC4+s4xFe4Efi6q+HrJCFfJwG+7qphyHgRVHxFKJDKCBK+whgSGF/hEF+njMDXHQ1fpwn5Og3wdUcNQ8Y7Q8XXGQVSeYaErwiGBMbXKYivs0bg67aGr3OEfJ0D+LqthiHjRVLxFalAKiNJ+DrDkMD4Ogvxdd4IfN3S8HWBkK8LAF+31DBkvItUfF1UIJUXSfiKZEhgfJ2H+LpkBL5uavi6TMjXZYCvm2oYMt4VKr6uKJDKKyR8XWRIYHxdgvi6agS+bmj4ukbI1zWArxtqGDLedSq+riuQyuskfF1hSGB8XYX4umEEvq5r+LpJyNdNgK/rahgy3i0qvm4pkMpbJHyxgW9gfN2A+LptBL6uafi6Q8jXHYCva2oYMt5dKr7uKpDKuyR8sYvdbYyv2xBf94zA11UNX/cJ+boP8HVVDUPGe0DF1wMFUvmAhC/2wdo9jK97EF8PjcDXFQ1fjwj5egTwdUUNQ8Z7TMXXYwVS+ZiEL/bF5kOMr4cQX0+MwNdlDV9PCfl6CvB1WQ1DxntGxdczBVL5jISvxwwJjK8nEF/PjcDXJQ1fLwj5egHwdUkNQ8Z7ScXXSwVS+ZKEr2cMCYyv5xBfr4zA10UNX68J+XoN8HVRDUPGe0PF1xsFUvmGhK+XDAmMr1cQX2+NwNcFDV/vCPl6B/B1QQ1DxntPxdd7BVL5noSvNwwJjK+3EF8fjMDXeQ1fUYR8RQF8nVfDkPE+UvH1UYFUfiTh6z1DAuPrA8TXJyPwFanh6zMhX58BviLVMGS8L1R8fVEglV9I+PrIkMD4+gTx9dUIfJ3T8PWNkK9vAF/n1DBkvGgqvqIVSGU0CV9fGBIYX18RvpxjGYGvsxa+nO3o+HK2A/g6q4YB4zmbiPhyNimQShMJX9EMCYgvFobwZTYCX2c0fNkT8mUP8HVGDUPW14GKLwcFUulAwZeziSGB8WWG+HI0Al+nNXw5EfLlBPB1Wg1D1teZii9nBVLpTMKXA0MC48sR4svFCHyd0vAVm5Cv2ABfp9QwZH1dqfhyVSCVriR8OTMkML5cIL7cBFRaiWdHwJUNDKg0qWGISnedKoMglepaIpvu7MYUQH9OwNlDvlDTj6QCCXVhCjChnvKFxv5RXSGhjkwBJjSOfKGOP66ZkFAzU4AJjUsiVPVbkFBVASY0HsVh+v7BA5RBvzIFmND4JELVT+AgoZ+YAkxoAvlCnX58FA0J/cAUYEITkghVv5OBhL5lCjChieQLtf/x5SQk9BVTgAlNLF+o+ce39JDQ50wBJjQJydarr6tAQp8wBZjQpCQrqr63BQl9yBRgQpORrOitcKfbkNB7TAEmNDlJHlXf5IWE3mYKMKH/kGy9+ko7JPQGU4AJTUFxzfv+sx2Q0KtMASY0JcmlRP0hJ0joJaYAE5qKJOGrP+0HCT3PFGBCvUhWVP2xV0go++DVCxOamuQwqT//DQllDjg1JjSNfKF2P34RAhQYzhRgQtOS5FH1N4JAQo8zBZjQdCRC1V+NAwk9whRgQtOTMLo33GkfJPQgU4AJzUBy6tVflgYJ3ccUYEIzklQm9bcGQkJ3MwWY0Ewktyf112dCQncwBZjQzCQrqv4eWUjoVqYAE5qFROi6cKf1kNBNTAEmNCtJwld/szgUuJ4pwIRmI0lP6q/Yh4SuYQowodlJbk/q35qAhK5kCjChOUi2Xv2jK1DgcqYAE5qTZOvVvz4ECV3KFGBCc5GcevXPcEFCFzEFmNDcJFuv/j06KHA+U4AJzUNS69U/zAgJncsUYELzkjCq/oVSSOgspgATmo9k69U/1QsFTmcKMKH5SYSqf7MaCpzCFGBCC5Dc8NU/3g4JVZgCTGhBkhUdF+40HgqcxBRgQguRHKbR4U5jIKHjmQJMaGGSFR0R7jQSChzDFGBCi5CsaEC40zBI6EimABNalGRFB4c7DYEChzEFmNBigNBfXgYxB/18GQQSbdpfEwo7EG46GgiI+fkmyt+D7dT/BFneMSluaZbAXjdZW6aLt0/nMn59K/Ty9VGnHrCkTukaFcsHBSxr2NHft23PnmzUsOtQXAmvX3Y70Mofeg96+f371+LQDpZAXt1wh/5AlLveP9AUGARJxCZS8sfD/xYILXZJtil/fX8JEGxdiub9pVJi7y8BMtjY/73z8rdoNQzYXufSAu8vQSpLK5DK0jrxgq44ziXYwNbeDPKMjo5Ww5D5lAFUIhyW8bIlczKz3D/caSCU7oewPE6YO8tamuXk5c6yYO4s5yXwOYOupQuCsnFZCJ5yNBkUe3h5SRm0vO0ZtKyuDFqBKoOWZWNjGbQClEErkmRQprIilkErkmTQcmxgLINWhDa/kqQMWun/zqDguYEuR1YO7fd0KJo7K1uaVeTlzspYWBV91059awYlzcrQE6sA6/97DbD+cz+Vwp1qQzWgdrhTfewH0CpB06kqYP6sT6eyjuk0wKaD7U41kulU0TGdhth0qkDTqU4ynao6ptMIm05VaDo1SKZTTcd0GmPTqQZNpybJdKrrmE4TbDrVoenUIplODR3TaYpNpwY0ndok06mpYzrNsOnUhKZTh2Q6tXRMpzk2nVrQdOoi06netqtfj36VfTv6B7vOZLWK5XeWE1keYWeP8cr2mK0LG2vpj0D9t1nmvVjZh6bVH5pWPYo7r1NrNjBmZeoDzw/5sVo1uwW5BiPXvFjgT9IhD0eHaiCwjsDusIGDoefXw1RCe9KQYE/sYmBPGsYgWw4V5M2jUUzOo5q8eTSOyXnUkDePJjE5j1ry5tE0JudRR948msXkPOrJm0fzmJxHA3nzaBGT82gkbx4tY3IeTeTNoxUwD9s+kbYHTrPmE2lvok+k7dnd2htbk9YUnzWrz2+NfFek9+0EVzYuICAFC0M+unUFlkjvj0yBnxm3hqJ8dNIBeUfVjtWDPrJn127sYyRn7GOkNiRfLPiwgTGT1ZbAijuxYQGZKVlYoMD0AUbY9LFN8oEWqR3BIrmxYbFFahdohCRtp0nS7QmTdHts49pDUR2oUnkHBX2+lSD9Cd+dDQvITMXCkLzrDkwkFU3C7wBFdSRJ+NV0JHzsg3Zn7IP2TiQJvyMbGEv4nWkSfmdAphcLo0n46vSxTeoILVIXgkXyYMNii9TFEAnfpEn4XQkTflfst0t1hbbXlyrh+yqQSl+ChO/JhgVkpmZhSN71BBYyNU3C94Wi/EgSfnUdCR/7KtIZ+yqyG0nC92MDYwm/O03C7w7ITMPCaBK+On1sk/ygRepBsEhx2LDYIvUwRMI3axJ+T8KE3xPYOLMahmyvP1XC91cglf4ECT8uGxaQmZaFIXk3LrCQaWkSvj8U1Ysk4dfQkfCxlzWcsZc1epMk/F5sYCzh96FJ+H0AmelYGE3CV6ePbVIvaJH6EixSPDYstkh9DZHw7TUJvx9hwu8HbJy9GoZsb3+qhN9fgVT2J0j48dmwgMz0LAzJu/GBhUxPk/CxN4sGkCT8mjoSPvY6mzP2OttAkoQ/gA2MJfxBNAl/ECAzAwujSfjq9LFNGgAt0mCCRUrAhsUWabAhEr6DJuEPIUz4Q4CNc1DDkO0dSpXwhyqQyqEECT8hGxaQmZGFIXk3IbCQGWkS/lAoKoAk4dfSkfCxF36dsRd+h5Ek/AA2MJbwh9Mk/OGAzEwsjCbhq9PHNikAWqQRBIuUiA2LLdIIQyR8R03CH0mY8EcCG+eohiHbO4oq4Y9SIJWjCBJ+YjYsIDMzC0PybmJgITPTJPxRUNRokoRfW0fCb4HlktrQdMaQJPzRbGAs4Y+lSfhjAZlZWBhNwlenj23SaGiRxhEsUhI2LLZI4wyR8J00CX88YcIfD2yckxqGbO8EqoQ/QYFUTiBI+EnZsIDMrCwMybtJgYXMSpPwJ0BRE0kSfh0dCb8llkvqQNOZRJLwJ7KBsYQ/mSbhTwZkZmNhNAlfnT62SROhRQokWKRkbFhskQINkfCdNQlfIUz4CrBxzuHO2GuRQVQJP0iBVAYRJPzkbFhAZnYWhuTd5MBCZqdJ+FhUMEnCr6sj4bfCckldaDpTSBJ+MBsYS/hTaRL+VEBmDhZGk/DV6WObFAwt0jSCRfqHDYst0jTdCT+Wzj/gCvydUc2vOJpuac7Qn/kDkR8ed4W2ZfqfUc1+i2JbPMPWcmlN7PdH/K7jQ8TMyBmjT7Ufr6y55jt42WJNuZxJ9OdvnWewsTlJ9A8tahgy3iyBcgmpnKVAKmfZyv3v6r3Mw1LGK10qKqLnku4tBi9bwn3E7/9IQ/5sS3OOvF/uNTtsKBQ3h8X9cZKAKUJnaTZ0luZYX65fd8Qu6K+/SO33J+g9eLOtE6I5eHPl7dlcO+tbwV/k3x/3+/PZ2NBY/1pdTex37v2LUPXn4+dAUdhU5gFUIVOZx6byf+UD6HdXO89iRQW6YbDAGXBtsBKkra3zLc0F8midD2aYBb+xgC3adLYc0KKpmR/71TEzIG7mQzlrgd4qQpyz5uvKWQvlUbBQKGfNh3LWQmisRZJy1iKxnLUAisKmslhSzlr8e87S0ietCNIyukQeo0vs/vwNptYG5l5ehEleAo21FLgaI/Nd+jvJ2ITnSOQdm/AyADJkwsv+UqMhON101dMQS3M5kVd1g9YvBKpVy+m96nJdXjWUyqsuZ2NjXjUUmtYKEq/KVK7AvOoKeq+6QpdXXWlprpKXn1eCN8lVYl51BXSWVkJnaZXBvOpKXTV1tbw9Wy1071sJVcvV0FhrJN371ojd+1ZBUdhU1kq696212auuYEUFsl0scDlcG6wEaWvrOktzvTxa14EZZr2QVw1hywEtmpr5Ma+6HOJmHZSz1hvMq67TlbM2yKNgg1DOWgflrA3QWBsl5ayNYjlrPRSFTWWTpJy1yXavChRBWkY3y2N0s5BXXSmR5M3QWFskedUtYl51lUTesQlvleRVt9rqVd111dNtluZ2Iq/qDq3fNqhWbaf3qtt1edUdVF51Oxsb86o7oGntJPGqTOVOzKvupPeqO3V51V2W5m55+XkXeJPcLeZVd0JnaRd0lnYbzKvu0lVT98jbsz1C975dULXcA421V9K9b6/YvW83FIVNZZ+ke98+m73qTlZUINvFArfDtcFKkLa27rc0D8ijdT+YYQ4IedVtbDmgRVMzP+ZVt0Pc7Idy1gGDedX9unLWQXkUHBTKWfuhnHUQGuuQpJx1SCxnHYCisKkclpSzDtvuVYEiSMvoEXmMHhHyqrskknwEGuuoJK96VMyr7pbIOzbhY5K86jFbvaqHrnp63NI8QeRVPaD1Ow7VqhP0XvWELq8aRuVVT7CxMa8aBk0rnMSrMpXhmFcNp/eq4bq86klLM0Jefj4J3iQjxLxqOHSWTkJnKcJgXvWkrpp6St6enRK6952EquUpaKzTku59p8XufRFQFDaVM5LufWds9qrhrKhAtosFnoBrg5UgbW09a2mek0frWTDDnBPyqsfZckCLpmZ+zKuegLg5C+Wscwbzqmd15axIeRRECuWss1DOioTGOi8pZ50Xy1nnoChsKhck5awLtntVoAjSMnpRHqMXhbzqSYkkX4TGuiTJq14S86oREnnHJnxZkle9bKtX9dRVT69YmleJvKontH5XoFp1ld6rXtXlVa9RedWrbGzMq16DpnWdxKsyldcxr3qd3qte1+VVb1iaN+Xl5xvgTfKmmFe9Dp2lG9BZumkwr3pDV029JW/Pbgnd+25A1fIWNNZtSfe+22L3vptQFDaVO5LufXds9qrXWVGBbBcLvArXBitB2tp619K8J4/Wu2CGuSfkVa+w5YAWTc38mFe9CnFzF8pZ9wzmVe/qyln35VFwXyhn3YVy1n1orAeSctYDsZx1D4rCpvJQUs56aLtXBYogLaOP5DH6SMir3pBI8iNorMeSvOpjMa96UyLv2ISfSPKqT2z1qnF01dOnluYzIq8aB1q/p1CtekbvVZ/p8qrPqbzqMzY25lWfQ9N6QeJVmcoXmFd9Qe9VX+jyqi8tzVfy8vNL8Cb5SsyrvoDO0kvoLL0ymFd9qaumvpa3Z6+F7n0voWr5GhrrjaR73xuxe98rKAqbyltJ9763NnvVF6yoQLaLBT6Da4OVIG1tfWdpvpdH6zsww7wX8qpP2XJAi6ZmfsyrPoO4eQflrPcG86rvdOWsD/Io+CCUs95BOesDNFaUpJwVJZaz3kNR2FQ+SspZH233qkARpGX0kzxGPwl51ZcSSf4EjfVZklf9LOZVX0nkHZvwF0le9YutXjWurnr61dL8RuRV40Lr9xWqVd/oveo3XV41msqrfmNjY141GpmWSywSr/qNDQx5VfX5Voaz1avyHvF/e1UXO0vTJC0/u9hhN0kXk5BXdYmFnCUXO+QsuZiM5VVd7PTUVBezvD0zi9z7vi/y74/7/flsbGgsezn3Phd7oXufiwmKwqbiIOfe5+Jgq1d1UYsKYrvUwG9wbbASpKmtLo6WppM8Wh3BDOMk5FW/suWAvKqa+TGv+g3ixhHKWU7G8qoujrpylrM8CpyFcpYjlLOcobFcJOUsF7Gc5QRFYVOJLSlnxbbZqyJFkJZRV3mMuop4Vd7lRZhk6E+QuLjJ8aoubkJeFay+GO/YhIFfaQRN2N1WrxpPVz31sDQ9ibxqPGj9PKBa5am3Vun2quojcK/qEofIq7p4srEhr+oSB5pWXAqvqqqMi3nVuHp3Tr9XjavLq8azNOPLy8/xwJtkfDGvCn3u4xIPOkvxDeZV4+mqqQnk7VkCoXtfPKhaJoDGSijp3pdQ7N4XH4rCppJI0r0vkc1eNS4rKpBXZYGecG2wEqStrYktzSTyaE0MZpgkIl7VxYMtB7RoauYPxhYN4iYxlLOSGMyrJtaVs5LKoyCpUM5KDOWspNBYySTlrGRiOSsJFIVNJbmknJXcdq8KFEFaRv+Rx+g/Ql41nkSS/4HGSiHJq6YQ86rxJfKOTTilJK+a0lavGl9XPU1laXoReVVsL1JBtcqL3qt66fKqqam8qhcbG/OqqaFppSHxqkxlGsyrpqH3qml0edW0lmY6efk5LXiTTCfmVdNAZyktdJbSGcyrptVVU9PL27P0Qve+tFC1TA+NlUHSvS+D2L0vHRSFTSWjpHtfRpu9ahpWVCDbxQK94NpgJUhbWzNZmpnl0ZoJzDCZhbxqKrYc0KKpmR/zql4QN5mgnJXZYF41k66clUUeBVmEclYmKGdlgcbKKilnZRXLWZmhKGwq2STlrGy2e1WgCNIyml0eo9mFvGpaiSRnh8bKIcmr5hDzqukk8o5NOKckr5rTVq+aQFc9zWVp5ibyqtjn8bmgWpWb3qvm1uVV81B51dxsbMyr5oGmlZfEqzKVeTGvmpfeq+bV5VXzWZr55eXnfOBNMr+YV80LnaV80FnKbzCvmk9XTS0gb88KCN378kHVsgA0VkFJ976CYve+/FAUNpVCku59hWz2qnlZUYFsFwvMDdcGK0Ha2lrY0iwij9bCYIYpIuRVc7HlgBZNzfyYV80NcVMYyllFDOZVC+vKWUXlUVBUKGcVhnJWUWisYpJyVjGxnFUEisKmUlxSzipuu1cFiiAtoyXkMVpCyKvmk0hyCWiskpK8akkxr5pfIu/YhEtJ8qqlbPWqCXXV09KWZhkir5oQWr/SUK0qQ+9Vy+jyqmWpvGoZNjbmVctC0ypH4lWZynKYVy1H71XL6fKq5S3NCvLyc3nwJllBzKuWg85SeegsVTCYVy2vq6ZWlLdnFYXufeWhalkRGquSpHtfJbF7XwUoCptKZUn3vso2e9VyrKhAtosFloFrg5UgbW2tYmlWlUdrFTDDVBXyqqXZckCLpmZ+zKuWgbipAuWsqgbzqlV05axq8iioJpSzqkA5qxo0VnVJOau6WM6qCkVhU6khKWfVsN2rAkWQltGa8hitKeRVy0skuSY0Vi1JXrWWmFetIJF3bMK1JXnV2rZ61US66mkdS7MukVdNBK1fHahW1aX3qnV1edV6VF61Lhsb86r1oGnVJ/GqTGV9zKvWp/eq9XV51QaWZkN5+bkBeJNsKOZV60NnqQF0lhoazKs20FVTG8nbs0ZC974GULVsBI3VWNK9r7HYva8hFIVNpYmke18Tm71qfVZUINvFAuvCtcFKkLa2NrU0m8mjtSmYYZoJedU6bDmgRVMzP+ZV60LcNIVyVjODedWmunJWc3kUNBfKWU2hnNUcGquFpJzVQixnNYOisKm0lJSzWtruVYEiSMtoK3mMthLyqg0kktwKGstbklf1FvOqDSXyjk24tSSv2tpWr5pYVz31sTTbEHnVxND6+UC1qg29V22jy6u2pfKqbdjYmFdtC02rHYlXZSrbYV61Hb1XbafLq7a3NDvIy8/twZtkBzGv2g46S+2hs9TBYF61va6a2lHennUUuve1h6plR2isTpLufZ3E7n0doChsKp0l3fs62+xV27GiAtkuFtgGrg1WgrS1tYul2VUerV3ADNNVyKv6sOWAFk3N/JhXbQNx0wXKWV0N5lW76MpZvvIo8BXKWV2gnOULjeUnKWf5ieWsrlAUNpVuknJWN9u9KlAEaRntLo/R7kJetb1EkrtDY/WQ5FV7iHnVDhJ5xybcU5JX7WmrV02iq576W5q9iLwq9hus/KFa1Yveq/bS5VV7U3nVXmxszKv2hqbVh8SrMpV9MK/ah96r9tHlVftamv3k5ee+4E2yn5hX7QOdpb7QWepnMK/aV1dN7S9vz/oL3fv6QtWyPzTWAEn3vgFi975+UBQ2lYGS7n0DbfaqfVhRgWwXC+wF1wYrQdraOsjSHCyP1kFghhks5FX92XJAi6Zmfsyr9oK4GQTlrMEG86qDdOWsIfIoGCKUswZBOWsINNZQSTlrqFjOGgxFYVMJkJSzAmz3qkARpGV0mDxGhwl51b4SSR4GjTVcklcdLuZV+0nkHZvwCEledYStXjWprno60tIcReRVsd8bPhKqVaPoveooXV51NJVXHcXGxrzqaGhaY0i8KlM5BvOqY+i96hhdXnWspTlOXn4eC94kx4l51THQWRoLnaVxBvOqY3XV1PHy9my80L1vLFQtx0NjTZB075sgdu8bB0VhU5ko6d430WavOoYVFch2scBRcG2wEqStrZMszcnyaJ0EZpjJQl51JFsOaNHUzI951VEQN5OgnDXZYF51kq6cFSiPgkChnDUJylmB0FiKpJyliOWsyVAUNpUgSTkryHavChRBWkaD5TEaLORVx0okGUNpiiSvOkXMq46TyDs24amSvOpUW71qMl31dJqlOZ3IqyaD1m8aVKum03vV6bq86gwqrzqdjY151RnQtGaSeFWmcibmVWfSe9WZurzqLEtztrz8PAu8Sc4W86ozobM0CzpLsw3mVWfpqqlz5O3ZHKF73yyoWs6Bxpor6d43V+zeNxuKwqbyr6R73782e9WZrKhAtosFTodrg5UgbW2dZ2nOl0frPDDDzBfyqtPYckCLpmZ+zKtOh7iZB+Ws+QbzqvN05awF8ihYIJSz5kE5awE01kJJOWuhWM6aD0VhU1kkKWctst2rAkWQltHF8hhdLORVZ0kkeTE01hJJXnWJmFedLZF3bMJLJXnVpbZ61eS66ukySzOEyKsmh9ZvGVSrQui9aogur7qcyquGsLExr7ocmlYoiVdlKkMxrxpK71VDdXnVFZbmSnn5eQV4k1wp5lVDobO0AjpLKw3mVVfoqqmr5O3ZKqF73wqoWq6Cxlot6d63WuzetxKKwqayRtK9b43NXjWUFRXIdrHAELg2WAnS1ta1luY6ebSuBTPMOiGvuowtB7RoaubHvGoIxM1aKGetM5hXXasrZ62XR8F6oZy1FspZ66GxNkjKWRvEctY6KAqbykZJOWuj7V4VKIK0jG6Sx+gmIa+6QiLJm6CxNkvyqpvFvOpKibxjE94iyatusdWr/qOrnm61NLcRedV/oPXbCtWqbfRedZsur7qdyqtuY2NjXnU7NK0dJF6VqdyBedUd9F51hy6vutPS3CUvP+8Eb5K7xLzqDugs7YTO0i6DedWdumrqbnl7tlvo3rcTqpa7obH2SLr37RG79+2CorCp7JV079trs1fdwYoKZLtY4Da4NlgJ0tbWfZbmfnm07gMzzH4hr7qVLQe0aGrmx7zqNoibfVDO2m8wr7pPV846II+CA0I5ax+Usw5AYx2UlLMOiuWs/VAUNpVDknLWIdu9KlAEaRk9LI/Rw0JedadEkg9DYx2R5FWPiHnVXRJ5xyZ8VJJXPWqrV82pq54eszSPE3nVnND6HYNq1XF6r3pcl1c9QeVVj7OxMa96AppWGIlXZSrDMK8aRu9Vw3R51XBL86S8/BwO3iRPinnVMOgshUNn6aTBvGq4rpoaIW/PIoTufeFQtYyAxjol6d53SuzedxKKwqZyWtK977TNXjWMFRXIdrHA43BtsBKkra1nLM2z8mg9A2aYs0Je9RhbDmjR1MyPedXjEDdnoJx11mBe9YyunHVOHgXnhHLWGShnnYPGipSUsyLFctZZKAqbynlJOeu87V4VKIK0jF6Qx+gFIa8aLpHkC9BYFyV51YtiXvWkRN6xCV+S5FUv2epVc+mqp5ctzStEXjUXtH6XoVp1hd6rXtHlVa9SedUrbGzMq16FpnWNxKsyldcwr3qN3qte0+VVr1uaN+Tl5+vgTfKGmFe9Bp2l69BZumEwr3pdV029KW/Pbgrd+65D1fImNNYtSfe+W2L3vhtQFDaV25Lufbdt9qrXWFGBbBcLvALXBitB2tp6x9K8K4/WO2CGuSvkVS+z5YAWTc38mFe9AnFzB8pZdw3mVe/oyln35FFwTyhn3YFy1j1orPuSctZ9sZx1F4rCpvJAUs56YLtXBYogLaMP5TH6UMirXpdI8kNorEeSvOojMa96QyLv2IQfS/Kqj231qnl11dMnluZTIq+aF1q/J1CtekrvVZ/q8qrPqLzqUzY25lWfQdN6TuJVmcrnmFd9Tu9Vn+vyqi8szZfy8vML8Cb5UsyrPofO0gvoLL00mFd9oaumvpK3Z6+E7n0voGr5ChrrtaR732uxe99LKAqbyhtJ9743NnvV56yoQLaLBT6Fa4OVIG1tfWtpvpNH61sww7wT8qpP2HJAi6ZmfsyrPoW4eQvlrHcG86pvdeWs9/IoeC+Us95COes9NNYHSTnrg1jOegdFYVOJkpSzomz3qkARpGX0ozxGPwp51RcSSf4IjfVJklf9JOZVX0rkHZvwZ0le9TO3FK2u3quLf8e6Pt5dvHuw5pSrscoEhJT18+3p7+3rf9DLuUS/uBfzu/TO/NKxV+4vCY9/7Rcy+/mJwoElOzbM5uNXpYk2NtmQFp9WDcndLP3yJG/cjl7IWzJsRf8LxzwTXA/YeSjTx+Dm2lirM9LEOlQJ6dTzxLh8dVo03X3+btEFSSeN8mxZuFaGyd1vlFd23TVpY73mRuzJ9rnhx/f2fuUuJDv8KapHvTVHSg20f9I6WevRx/dlENXwT7nXS7wGBuwfNzz1koBmD9fljpNux7P4SZLuuPxu4aqQipW0sebQ5wXul8mSwk7xyXK48axHT5aszJY45JhXaLE148ceigoR1ZDh4rpEbh1SL3Jr+/5ExXhVvtntn1e20NvqVeId+xKR5rPf+l/W7Ihb0Tnu6Rfvi3Vn4YA3YQVbjosKv1R50kHnWcOK+7c5Hi2qwevZnE4pMmb8p9yMPScd+kbOXbdqd+jofB8+hbkMmD2zZoSvNjZz+KCCLoU2NDqcrUqsD0Xc46xYdi90fkX7+d1Ljk25e1va7qIaTOlCVhw+ujXS3PN8tTMLViRsv6dg1qKpBoxKMcQufbc6Z4drY9M2aj078PHnzHPb1VoU98HMBGtTt1i7LDDANcPlJsPaZ7gQV1SDZxy/rhV2BlapE1gvXeD614X6tHxzsPz6qA/2B9u1bVkhdpZf1mHFiHM9Xp0tWeaby8EBk/vEeZnU63zCOrXitc99d9ToAREZhddhxuu7aSq/rD1n3LhdSoPBu+18K3mmnj0haYUUnRo3O1Bg2i9MNn1adaTX4qe3B0SGftp958atwu7+hQ8mDTnU5OR6p9CjRUU1ZJuWqeLcu0lSLhs8wCV+2NsUWfwTNk0xZ9jjhV77k/RN5ffLuBknj9r6dWod1+YLiz5P1iJ/9UNX154oe36Lb+uJV6LX2V3oLarB9ZbiVyhH/jyhdZe1++a/bvnwvtVCt5kCVy/b4935QPfPpX/Zt7b1ajk8nPaqTOWpPuU+fVx1rXfWXj0Xj940eWiTAimCYnuJasgcPaLg6qZPx85IUHp9rgILsw6J3P3oxcuHxdwjtw743PS8hzY21ZmK+bP2ud2+c5oraSMGnhtWsWa9EvmGblo0p0xU4UWOu+OIashZ9NyjyRNGNApvNGZ05Zfv7g1bnL9t754zbk6q9ajq7KSLL/2ioW5lx9Oh46suq3LpTlSTO1GZW9R+vOZ00+ZxO9ht82nl1VRUQ8ZegTPept/SpuL+QxkzNexgXrCy+Z0B20c3OTjwanTdWdtya2NjLx58v3q8iw0itiZv3CxFq5NPNwe//Lq6TcUK0XlLFH6fYouoBrtmIedHJfr6sIvifOeK/bsxN98433cvMHha0UEVPB8tbdHlF34/Jok19/KULMciZ5rDs5umXOw5OXh8/CmJ3cdmMQ3yzDdAVIN74uGR6xv0rp/wzbEZEz++2j7Yr+XadBPGdv98yBwdmaRPAm1sjh1la74dOeRA61RFDxzeGitr4lPZ53jV6PVq9mTXmY87lMomqiGXp9eUHAVXrJvq9TH3hz0DO28/VqKc97K+0/p8HHWn3Ol397SxcXss3ex/uPPagnHm7agefO740Ho75l52Hj7Le+yThiPjxu0qqiH+0g0BS31Cx/UadHbUopApg8p38F/U4F3Oca8WXay6wHFwqDY2TaV6sTyXH/EYXXJdlQt7T6WI6Prujck7b/HOPkfGDVqyqJKohqwFr7bYeCDqxNKcsUY+jR+n7uP7SZKV6BmSY1C/3lVMeaeE/cLv0cT7CrbOtGj5u5VdVkf2bbho+5Kh8/dtiZ34Q5NOW24XHChcu1f/c7Du5Q2vIyrFCSu59UO8hoXy5g2tWeTkpM1zxi/+1HyBNjbTnj1D6yW/XvDRlbhFbj2xn/PKJ7rG8rbVvd9mmbozh2viXaIaPDK37rR5t3/pQc7rJ0yetMf0tVvKTKfPDUjq/SDRg/w3s8f7hYd59c/v+dx5e0Cff9fMeBPnULsUIwsPcKn5+dqO0p8zVHUWztUOzS7XfRDw5vm13q4LD07oWuDMfO961YrnfeAda1e1tg+n/7LHmQqnHDu3jdNd05RPS+41SLaxx90SSyKrJcxXdFbFE/2HPnMR1ZA9alupe2M9asTvc7Nuz0/3Z6XoVbNj/vvLhm5uN8U/9+vw8F/OZviY043b76y7daSSwz3RKO96KzeH7j8b1SLj8cEv1u8LHK5Hw9VY2SzXcefpmvYMTTtE016uaW/TtLdr2sc17ROa9hVN+6qm/VTTfqZpf9W0v2lsg4em7alpp9K0vTTtXJp2bk27tKZdRtOuo2nX1bR9NO02mra/pt1L0x6paY/StKdp2po1d1mmaWvW3GWrpq1Zc5djmrZmzV0ua9qaNWff1VnaT3VgklAUayuhdsHhLl/CXb6Gu3z71fcGAS7UBHnjL7Z+a2TtESl0faIb/bMZOxbRt6UpIAcfjXxaGjsW+bel6iPwb0tj2xF9Wxo7Fhsb+raUhSHjmSi+LVVVmqBvS9XnWxnO1m9LeY/4v78tjW22NO2lfUIY24x9lxHbXujb0tgm5CzFNkNnyd5Y35bGNuv5VDe2g7w9cxD55uH7Iv/+uN+fz8aGxnKU881DbEehbx5i20NR2FSc5HzzENvJ1m9LY5tYUUG++GOBsWPBtcFKkKa2xna2NF3k0eoMZhgXoW9Lo9lyQIumrlswtmgQN85QznIx1relsZ115azY8iiILZSznKGcFRsay1VSznIVy1kuUBQ2FTdJOcvN5m9LkSJIy6i7PEbdRb4t5V1ehEl2h8bykPNtaWwPoW9LweqL8Y5N2FPOt6WxPW19szelrnoax9KMS+RVU0LrFweqVXHpvWpcXV41HpVXjcvGxrxqPGha8Um8KlMZH/Oq8em9anxdXjWBpZlQXn5OAN4kE4p51fjQWUoAnaWEBvOqCXTV1ETy9iyR0L0vAVQtE0FjJZZ070ssdu9LCEVhU0ki6d6XxGavGp8VFch2scC4cG2wEqStrUktzWTyaE0KZphkIl41dhy2HNCiqZkf86pxIW6SQjkrmd4qQpyzkurKWcnlUZBcKGclhXIW9KcDY/8jKWf9I5azkkFR2FRSSMpZKWz3qkARpGU0pTxGUwp51QQSScasRypJXjWVmFdNKJF3bMJekryql61eNZWuepra0kxD5FVTQeuXGqpVaei9ahpdXjUtlVdNw8bGvGpaaFrpSLwqU5kO86rp6L1qOl1eNb2lmUFefk4P3iQziHnVdNBZSg+dpQwG86rpddXUjPL2LKPQvS89VC0zQmNlknTvyyR278sARWFTySzp3pfZZq+ajhUVyHaxwDRwbbASpK2tWSzNrPJozQJmmKxCXjU1Ww5o0dTMj3nVNBA3WaCcldVgXjWLrpyVTR4F2YRyVhYoZ2WDxsouKWdlF8tZWaEobCo5JOWsHLZ7VaAI0jKaUx6jOYW8anqJJEN/WCR2LkleNZeYV80gkXdswrkledXctnpVL131NI+lmZfIq3pB65cHqlV59dYq/V41ry6vmo/Kq+ZlY2NeNR80rfwkXpWpzI951fz0XjW/Lq9awNIsKC8/FwBvkgXFvGp+6CwVgM5SQYN51QK6amoheXtWSOjeVwCqloWgsQpLuvcVFrv3FYSisKkUkXTvK2KzV83Pigpku1hgXrg2WAnS1tailmYxebQWBTNMMSGvmoctB7RoaubHvCr0GxNjF4VyVjGDedWiunJWcXkUFBfKWUWhnFUcGquEpJxVQixnFYOisKmUlJSzStruVYEiSMtoKXmMlhLyqgUkklwKGqu0JK9aWsyrFpTIOzbhMpK8ahlbvWpqXfW0rKVZjsirpobWryxUq8rRe9VyurxqeSqvWo6NjXnV8tC0KpB4VaayAuZVK9B71Qq6vGpFS7OSvPxcEbxJVhLzqhWgs1QROkuVDOZVK+qqqZXl7VlloXtfRahaVobGqiLp3ldF7N5XCYrCplJV0r2vqs1etQIrKpDtYoHl4NpgJUhbW6tZmtXl0VoNzDDVhbxqWbYc0KKpmR/zquUgbqpBOau6wbxqNV05q4Y8CmoI5axqUM6qAY1VU1LOqimWs6pDUdhUaknKWbVs96pAEaRltLY8RmsLedWKEkmuDY1VR5JXrSPmVStJ5B2bcF1JXrWurV5V33tK9SzN+kReFXsHqB5Uq+rTe9X6urxqAyqvWp+NjXnVBtC0GpJ4VaayIeZVG9J71Ya6vGojS7OxvPzcCLxJNhbzqg2hs9QIOkuNDeZVG+mqqU3k7VkToXtfI6haNoHGairp3tdU7N7XGIrCptJM0r2vmc1etSErKpDtYoH14dpgJUhbW5tbmi3k0doczDAthLxqPbYc0KKpmR/zqvUhbppDOauFwbxqc105q6U8CloK5azmUM5qCY3VSlLOaiWWs1pAUdhUvCXlLG/bvSpQBGkZbS2P0dZCXrWRRJJbQ2P5SPKqPmJetbFE3rEJt5HkVdvY6lXT6qqnbS3NdkReNS20fm2hWtWO3qu20+VV21N51XZsbMyrtoem1YHEqzKVHTCv2oHeq3bQ5VU7Wpqd5OXnjuBNspOYV+0AnaWO0FnqZDCv2lFXTe0sb886C937OkLVsjM0VhdJ974uYve+TlAUNpWuku59XW32qh1YUYFsFwtsB9cGK0Ha2uprafrJo9UXzDB+Ql6Vae0ALZqa+TGv2g7ixhfKWX4G86q+unJWN3kUdBPKWb5QzuoGjdVdUs7qLpaz/KAobCo9JOWsHrZ7VaAI0jLaUx6jPYW8akeJJPeExvKX5FX9xbxqJ4m8YxPuJcmr9rLVq6bTVU97W5p9iLwq9vtgekO1qg+9V+2jy6v2pfKqfdjYmFftC02rH4lXZSr7YV61H71X7afLq/a3NAfIy8/9wZvkADGv2g86S/2hszTAYF61v66aOlDeng0Uuvf1h6rlQGisQZLufYPE7n0DoChsKoMl3fsG2+xV+7GiAtkuFtgHrg1WgrS1dYilOVQerUPADDNUyKv2ZssBLZqa+TGv2gfiZgiUs4YazKsO0ZWzAuRRECCUs4ZAOSsAGmuYpJw1TCxnDYWisKkMl5SzhtvuVYEiSMvoCHmMjhDyqv0lkjwCGmukJK86UsyrDpDIOzbhUZK86ihbvWp6XfV0tKU5hsirYr/YazRUq8bQe9UxurzqWCqvOoaNjXnVsdC0xpF4VaZyHOZVx9F71XG6vOp4S3OCvPw8HrxJThDzquOgszQeOksTDOZVx+uqqRPl7dlEoXvfeKhaToTGmiTp3jdJ7N43AYrCpjJZ0r1vss1edRwrKpDtYoFj4NpgJUhbWwMtTUUerYFghlGEvOpothzQoqmZH/OqYyBuAqGcpRjMqwbqyllB8igIEspZgVDOCoLGCpaUs4LFcpYCRWFTmSIpZ02x3asCRZCW0anyGJ0q5FXHSyR5KjTWNEledZqYV50gkXdswtMledXptnrVDLrq6QxLcyaRV8V+J/MMqFbNpPeqM3V51VlUXnUmGxvzqrOgac0m8apM5WzMq86m96qzdXnVOZbmXHn5eQ54k5wr5lVnQ2dpDnSW5hrMq87RVVP/lbdn/wrd++ZA1fJfaKx5ku5988TufXOhKGwq8yXd++bb7FVns6IC2S4WOBOuDVaCtLV1gaW5UB6tC8AMs1DIq85gywEtmpr5Ma86E+JmAZSzFhrMqy7QlbMWyaNgkVDOWgDlrEXQWIsl5azFYjlrIRSFTWWJpJy1xHavChRBWkaXymN0qZBXnSOR5KXQWMskedVlYl51rkTesQmHSPKqIbZ61Yy66ulySzOUyKtif5dvOVSrQum9aqgur7qCyquGsrExr7oCmtZKEq/KVK7EvOpKeq+6UpdXXWVprpaXn1eBN8nVYl51JXSWVkFnabXBvOoqXTV1jbw9WyN071sFVcs10FhrJd371ord+1ZDUdhU1km6962z2auuZEUFsl0sMBSuDVaCtLV1vaW5QR6t68EMs0HIqy5nywEtmpr5Ma8aCnGzHspZGwzmVdfrylkb5VGwUShnrYdy1kZorE2SctYmsZy1AYrCprJZUs7abLtXBYogLaNb5DG6RcirrpJI8hZorK2SvOpWMa+6WiLv2IS3SfKq22z1qpl01dPtluYOIq+aCVq/7VCt2kHvVXfo8qo7qbzqDjY25lV3QtPaReJVmcpdmFfdRe9Vd+nyqrstzT3y8vNu8Ca5R8yr7oLO0m7oLO0xmFfdraum7pW3Z3uF7n27oWq5Fxprn6R73z6xe98eKAqbyn5J9779NnvVXayoQLaLBe6Aa4OVIG1tPWBpHpRH6wEwwxwU8qrb2XJAi6Zmfsyr7oC4OQDlrIMG86oHdOWsQ/IoOCSUsw5AOesQNNZhSTnrsFjOOghFYVM5IilnHbHdqwJFkJbRo/IYPSrkVXdLJPkoNNYxSV71mJhX3SORd2zCxyV51eO2etXMuurpCUszjMirZobW7wRUq8LovWqYLq8aTuVVw9jYmFcNh6Z1ksSrMpUnMa96kt6rntTlVSMszVPy8nMEeJM8JeZVT0JnKQI6S6cM5lUjdNXU0/L27LTQvS8CqpanobHOSLr3nRG7952CorCpnJV07ztrs1c9yYoKZLtYYBhcG6wEaWvrOUszUh6t58AMEynkVU+w5YAWTc38mFcNg7g5B+WsSIN51XO6ctZ5eRScF8pZ56CcdR4a64KknHVBLGdFQlHYVC5KylkXbfeqQBGkZfSSPEYvCXnVCIkkX4LGuizJq14W86qnJPKOTfiKJK96xVavmkVXPb1qaV4j8qpZoPW7CtWqa/Re9Zour3qdyqteY2NjXvU6NK0bJF6VqbyBedUb9F71hi6vetPSvCUvP98Eb5K3xLzqDegs3YTO0i2DedWbumrqbXl7dlvo3ncTqpa3obHuSLr33RG7992CorCp3JV077trs1e9wYoKZLtY4DW4NlgJ0tbWe5bmfXm03gMzzH0hr3qVLQe0aGrmx7zqNYibe1DOum8wr3pPV856II+CB0I56x6Usx5AYz2UlLMeiuWs+1AUNpVHknLWI9u9KlAEaRl9LI/Rx0Je9aZEkh9DYz2R5FWfiHnVWxJ5xyb8VJJXfWqrV82qq54+szSfE3nVrND6PYNq1XN6r/pcl1d9QeVVn7OxMa/6AprWSxKvylS+xLzqS3qv+lKXV31lab6Wl59fgTfJ12Je9SV0ll5BZ+m1wbzqK1019Y28PXsjdO97BVXLN9BYbyXd+96K3fteQ1HYVN5Juve9s9mrvmRFBbJdLPA5XBusBGlr63tL84M8Wt+DGeaDkFd9xpYDWjQ182Ne9TnEzXsoZ30wmFd9rytnRcmjIEooZ72HclYUNNZHSTnro1jO+gBFYVP5JClnfbLdqwJFkJbRz/IY/SzkVV9JJPkzNNYXSV71i5hXfS2Rd2zCXyV51a+2etVsuurpN0szmsirZoPW7xtUq6LpvWq0Hq/qGovKq0azsSGvysKA8VztSLwqU2kHeVX1+VaGs9Wr8h7xf3tVV5OlaZaWn11N2E3S1SzkVV3tkLPkakLOkqvZWF7V1aSnprray9sze5F73/dF/v1xvz+fjQ2N5SDn3ufqIHTvczVDUdhUHOXc+1wdbfWqriw9fUNslxoYDdcGK0Ga2urqZGk6y6PVCcwwzkJe9RtbDsirqpkf86rREDdOUM5yNpZXdXXSlbNc5FHgIpSznKCc5QKNFVtSzootlrOcoShsKq6ScparzV4VKYK0jLrJY9RNxKvyLi/CJLtBY7nL8aqu7kJeFay+GO/YhD3keFVXD1u9anZd9dTT0oxD5FWzQ+vnCdWqOOReVX2EDq8al8irusZhY2NeNS40rXgUXlVVGQ/zqvHovWo8XV41vqWZQF5+jg/eJBOIedV40FmKD52lBAbzqvF11dSE8vYsodC9Lz5ULRNCYyWSdO9LJHbvSwBFYVNJLOnel9hmrxqPFRXIq7LAOHBtsBKkra1JLM2k8mhNAmaYpCJe1dWTLQe0aGrmD8YWDeImCZSzkhrMqybRlbOSyaMgmVDOSgLlrGTQWMkl5azkYjkrKRSFTeUfSTnrH9u9KlAEaRlNIY/RFEJeNb5EklNAY6WU5FVTinnVBBJ5xyacSpJXTWWrV82hq556WZqpibxqDmj9vKBalZreq6bW5VXTUHnV1GxszKumgaaVlsSrMpVpMa+alt6rptXlVdNZmunl5ed04E0yvZhXTQudpXTQWUpvMK+aTldNzSBvzzII3fvSQdUS+uPSrhkl3fsyit370kNR2FQySbr3ZbLZq6ZlRQWyXSwwNVwbrARpa2tmSzOLPFozgxkmi5BX9WLLAS2amvkxr5oa4iYzlLOy6K0ixDkrs66clVUeBVmFclZmKGdBP7Tlmk1SzsomlrOg34ICTiW7pJyV3XavChRBWkZzyGM0h5BXTSeRZMx65JTkVXOKedX0EnnHJpxLklfNZatXza2rnua2NPMQedXc0PrlhmpVHnqvmkeXV81L5VXzsLExr5oXmlY+Eq/KVObDvGo+eq+aT5dXzW9pFpCXn/ODN8kCYl41H3SW8kNnqYDBvGp+XTW1oLw9Kyh078sPVcuC0FiFJN37Cond+wpAUdhUCku69xW22avmY0UFsl0sMA9cG6wEaWtrEUuzqDxai4AZpqiQV83NlgNaNDXzY141D8RNEShnFTWYVy2iK2cVk0dBMaGcVQTKWcWgsYpLylnFxXJWUSgKm0oJSTmrhO1eFSiCtIyWlMdoSSGvml8iySWhsUpJ8qqlxLxqAYm8YxMuLcmrlrbVq+qrp2UszbJEXhWrVWWgWlWW3quW1eVVy1F51bJsbMyrloOmVZ7EqzKV5TGvWp7eq5bX5VUrWJoV5eXnCuBNsqKYVy0PnaUK0FmqaDCvWkFXTa0kb88qCd37KkDVshI0VmVJ977KYve+ilAUNpUqku59VWz2quVZUYFsFwssC9cGK0Ha2lrV0qwmj9aqYIapJuRVy7DlgBZNzfyYVy0LcVMVylnVDOZVq+rKWdXlUVBdKGdVhXJWdWisGpJyVg2xnFUNisKmUlNSzqppu1cFiiAto7XkMVpLyKtWkEhyLWis2pK8am0xr1pRIu/YhOtI8qp1bPWqja2HaOppXUuzHpFXbQytX12oVtUDBNroVevp8qr1qbxqPTY25lXrQ9NqQOJVmcoGmFdtQO9VG+jyqg0tzUby8nND8CbZSMyrNoDOUkPoLDUymFdtqKumNpa3Z42F7n0NoWqJJb8mku59TcTufY2gKGwqTSXd+5ra7FUbsKIC2S4WWA+uDVaCtF61maXZXB6tzcAM01zIq9ZlywEtmpr5Ma9aD+KmGZSzmhvMqzbTlbNayKOghVDOagblrBbQWC0l5ayWYjmrORSFTaWVpJzVynavChRBWka95THqLeRVG0ok2Rsaq7Ukr9pazKs2ksg7NmEfSV7Vh1uKVlfv1cW/Y10f7y7ePVhzytVYZQJCyvr59vT39vU/6OVcol/ci/ldemd+6dgr95eEx7/2C5n9/EThwJIdG2bz8avSRBubbEiLT6uG5G6WfnmSN25HL+QtGbai/4VjngmuB+w8lOljcHNtrNUZaWIdqoR06nliXL46LZruPn+36IKkk0Z5tixcK8Pk7jfKK7vumrSxXnMj9mT73PDje3u/cheSHf4U1aPemiOlBto/aZ2s9ejj+zKIavin3OslXgMD9o8bnnpJQLOH63LHSbfjWfwkSXdcfrdwVUjFStpYc+jzAvfLZElhp/hkOdx41qMnS1ZmSxxyzCu02JrxYw9FhYhqyHBxXSK3DqkXubV9f6JivCrf7PbPK1vobfUq8Y59iUjz2W/9L2t2xK3oHPf0i/fFurNwwJuwgi3HRYVfqjzpoPOsYcX92xyPFtXg9WxOpxQZM/5Tbsaekw59I+euW7U7dHS+D5/CXAbMnlkzwlcbmzl8UEGXQhsaHc5WJdaHIu5xViy7Fzq/ov387iXHpty9LW13UQ2mdCErDh/dGmnueb7amQUrErbfUzBr0VQDRqUYYpe+W52zw7WxaRu1nh34+HPmue1qLYr7YGaCtalbrF0WGOCa4XKTYe0zXIgrqsEzjl/XCjsDq9QJrJcucP3rQn1avjlYfn3UB/uD7dq2rBA7yy/rsGLEuR6vzpYs883l4IDJfeK8TOp1PmGdWvHa5747avSAiIzC6zDj9d00lV/WnjNu3C6lweDddr6VPFPPnpC0QopOjZsdKDDtFyabPq060mvx09sDIkM/7b5z41Zhd//CB5OGHGpycr1T6NGiohqyTctUce7dJCmXDR7gEj/sbYos/gmbppgz7PFCr/1J+qby+2XcjJNHbf06tY5r84VFnydrkb/6oatrT5Q9v8W39cQr0evsLvQW1eB6S/ErlCN/ntC6y9p981+3fHjfaqHbTIGrl+3x7nyg++fSv+xb23q1HB5Oe1Wm8lSfcp8+rrrWO2uvnotHb5o8tEmBFEGxvUQ1ZI4eUXB106djZyQovT5XgYVZh0TufvTi5cNi7pFbB3xuet5DG5vqTMX8Wfvcbt85zZW0EQPPDatYs16JfEM3LZpTJqrwIsfdcUQ15Cx67tHkCSMahTcaM7ryy3f3hi3O37Z3zxk3J9V6VHV20sWXftFQt7Lj6dDxVZdVuXQnqsmdqMwtaj9ec7pp87gd7Lb5tPJqKqohY6/AGW/Tb2lTcf+hjJkadjAvWNn8zoDto5scHHg1uu6sbbm1sbEXD75fPd7FBhFbkzdulqLVyaebg19+Xd2mYoXovCUKv0+xRVSDXbOQ86MSfX3YRXG+c8X+3Zibb5zvuxcYPK3ooAqej5a26PILvx+TxJp7eUqWY5EzzeHZTVMu9pwcPD7+lMTuY7OYBnnmGyCqwT3x8Mj1DXrXT/jm2IyJH19tH+zXcm26CWO7fz5kjo5M0ieBNjbHjrI1344ccqB1qqIHDm+NlTXxqexzvGr0ejV7suvMxx1KZRPVkMvTa0qOgivWTfX6mPvDnoGdtx8rUc57Wd9pfT6OulPu9Lt72ti4PZZu9j/ceW3BOPN2VA8+d3xovR1zLzsPn+U99knDkXHjdhXVEH/phoClPqHjeg06O2pRyJRB5Tv4L2rwLue4V4suVl3gODhUG5umUr1YnsuPeIwuua7Khb2nUkR0fffG5J23eGefI+MGLVlUSVRD1oJXW2w8EHViac5YI5/Gj1P38f0kyUr0DMkxqF/vKqa8U8J+4fdo4n0FW2datPzdyi6rI/s2XLR9ydD5+7bETvyhSacttwsOFK7dq/85WPfyhtcRleKEldz6IV7DQnnzhtYscnLS5jnjF39qvkAbm2nPnqH1kl8v+OhK3CK3ntjPeeUTXWN52+reb7NM3ZnDNfEuUQ0emVt32rzbv/Qg5/UTJk/aY/raLWWm0+cGJPV+kOhB/pvZ4/3Cw7z65/d87rw9oM+/a2a8iXOoXYqRhQe41Px8bUfpzxmqOgvnaodml+s+CHjz/Fpv14UHJ3QtcGa+d71qxfM+8I61q1rbh9N/2eNMhVOOndvG6a5pyqcl9xok29jjboklkdUS5is6q+KJ/kOfuYhqyB61rdS9sR414ve5Wbfnp/uzUvSq2TH//WVDN7eb4p/7dXj4L2czfMzpxu131t06UsnhnmiUd72Vm0P3n41qkfH44Bfr9wUO16Phaqxsluu4S7TmT3TE0rTjaNpxNe3UmnYaTTuPpp1X0y6raZfTtOtp2vU17baadjtNu7em3UfTHq1pj9G0Z2jaMzXt5Zp2qKa9XdPeoWmf0LTDNO2rmvY1TfuZpv1c0/6maWvW3NVT09asuauXpq1Zc9fcmrZmzV3LaNqaNWff1Vna9XRgklAUayuhdsHhrm3CXdmHBu1+9b1BgAs1Q964DfW7qSl0fTjSnubbvhRsZOyznA4E3+Kxp3cIpF7nVLrWuSPNOqdiI2Pr3IlgndnTO5Gvc2pd69yZZp1Ts5Gxde5CsM7s6V2QdRb40LkDFNUJiupqVaJZf1ZlU4eifEneWejKBlag5/tJ+gTSzyumt7Gb1ZmYbDvRaXWd6O40JzotGxk70T0ITjR7eg+9JxojtgvbQIjYOBlJnu/LEMaen4kmo/VENjVORigqk07wwIzWA4ryJ8loLMX4Yxmtl6SM1ksoo/X+n26jjXeU9LoyWh+ajJaejYxltL4EGY09vS9NRuvBYMAySmaS5/szhLHnZ6HJaP0gyDNDUVloMlpfKKo/SUbrxwbGMtoASRltgFBGG/g/3UYbM1pGXRltEE1Gy8hGxjLaYIKMxp4+mCaj9WUwYBklK8nz+zOEsedno8loQyDIs0JR2Wgy2mAoaihJRhvCBsYyWoCkjBYglNGG/U+30caMpu8XRw6nyWiZ2chYRhtBkNHY00fQZLTBDAYso2Qnef5QhjD2/Bw0GW0kBHl2KCoHTUYbAUWNIsloI9nAWEYbLSmjjRbKaGP+p9toY0bLqiujjaXJaFnZyFhGG0eQ0djTx9FktBEMBiyj5CR5/iiGMPb8XDQZbTwEeU4oKhdNRhsHRU0gyWjj2cBYRpsoKaNNFMpok/6n22hjRsuuK6NNpslo2dnIWEYLJMho7OmBNBltHIMByyi5SZ4/gSGMPT8PTUaDNjVObigqD01GC4SigkgymsIGxjJasKSMFiyU0ab8T7dRhPRAJhIjPS/J84PY0mLPz0dz0qZCiw/9+vQ4Vn59+ovo6Chbf0HCVF1lZxrVL0iYysbGBE8n+dUH7PnTKUqPPRsXSyzT9V4wzDp/HBGpbH/76VrtWOp/ND8bPcPSnCnvJw5nhF2H4mZyUqk1AVb+PETQjx9QngHt3Ey9iQSrh9jDZ/14+N8CoUWcxRb7r6kEEGxdiiaVzBZLJYAMNnZQkHUtahiSGuYIJBxI5RwFUjmHpE7OZAMHWZm/Z3R0tBqGzGeupHvRXC/bslweuiz3r6U5T16W+xfMcvMEslweKMv9C23wPJoshz18vqQsN9/2LPevriy3gCrL/cvGxrLcAijLLSTJckzlQizLLSTJcvPYwFiWWwht/iJJWW7RX7Icdm5mQrs6z3qCE82Giy3NJfKy4WIsbInXn7+bQdqaQUlzMfTEJcD66z9V09XHY2YJUrmU4Ow5sGEVaU//62GxJuXHxtta4Ww6LMsszRB5h2UZFhbCOSzWng+vGXRYlkFjhQgcFuvzUA8LBuJymhsONvlQko9VlrOBscmvoMkBK6w9/cX36ivydGBD2eyxBLEcWqOVNGu0Elijb2JPtzan/z6esqbSnuDZDuCzHai/eUtpXavmRr+K5iPQlGxkLJ+sgoheTfAxKdO4Gssmq2N4z9SsotmzNWR7tiYIym9roD1bS7Nna7EcvJZ6z7x0nbN1NHvmxUbGztk6aM/WE+wZ07geO2frY3jPfjtnG8j2bAN2zjZAe7aRZs82YudsI8ldZz0bGLvrbITI2kSicjVLM5jKtZDKzSS35v/W0vrzsbXcQvIJoOy13EqdS9Loyv/baHJJGjYytrfboLXdTpBLmMbtWP7fLvIOg7XHM7Sw0gdJ3EFyRLezgbEl2inpI9udXiLmfzsUtUvnGsXANu6O4ezw201jD1l22IPdNPZAa7uXJjvsxW4ae0m+U9nEyi72hlV+kudvYaUKe34Bkexo/Sjsg97dyg9FFSDJjrsARH7MZT/JFu1jA2PPPyApOx8Qys77oaiDItnZ+rCH/qcY2Zid0+m6ux2myc7p2MjYxh6GsvMRguzMNB7B0D9CcvTYxWgnlh0LkjyfpZ7d2PML0WTno9CBKQhFFSLJzkeYSAyRY5Ky4zGh7HgEijpOkx1P/E+3kTY7/nZ3DSPLjmHY3TUMyo7hNNkxHLu7hpNkp/3spoBlp8Ikzz/Iyj72/CI02fEkdGAKQ1FFSLLjcQCRH3OJINmik2xg7PmnJGXnU0LZOQKKOk2Tnc/8TzGyMTtn0HV3PUuTnTOwkbGNPQtl53ME2ZlpPIehf47k6LGL0TEsOxYleT5LPSew5xejyc6R0IEpCkUVI8nO55hIDJHzkrLjeaHseA6KukCTHS/+T7eRNjv+dne9RJYdL2F310tQdrxMkx0vY3fXyyTZKYLdFLDsVJzk+adZ2ceeX4ImO16BDkxxKKoESXa8ACDyYy5XSbboChsYe/41Sdn5mlB2vgpFXafJzjf+pxjZmJ0z6bq73qTJzpnYyNjG3oSy8y2C7Mw03sLQv0Vy9NjF6DyWHUuSPJ+lnovY80vRZOfb0IEpCUWVIsnOt5hIDJE7krLjHaHseAuKukuTHe/9T7eRNjv+dne9T5Yd72N31/tQdnxAkx0fYHfXByTZ6Sq7KWDZqTTJ86+zso89vwxNdnwIHZjSUFQZkux4F0Dkx1wekWzRQzYw9vzHkrLzY6Hs/AiKekKTnZ/+TzGyMTtn0XV3fUaTnbOwkbGNfQZl5+cE2ZlpfI6h/5zk6LGL0R0sO5YleT5LPfew55ejyc4voANTFooqR5KdnzORGCIvJWXHl0LZ8TkU9YomO77+n24jbXb87e76hiw7vsHurm+g7PiWJju+xe6ub0my0yN2U8CyU3mS5z9hZR97fgWa7PgOOjDloagKJNnxFYDIj7m8J9mid2xg7PkfJGXnD0LZ+T0UFUWTnT/+TzGyMTtn03V3/USTnbOxkbGN/QRl588E2Zlp/Iyh/5nk6LGL0UssO1YkeT5LPa+x51eiyc5foANTEYqqRJKdPzORGCJfJWXHr0LZ8TMU9Y0mO0b/T7eRNjv+end1i0WVHd1iQXdXFgasmpsdSXZ0s4PururTrQwmkp3es5sClp0qkzw/ipV97PlVSLKjmwk6MJWhqCok2fEbgMiPuZgptsjNxAbGnm8vJzu72YtkZzczFOVAkp3dHP+nGNmYnXPoubu6OdFk5xxsZGxjnaDs7EyQnZlGZwx9Z5LsyC5GX7HsWJXk+d/YtQN7fjWa7OwCHZiqUFQ1iuzs5sxEYojElpQdYwtlR2coypUmO7r9T7eRNjv+dnd1J8uO7tjd1R3Kjh402dEDu7t6kFxMzOymgGWn6iTPd2BlH3t+DZrs6AkdmOpQVA2S7OgKIPJjLnFItsiTDYw9P66k7BxXKDvHgaLi0WTn+P9TjIRITwA9HP6bSdaCoJ1OYOMfomAjAIsF/j5p9X8my++TdktoaSaS9vuk3RKmgsISifwyou97bL2UJIR4SaT3kqDZvCD4z5jBf28skG6jE1uaSeRtdGJso5P8ttFToC1MDG1hkv/pkRf5xd0gi0mtPtwBWuykQpUFW+xkkjQm+1VjEGqhYqO3CTfoFxq6JYVmnVxSzU8uMus47K4ABcZTKzQ062TQrP+RNOt/ODxa05hb2r7ofnQeaYvzS+GIpdNd1rf+AE12T2FpptRvNKHCWx9alxR/RjX7LYoBmFLv6tkF/bXu/f4EvResFNb1aKx8Knn1M5XQRTzFn5Oy+/35bGxoLC+rq4mdcq+woSJTSQlFYVNJ/edUfv9H0FRSs6n8Gbe6eq8u/h3r+nh38e7BmlOCf/6LBj9bDQNCyvr59vT39vVHjq/lkSk07ZQ6BrELDndLE+6WNtwtnW3phg2jK+GktzQzECUcJgna9vRQyslA/XHg90f8ruNDxMzIGaNPtR+vrLnmO3jZYk0WyUj0F3DdMrCxOXe+P7SoYch4wE+OiqnMpEAqM9laan9X72UeljJe6VJRET2XdG8xeNkS7iN+/0ca9jNbmlnklYLM3KzzZ1wWJNFypgidpczQWcoCJNr/ZfnOrKt8Z5W3Z1mFyndmqHxnhcbKJql8ZxMr31mgKGwq2SWV7+xsKv9XPsAsVyZWVJDfnK8GZoBrg5UgbXXNYWnmlEdrDjDD5PyNBWzR0rPlgBZNzfxY/c8AcZMDylk5DWY5cujKWbnkUZBLKGflgHJWLmis3JJyVm6xnJUTisKmkkdSzsrze86yCyIogrSM5pXHaF7O58XWBuZeXoRJzguNlQ+4GiPzzfc7ydiEs0jkHZsw8ov4kQnnhyz2NK0Tdi7RL+7F/C69M7907JX7S8LjX/uFzH5+onBgyY4Ns/n4VWmijU02pMWnVUNyN0u/PMkbt6MX8pYMW9H/wjHPBNcDdh7K9DG4uR6bro3NuO7U8FlN025/lWVi0qZJVmaaHFEq2eec3bYu3pT52b1P855pY//xf9NkbOKKtRre6ZQ1TqM3Hf3Xnqy9OZbT2QHz5/cv3zOogB4NUzRLl17TzqDnowLRSVsbl30EUSDcrWC4WyHdt4Z64ab9yOXCdCDcdAz5HgN6vdIN+CX3V2PVdnJ2ie3q5u7hGSduvPgJEiZKnCRpsuT/pEiZyit1mrTp0mfImClzlqzZsufImSt3nrz58hcoWKhwkaLFipcoWap0mbLlyleoWKlylarVqteoWat2nbr16jdoOD2Wncls7+AYeNU8IChgcWmfjj2cgyL6dfoaGrSiStnA/9/lEhRx+H0Pl2IJxw/9ryttUMTthi3zLRswutF/XRmDIi50WLmvVWHvG/915QiKWOV6psyuec4t/uvK+WdXvj+7CvzZVejPrsJ/dpX4s6vUn13l/uyq8GdX9T+7avzZVffPrvp/djX8s6vRn13N/+xq+WeXz59dbf/s6vJnV9c/u3r82eX/Z1fvP7v6/Nk18M+uwX92hQ3j9I3g9I3n9E3g9CmcvmBO31RO3zRO32xO31xO3wJO3yJOXyinbwWnby2nbz2nbyOnbxOnbzunbyenby+nbz+n7xin7zinL4LTd5rTd5bTd47Td4nTd4XTd4PTd4vT95DT94jT95zT95LT95rT94bTF8Xp+8Tp+/ZnX7hdLF6nE6/Tmdfpzuv05HXG5XXG43Um5nUm5XWm4HWm4nVm4HVm5HVm43Xm4HXm4nXm5nUW4HUW4nUW43WW4HWW53VW4HVW5XVW53XW5HXW4nXW53U25HU25XU253W24XW25XV24nV24XX68jr9eJ3+vM7evM7+vM6BvM7hvM4RvM6xvM7xvM6JvM5JvM5gXudUXudMXudsXudCXuciXmcIrzOU17mS17mK17me17mR17mV17md17mP17mf13mE13mM13mC1xnG6zzN6zzL67zA67zE67zJ67zF67zP63zI63zM63zC63zJ63zN63zP64zidUZzOk28ymVy4HXyypnJhdcZm9fJK2cmXjkzJeR18sqZKSWvk1e5TOl4nbxyZsrE68zM6+SVMxOvnJny8Tp55cxUnNfJq1ymsrxOXjkzVeR1VuJ18sqZiVfOTHV5nbxyZmrG6+RVLlNrXievnJna8Trb8zp55czEK2emHrxOXjkzDeB18iqXKYDXyStnppG8zlG8Tl45M/HKmUnhdfLKmWkWr5NXuUzzeZ28cmZazOtcwuvklTMTr5yZ1vI6eeXMtI3Xyatcpj28Tl45Mx3gdR7kdfLKmYlXzkwRvE5eOTNd5HXyKpfpOq+TV85Mt3mdd3idvHJm4pUz03NeJ6+cmT7wOnmVy/SV18krZ2Y7XqeJ18krZ2ZeOTPz3JmZV87MiXidvMpl/ofXyStnZi9eZ2peJ6+cmXnlzMxzZ2ZeOTPn53XyKpe5KK+TV87MJXmdpXidvHJm5pUzM8+dmXnlzFyP18mrXOYmvE5eOTO34HW25HXyypmZV87MPHdm5pUzc09eJ69ymfvxOnnlzDyI1zmY18krZ2ZeOTPz3JmZV87MQbxOXuUyz+B18sqZeQ6vcy6vk1fOzLxyZua5MzOvnJnX8Tp5lcu8hdfJK2fmHbzOnbxOXjkz88qZmefOzLxyZj7F6+RVLvN5XievnJkv8zqv8Dp55czMK2dmnjsz88qZ+QWvk1e5zO94nbxyZv7I6/zE6+SVM3teObPnuTN7Xjmz9+B18iqXfQJeJ6+c2SfhdfI+V7TnlTN7Xjmz57kze145s2fl7Ey9b4FDd22pa+nMzOvMEhTRLXc+H4/LGztaOllKb9Iy//Moj3cnLZ3Md1QIqxOWuEqGVZbOTrzOHrzO/rzOYbzOcbzOIF7nLF7nQl4nyyFLQpbETnPI976lcwOn05F9Blihd52pPbKvLmjpbMfrbM/r7MDr7Mjr7MTr7Mzr7MLr7Mrr9OV1+vE6u/E62cY52Cef6bWmVTVLJyuRp5yevD1xuH2gpZN9cXbyQi+nr5VPDLN0si1uOyGokK9T/YuWTub4OjRfsu3Nt1uRlk5WIgOCBs0ITxlR1tLJSmTynW1Plbz6+KqlcyRP0miepLG8yIm8yJW8fV/F6XS6yBnT6TJnTKervM7rvH9+mxPpbMd5urOJ0+mSnfPPXXJyHuSSmxeZlxdZkBfZgPf0hpzO2AM5Y8YezNnN2EM5D4o9jPfPR/Eil/CevpTT6coMY4DDxKkt3Kr7WjrZR53tqngf7n5/RmpLZ2RQxPOG/v1uHJ5Z2dJ5iffPr/H++Q3eP7/D++cPeP/8Ee+fP+P981e8f/6G988/8P75Z94//8r55252nH/u5sD5525OvH/uyvvnnrx/Hpf3zxPy/nlS3j9PzvvnqXj/PC3vn6fn/XOe43PLzuvMw+vkfYDpxrOBbgV5nbzv49x4n2q6leF1luN18hyfWzVeZ21eJ+8DTDeeDXRrwOvkfR/nxvtU082b1+nD6+Q5PrfOvM5uvE7eB5huPBvo1ovXyfs+zo33qabbUF7nMF4nz/G5jeN1TuZ18j7AdOPZQLcpvE7e93FuvE813ebxOhfwOnmOz205r3M1r5P3AaYbzwa6beB18r6Pc+N9qum2m9e5l9fJc3xuR3md4bxO3geYbjwb6HaG18n7Ps6N96mm2zVe5w1eJ8/xuT3gdT7ldfI+wHTj2UC3V7xO3vdxbrxPNd2+8Dp5r5e48xyfuyOv05XXyfsA051nA93j8Dp538e58z7VdE/O6+S9XuLOc3zu6XmdWXidvHLmzvsA0z0nr5NXztx55cy9CK+TV87ced/HufMql3tlXievnLnzPsB0r8Hr5JUzd145c2/M6+SVM3fe93HuvMrl3oHXyStn7rwPMN278jp55cydV87c+/I6eeXMnfd9nDuvcrmP5nXyypk77wNM9wm8Tl45c+eVM/fpvE5eOXPnfR/nzqtc7kt5nbxy5s77ANN9Ba+TV87ceeXMfTOvk1fO3Hnfx7nzKpf7IV4nr5y58z7AdD/O6+SVM3deOXOP5HXyypk77/s4d17lcr/L6+SVM3feB5juj3idvHLmzitn7m95nbxy5s77Ps6dV7k8zLxOXjnz4H2A6cF7W9KDV848eOXMIz6vk1fOPHjfx3nwKpdHGl4nr5x58D7A9OC9LenBK2cevHLmwXNnHrxy5sH7Ps6DV7k8SvM6eeXMg/d9nAfvbUkPXjnz4JUzD5478+CVMw/e93EevMrl0YrXyStnHrzv4zx4b0t68MqZB6+cefDcmQevnHnwvo/z4FUujyG8Tl458+B9H+fBe1vSg1fOPHjlzIPnzjx45cyD932cB69yefzL6+SVMw/e93EevLclPXjlzINXzjx47syDV848WDkrUXFrRETKd+Utnbzv4zx4RsyDV848eN/HefC+j/PgvV7iwStnHrzXSzx45cyDV848eN/HefCMmAevnHnwvo/z4H0f58F7vcSDV848eK+XePDKmQevnHnwvo/z4BkxD1458+B9H+fJ+z7Ok/d6iSevnHnyXi/x5JUzT1458+R9H+fJM2KevHLmyfs+zpP3fZwn7/UST1458+S9XuLJK2eevHLmyXu9xJNnxDx55cyT93qJJ+/1Ek/e6yWevHLmyXu9xJNXzjx55cyT93qJJ8+IefLKmSfv9RJP3uslnrzXSzx55cyT93qJJ6+cefLKmSfv9RJPnhHz5JUzT97rJZ6810s8ea+XePLKmSfv9RJPXjnz5JUzT97rJZ48I+bJK2eevNdLPHmvl3jyXi/x5JUzT97rJZ68cubJK2eevNdLPHlGzJP3eoknr5x5/r/uziU0riqM4zOZ4qO1Pd+5qSU+qtWddJVEi6CgxjxIaQmkiS4U4tjcJqPJzGRyZzBUghdCqeiiGatY0E1nGmNttKArEdzYjWAsSJWGQheldGV31RYRvPO69+bOb6YznSKlqyT/3POd1z3f75x835lQeomi9BJFOFOEM0WnM0U4U5ReoohcitJLFOFMUXqJovQSRThThDNFpzNFOFOUXqKIXIrSSxThTFF6iaL0EkU4E8KZ0OlMCGdC6SVC5BJKLxHCmVB6iVB6iRDOhHAmdDoTwplQREyIXNJNIuFMKCImdG1NCGdCOBM6nQnhTCgiJkQuGSaRcCYUERO6tiaEMyGcCZ3OhHAmFBETIpfMkEg4E4qICV1bE8KZEM6ETmdCOBOKiAmRS46QSDgTiogJXVsTwpkQzoROZ0I4E4qICZFLviGRcCYUERO6tiaEMyGcCZ3OhHAmFBETIpeskkg4E4qICV1bE8KZEM6ETmdCOBOKiAmRS/4kkXAmFBETurYmhDMhnAmdzoRwpikipolc+gESCWeaImKarq1pwpkmnGk6nWnCmaaImCZy6Z0kEs40RcQ0XVvThDNNONN0OtOEM+3g7PQnHfdvvrG26Il7ICdKv0LiGyS+RSJl9+l5Eg+T6HjaQ+dEX99+/mFPPJX99f1jnx3v/WXiXk90XNCh7Oo9l1862+2JTrxjYe3bFxZejP/gic7e+1y7Pnjt8odPe6ITBPnngzOf/zh6sMcTV6lJ50m8ROJVEq+DaERI3ExiB4lPkkiJfAZl4hk9JNLLYLxK4mskmpCeZ0yQGKPib5Po7C4uXdlinj35pa+4E7X89/V3tfXo3395Iu0uDNpdGLRnMOgIbNCewaAjsEFRS+MwiXRh0KA/8xp0LjZoI2E4Ucvn5g/8Fv15cu7I0ezX4+b+xHQyMWuOTcbi1oXQY/aJ4kdEfWQv9cZS5n6rzf5iMG6ZE2YqN9rd1cDHUQXKh5sq/95AsHyoufoH7HzhM8cWt7h2lofNqagVy5i33BPXQqQ5CyH7VKEt41Er+nIiOed2qdffJp/x3N5EJusJYe/5Up9U+Ymy3Od/dN1v+v0VtNqLvmoLG5qz0Gbn91mJ5GLW3wbP2NKwaaVT8XInOwpfA+319bNScX60s+vZqkf9w3miP2ZOjdsrPbF4NDVX/GEoedT3QG5f+k2/6XpjFi5Z+2lHe2foj8cvPjO3c9uuxFBm4eLIyvzW3FNXVMfV9POZGxcStevbkNubnqrRq6qZ97Ul8Ls2GLnAkmluet4ZsL8qtdkpNJT8uGIlsrzHnJ0dmYzGC1a85ehWsrQ7PZ0cPOC+dZHt9spgfLz4fW0fsKvOP+NZO3Pt9+92d03b+ZFUtPC+uOUrzqjc4+zylFXxWE/cvR4r0uw6a3WlNuCx/Cu3jseqemtdp4W+rN9vpFXP3d/ySIarPZbftaz3WI/UWfNLfTPp6NRsjaXtriCvwDY7XxAX2+sYdRdmYx5j3YyVrD8EHs4doeOjnQ0MUO1Kwm4ltd1a5A5zXTv+P9d1ulSNMwhjsXjGTFnHgoPwYIsObOvtWfQhrz2u4aCrrWDxplUE3+bKwFcWSLDOtuo5uq/KUTdYe7hW7aFcbyxTNVMhd/G73a4MRPZ7/+QVh3hsJp2wYmbc+jTYvI236r3L5Tfd5mnc6BmuMR5tJ8sV+oYl5I1PjVLh4sbGm7ebPl7Yd1VbX8cD33sQmIxNbnf+A+SfPSkIPQoA","debug_symbols":"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","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n//\n// IMPORTANT: Prefer `multi_scalar_mul()` over repeated `embedded_curve_add()`\n// for adding multiple points. This is significantly more efficient.\n// For adding exactly 2 points, use `embedded_curve_add()` directly.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// Elliptic curve addition\n/// IMPORTANT: this function is expected to perform a full addition in order to handle all corner cases:\n/// - points on the curve\n/// - point doubling\n/// - point at infinity\n/// As a result, you may not get optimal performance, depending on the assumptions of your inputs.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // avoid calling the black box function for trivial cases\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_inner(point1, point2)\n        }\n    } else {\n        embedded_curve_add_inner(point1, point2)\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// EC addition wrapper for the foreign function\nfn embedded_curve_add_inner(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    crate::assert_constant(separator);\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"52":{"source":"/// Game Move circuit.\n/// Proves that a game move is valid: one card placed from correct player,\n/// board state correctly updated with capture logic.\n/// Also computes ECDH shared secret to encrypt the placed card's nullifier.\n///\n/// Public inputs:\n///   card_commit_1, card_commit_2 - player card commitments (include ranks)\n///   start_state_hash - hash of board state before this move\n///   end_state_hash - hash of board state after this move\n///   game_ended - 1 if game over, 0 otherwise\n///   winner_id - 0=not ended, 1=player1 wins, 2=player2 wins, 3=draw\n///   encrypted_card_nullifier - the placed card's nullifier secret, encrypted with ECDH shared key\n///\n/// The circuit verifies:\n/// 1. The placed card is in the current player's committed hand (card_commit binding)\n/// 2. Capture logic: rank comparison for all adjacent opponent cells\n/// 3. Non-placed, non-captured cells are unchanged between board_before/board_after\n/// 4. Scores are consistent with board ownership + hand counts\n/// 5. Game end detection and winner determination\n/// 6. ECDH encryption of placed card's nullifier secret\n\n/// Board cell: each cell is (card_id, owner) where owner 0=empty, 1=player1, 2=player2\n\nuse std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n// External poseidon dep removed; using stdlib pedersen_hash instead\n\n/// Grumpkin generator point G\nglobal G: EmbeddedCurvePoint = EmbeddedCurvePoint {\n    x: 0x083e7911d835097629f0067531fc15cafd79a89beecb39903f69572c636f4a5a,\n    y: 0x1a7f5efaad7f315c25a918f30cc8d7333fccab7ad7c90f14de81bcc528f9935d,\n    is_infinite: false,\n};\n\n/// Compute ECDH shared secret: shared_point = my_private_key * opponent_public_key\nfn compute_shared_secret(my_private_key: Field, opponent_pubkey: EmbeddedCurvePoint) -> Field {\n    let shared_point = multi_scalar_mul(\n        [opponent_pubkey],\n        [EmbeddedCurveScalar::from_field(my_private_key)],\n    );\n    shared_point.x\n}\n\n/// Key expansion for symmetric encryption using pedersen hash\nfn expand_secret_1(secret: Field) -> Field {\n    std::hash::pedersen_hash([secret, 0])\n}\n\n/// Symmetric encrypt a single field element using ECDH shared secret\nfn symmetric_encrypt_field(plaintext: Field, secret: Field) -> Field {\n    let key = expand_secret_1(secret);\n    key + plaintext\n}\n\n// ====================== CARD DATABASE ======================\n/// Hardcoded card rank database: 50 cards with ranks [top, right, bottom, left].\nfn get_card_ranks(card_id: u32) -> [Field; 4] {\n    assert((card_id >= 1) & (card_id <= 50), \"Invalid card ID for rank lookup\");\n\n    // Level 1 - Common (IDs 1-10)\n    if card_id == 1 { [1, 4, 1, 5] }         // Mudwalker\n    else if card_id == 2 { [5, 1, 1, 3] }    // Blushy\n    else if card_id == 3 { [1, 3, 3, 5] }    // Snowdrop\n    else if card_id == 4 { [6, 1, 1, 2] }    // Sunny\n    else if card_id == 5 { [2, 3, 1, 5] }    // Inkwell\n    else if card_id == 6 { [2, 1, 4, 4] }    // Stripes\n    else if card_id == 7 { [1, 5, 4, 1] }    // Barkeeper\n    else if card_id == 8 { [3, 1, 5, 2] }    // Dotty\n    else if card_id == 9 { [2, 1, 6, 1] }    // Penny\n    else if card_id == 10 { [4, 3, 2, 4] }   // Peaches\n    // Level 2 - Uncommon (IDs 11-20)\n    else if card_id == 11 { [2, 6, 1, 6] }   // Freckles\n    else if card_id == 12 { [7, 1, 3, 1] }   // Camo\n    else if card_id == 13 { [6, 2, 2, 3] }   // Neon\n    else if card_id == 14 { [5, 3, 3, 4] }   // Glow Bug\n    else if card_id == 15 { [6, 1, 4, 3] }   // Limelight\n    else if card_id == 16 { [3, 4, 5, 3] }   // Marble\n    else if card_id == 17 { [5, 3, 2, 5] }   // Sapphire\n    else if card_id == 18 { [5, 1, 3, 5] }   // Jefferson\n    else if card_id == 19 { [5, 2, 5, 2] }   // Longfoot\n    else if card_id == 20 { [4, 2, 4, 5] }   // Featherfin\n    // Level 3 - Rare (IDs 21-30)\n    else if card_id == 21 { [3, 7, 2, 5] }   // Lilac\n    else if card_id == 22 { [5, 2, 5, 5] }   // Patches\n    else if card_id == 23 { [6, 6, 3, 3] }   // Faded\n    else if card_id == 24 { [6, 3, 6, 3] }   // Gold Dust\n    else if card_id == 25 { [3, 5, 5, 5] }   // Phantom\n    else if card_id == 26 { [7, 5, 1, 3] }   // Ash\n    else if card_id == 27 { [7, 1, 5, 3] }   // Cocoa\n    else if card_id == 28 { [5, 3, 6, 3] }   // Ringmaster\n    else if card_id == 29 { [5, 6, 2, 4] }   // Goldrush\n    else if card_id == 30 { [4, 4, 7, 2] }   // Swampling\n    // Level 4 - Epic (IDs 31-40)\n    else if card_id == 31 { [3, 6, 4, 7] }   // Glitter\n    else if card_id == 32 { [7, 2, 3, 7] }   // Starfield\n    else if card_id == 33 { [2, 3, 7, 7] }   // Specter\n    else if card_id == 34 { [6, 5, 5, 5] }   // Saffron\n    else if card_id == 35 { [4, 7, 6, 2] }   // Stardust\n    else if card_id == 36 { [2, 3, 7, 8] }   // Achoque\n    else if card_id == 37 { [1, 7, 6, 4] }   // Zacapu\n    else if card_id == 38 { [7, 3, 1, 6] }   // Laguna\n    else if card_id == 39 { [7, 4, 4, 4] }   // Streamwalker\n    else if card_id == 40 { [3, 7, 3, 6] }   // Digger\n    // Level 5 - Legendary (IDs 41-50)\n    else if card_id == 41 { [6, 7, 3, 7] }   // Eclipse\n    else if card_id == 42 { [6, 5, 8, 4] }   // Kaleidoscope\n    else if card_id == 43 { [6, 5, 6, 6] }   // Twinned\n    else if card_id == 44 { [3, 6, 7, 8] }   // Sparkletail\n    else if card_id == 45 { [7, 6, 5, 6] }   // Riddler\n    else if card_id == 46 { [3, 10, 2, 1] }  // Rosita\n    else if card_id == 47 { [6, 2, 6, 7] }   // Brooklet\n    else if card_id == 48 { [5, 5, 7, 6] }   // Whisper\n    else if card_id == 49 { [7, 7, 4, 2] }   // Misty\n    else { [7, 2, 7, 4] }                    // Lerma (50)\n}\n\n// ====================== HASH FUNCTIONS ======================\n\nfn hash_board_state(board: [Field; 18], scores: [Field; 2], current_turn: Field) -> Field {\n    let mut inputs: [Field; 21] = [0; 21];\n    for i in 0..18 {\n        inputs[i] = board[i];\n    }\n    inputs[18] = scores[0];\n    inputs[19] = scores[1];\n    inputs[20] = current_turn;\n    std::hash::pedersen_hash(inputs)\n}\n\n/// Compute card commitment hash (must match prove_hand format).\n/// Format: hash(player_secret, player_address, game_id,\n///              card_ids[5], card_ranks[5*4], nullifier_secrets[5])\nfn compute_card_commit(\n    player_secret: Field,\n    player_address: Field,\n    game_id: Field,\n    card_ids: [Field; 5],\n    card_ranks: [[Field; 4]; 5],\n    nullifier_secrets: [Field; 5],\n) -> Field {\n    let mut hash_inputs: [Field; 33] = [0; 33];\n    hash_inputs[0] = player_secret;\n    hash_inputs[1] = player_address;\n    hash_inputs[2] = game_id;\n    for i in 0..5 {\n        hash_inputs[3 + i] = card_ids[i];\n    }\n    for i in 0..5 {\n        for j in 0..4 {\n            hash_inputs[8 + i * 4 + j] = card_ranks[i][j];\n        }\n    }\n    for i in 0..5 {\n        hash_inputs[28 + i] = nullifier_secrets[i];\n    }\n    std::hash::pedersen_hash(hash_inputs)\n}\n\n// ====================== MAIN CIRCUIT ======================\n\nfn main(\n    // Public inputs\n    card_commit_1: pub Field,\n    card_commit_2: pub Field,\n    start_state_hash: pub Field,\n    end_state_hash: pub Field,\n    game_ended: pub Field,\n    winner_id: pub Field,\n    encrypted_card_nullifier: pub Field,\n    // Private inputs - move data\n    current_player: Field,       // 1 or 2\n    card_id: Field,              // ID of card being placed\n    row: Field,                  // 0-2\n    col: Field,                  // 0-2\n    // Private inputs - board state\n    board_before: [Field; 18],   // 9 cells x 2 fields (card_id, owner)\n    board_after: [Field; 18],\n    scores_before: [Field; 2],\n    scores_after: [Field; 2],\n    current_turn_before: Field,\n    // Private inputs - current player's hand commitment data\n    player_secret: Field,\n    player_address: Field,\n    game_id: Field,\n    player_card_ids: [Field; 5],\n    player_card_ranks: [[Field; 4]; 5],\n    player_nullifier_secrets: [Field; 5],\n    // Private inputs - ECDH encryption (FIX-3)\n    grumpkin_private_key: Field,\n    opponent_pubkey_x: Field,\n    opponent_pubkey_y: Field,\n) {\n    // ===== 1. Validate current player =====\n    assert(\n        (current_player == 1) | (current_player == 2),\n        \"Invalid player\",\n    );\n    assert(current_player == current_turn_before, \"Not this player's turn\");\n\n    // ===== 2. Validate position =====\n    let r = row as u32;\n    let c = col as u32;\n    assert(r < 3, \"Row out of bounds\");\n    assert(c < 3, \"Col out of bounds\");\n\n    // ===== 3. Verify card_commit binding (FIX-1) =====\n    // Recompute the current player's card_commit from their hand data\n    let recomputed_commit = compute_card_commit(\n        player_secret,\n        player_address,\n        game_id,\n        player_card_ids,\n        player_card_ranks,\n        player_nullifier_secrets,\n    );\n\n    // Verify it matches the correct card_commit (1 or 2 based on current_player)\n    if current_player == 1 {\n        assert(recomputed_commit == card_commit_1, \"Player 1 card commit mismatch\");\n    } else {\n        assert(recomputed_commit == card_commit_2, \"Player 2 card commit mismatch\");\n    }\n\n    // ===== 4. Verify placed card is in committed hand =====\n    let mut card_found: bool = false;\n    let mut placed_card_ranks: [Field; 4] = [0; 4];\n    let mut placed_card_nullifier_secret: Field = 0;\n    for i in 0..5 {\n        if player_card_ids[i] == card_id {\n            card_found = true;\n            placed_card_ranks = player_card_ranks[i];\n            placed_card_nullifier_secret = player_nullifier_secrets[i];\n        }\n    }\n    assert(card_found, \"Placed card not in committed hand\");\n\n    // ===== NEW: Verify card has not already been placed (C2 fix) =====\n    for i in 0..9 {\n        if board_before[i * 2 + 1] != 0 {\n            // Cell is occupied -- verify it's not the same card\n            assert(board_before[i * 2] != card_id, \"Card already placed on board\");\n        }\n    }\n\n    // Verify the committed ranks match the hardcoded card database\n    let db_ranks = get_card_ranks(card_id as u32);\n    for i in 0..4 {\n        assert(\n            placed_card_ranks[i] == db_ranks[i],\n            \"Placed card ranks do not match database\",\n        );\n    }\n\n    // ===== 5. Verify the cell was empty before the move =====\n    let cell_idx = r * 3 + c;\n    assert(board_before[cell_idx * 2] == 0, \"Cell not empty\");\n    assert(board_before[cell_idx * 2 + 1] == 0, \"Cell not empty (owner)\");\n\n    // ===== 6. Verify the card was placed in board_after =====\n    assert(board_after[cell_idx * 2] == card_id, \"Card not placed correctly\");\n    assert(\n        board_after[cell_idx * 2 + 1] == current_player,\n        \"Owner not set correctly\",\n    );\n\n    // ===== 7. Capture logic (FIX-2) =====\n    // Determine the opponent\n    let opponent: Field = if current_player == 1 { 2 } else { 1 };\n\n    // Track which cells are captured (1 = captured, 0 = not)\n    let mut captured: [bool; 9] = [false; 9];\n\n    // Check all 4 adjacent directions:\n    // Direction 0: Top    (row-1, col)   - placed card's top vs adjacent card's bottom\n    // Direction 1: Right  (row, col+1)   - placed card's right vs adjacent card's left\n    // Direction 2: Bottom (row+1, col)   - placed card's bottom vs adjacent card's top\n    // Direction 3: Left   (row, col-1)   - placed card's left vs adjacent card's right\n\n    // placed_card_ranks: [top, right, bottom, left]\n    // adjacent ranks:    [top=0, right=1, bottom=2, left=3]\n    // Facing rank pairs: placed_top vs adj_bottom, placed_right vs adj_left,\n    //                    placed_bottom vs adj_top, placed_left vs adj_right\n\n    // Direction 0: Top (row-1, col)\n    if r > 0 {\n        let adj_idx = (r - 1) * 3 + c;\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's top vs adjacent card's bottom\n            let placed_rank = placed_card_ranks[0] as u32;\n            let adj_rank = adj_ranks[2] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 1: Right (row, col+1)\n    if c < 2 {\n        let adj_idx = r * 3 + (c + 1);\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's right vs adjacent card's left\n            let placed_rank = placed_card_ranks[1] as u32;\n            let adj_rank = adj_ranks[3] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 2: Bottom (row+1, col)\n    if r < 2 {\n        let adj_idx = (r + 1) * 3 + c;\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's bottom vs adjacent card's top\n            let placed_rank = placed_card_ranks[2] as u32;\n            let adj_rank = adj_ranks[0] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 3: Left (row, col-1)\n    if c > 0 {\n        let adj_idx = r * 3 + (c - 1);\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's left vs adjacent card's right\n            let placed_rank = placed_card_ranks[3] as u32;\n            let adj_rank = adj_ranks[1] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // ===== 8. Verify board_after matches expected state =====\n    // For each cell, verify:\n    // - Placed cell: already verified above (card_id and owner)\n    // - Captured cell: card_id unchanged, owner changed to current_player\n    // - All other cells: identical to board_before\n    for i in 0..9 {\n        if i as u32 != cell_idx {\n            let before_card = board_before[i * 2];\n            let before_owner = board_before[i * 2 + 1];\n            let after_card = board_after[i * 2];\n            let after_owner = board_after[i * 2 + 1];\n\n            // Card ID must never change for non-placed cells\n            assert(after_card == before_card, \"Non-placed cell card_id changed\");\n\n            if captured[i] {\n                // Captured cell: owner must change to current_player\n                assert(\n                    after_owner == current_player,\n                    \"Captured cell owner not updated\",\n                );\n            } else {\n                // Non-captured cell: owner must stay the same\n                assert(after_owner == before_owner, \"Non-captured cell owner changed\");\n            }\n        }\n    }\n\n    // ===== 9. Verify start_state_hash matches board_before =====\n    let computed_start = hash_board_state(board_before, scores_before, current_turn_before);\n    assert(computed_start == start_state_hash, \"Start state hash mismatch\");\n\n    // ===== 10. Compute and verify end state =====\n    let next_turn: Field = if current_player == 1 { 2 } else { 1 };\n    let computed_end = hash_board_state(board_after, scores_after, next_turn);\n    assert(computed_end == end_state_hash, \"End state hash mismatch\");\n\n    // ===== 11. Verify game ended flag =====\n    let mut filled: u32 = 0;\n    for i in 0..9 {\n        if board_after[i * 2] != 0 {\n            filled += 1;\n        }\n    }\n\n    if filled == 9 {\n        assert(game_ended == 1, \"Game should have ended\");\n        let p1_score = scores_after[0] as u32;\n        let p2_score = scores_after[1] as u32;\n        if p1_score > p2_score {\n            assert(winner_id == 1, \"Player 1 should be winner\");\n        } else if p2_score > p1_score {\n            assert(winner_id == 2, \"Player 2 should be winner\");\n        } else {\n            assert(winner_id == 3, \"Should be a draw\");\n        }\n    } else {\n        assert(game_ended == 0, \"Game should not have ended\");\n        assert(winner_id == 0, \"No winner yet\");\n    }\n\n    // ===== 12. Verify scores are exactly correct (C1 fix) =====\n    let mut p1_board: u32 = 0;\n    let mut p2_board: u32 = 0;\n    for i in 0..9 {\n        let owner = board_after[i * 2 + 1];\n        if owner == 1 {\n            p1_board += 1;\n        } else if owner == 2 {\n            p2_board += 1;\n        }\n    }\n    // Player 1 goes first, so P1 has placed ceil(filled/2) cards, P2 has placed floor(filled/2)\n    let p1_played = (filled + 1) / 2;\n    let p2_played = filled / 2;\n    let p1_hand = 5 - p1_played;\n    let p2_hand = 5 - p2_played;\n    let expected_p1_score = p1_board + p1_hand;\n    let expected_p2_score = p2_board + p2_hand;\n    assert(scores_after[0] == expected_p1_score as Field, \"P1 score mismatch\");\n    assert(scores_after[1] == expected_p2_score as Field, \"P2 score mismatch\");\n\n    // ===== 13. ECDH encryption of card nullifier (FIX-3) =====\n    let opponent_pubkey = EmbeddedCurvePoint {\n        x: opponent_pubkey_x,\n        y: opponent_pubkey_y,\n        is_infinite: false,\n    };\n    let shared_secret = compute_shared_secret(grumpkin_private_key, opponent_pubkey);\n    let computed_encrypted = symmetric_encrypt_field(placed_card_nullifier_secret, shared_secret);\n    assert(\n        computed_encrypted == encrypted_card_nullifier,\n        \"Encrypted nullifier mismatch\",\n    );\n}\n\n// ====================== TEST HELPERS ======================\n\n/// Helper: create a card_commit for test use\nfn test_card_commit(\n    player_secret: Field,\n    player_address: Field,\n    game_id: Field,\n    card_ids: [Field; 5],\n    card_ranks: [[Field; 4]; 5],\n    nullifier_secrets: [Field; 5],\n) -> Field {\n    compute_card_commit(player_secret, player_address, game_id, card_ids, card_ranks, nullifier_secrets)\n}\n\n/// Helper: compute encrypted nullifier for tests\nfn test_encrypt_nullifier(nullifier_secret: Field, player_grumpkin_key: Field, opponent_pubkey: EmbeddedCurvePoint) -> Field {\n    let shared_secret = compute_shared_secret(player_grumpkin_key, opponent_pubkey);\n    symmetric_encrypt_field(nullifier_secret, shared_secret)\n}\n\n/// Helper: derive Grumpkin public key\nfn test_derive_pubkey(private_key: Field) -> EmbeddedCurvePoint {\n    multi_scalar_mul([G], [EmbeddedCurveScalar::from_field(private_key)])\n}\n\n// Default hand data for Player 1 in tests: cards 1-5\n// Mudwalker[1,4,1,5], Blushy[5,1,1,3], Snowdrop[1,3,3,5], Sunny[6,1,1,2], Inkwell[2,3,1,5]\nglobal P1_SECRET: Field = 111;\nglobal P1_ADDRESS: Field = 0xaaa;\nglobal TEST_GAME_ID: Field = 1;\nglobal P1_GRUMPKIN_KEY: Field = 42;\n\nfn p1_card_ids() -> [Field; 5] { [1, 2, 3, 4, 5] }\nfn p1_card_ranks() -> [[Field; 4]; 5] {\n    [[1, 4, 1, 5], [5, 1, 1, 3], [1, 3, 3, 5], [6, 1, 1, 2], [2, 3, 1, 5]]\n}\nfn p1_nullifier_secrets() -> [Field; 5] { [100, 200, 300, 400, 500] }\n\n// Default hand data for Player 2 in tests: cards 10-14\n// Peaches[4,3,2,4], Freckles[2,6,1,6], Camo[7,1,3,1], Neon[6,2,2,3], Glow Bug[5,3,3,4]\nglobal P2_SECRET: Field = 222;\nglobal P2_ADDRESS: Field = 0xbbb;\nglobal P2_GRUMPKIN_KEY: Field = 77;\n\nfn p2_card_ids() -> [Field; 5] { [10, 11, 12, 13, 14] }\nfn p2_card_ranks() -> [[Field; 4]; 5] {\n    [[4, 3, 2, 4], [2, 6, 1, 6], [7, 1, 3, 1], [6, 2, 2, 3], [5, 3, 3, 4]]\n}\nfn p2_nullifier_secrets() -> [Field; 5] { [600, 700, 800, 900, 1000] }\n\nfn get_p1_commit() -> Field {\n    test_card_commit(P1_SECRET, P1_ADDRESS, TEST_GAME_ID, p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets())\n}\n\nfn get_p2_commit() -> Field {\n    test_card_commit(P2_SECRET, P2_ADDRESS, TEST_GAME_ID, p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets())\n}\n\nfn get_p1_pubkey() -> EmbeddedCurvePoint {\n    test_derive_pubkey(P1_GRUMPKIN_KEY)\n}\n\nfn get_p2_pubkey() -> EmbeddedCurvePoint {\n    test_derive_pubkey(P2_GRUMPKIN_KEY)\n}\n\n/// Helper: compute encrypted nullifier for P1 placing a card (P1 encrypts for P2 to decrypt)\nfn p1_encrypt_nullifier(nullifier_secret: Field) -> Field {\n    test_encrypt_nullifier(nullifier_secret, P1_GRUMPKIN_KEY, get_p2_pubkey())\n}\n\n/// Helper: compute encrypted nullifier for P2 placing a card (P2 encrypts for P1 to decrypt)\nfn p2_encrypt_nullifier(nullifier_secret: Field) -> Field {\n    test_encrypt_nullifier(nullifier_secret, P2_GRUMPKIN_KEY, get_p1_pubkey())\n}\n\n// ====================== TESTS ======================\n\n#[test]\nfn test_first_move_no_capture() {\n    // Player 1 places card 1 (Mudwalker) at (0,0) on empty board - no captures possible\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; // card_id = 1 (Mudwalker)\n    board_after[1] = 1; // owner = player1\n    let scores_after: [Field; 2] = [5, 5]; // 1 on board + 4 in hand = 5\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 1 (Mudwalker) has nullifier_secret = 100\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,       // game not ended\n        enc_null,\n        1,          // current_player\n        1,          // card_id (Mudwalker)\n        0, 0,       // row, col\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        // Player 1 hand data\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        // ECDH data\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_second_move_no_capture() {\n    // Player 2 places card 10 (Peaches) at (1,1)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; // card at (0,0): card_id=1, owner=player1\n    board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    board_after[8] = 10; // card at (1,1): card_id=10, owner=player2\n    board_after[9] = 2;\n    let scores_after: [Field; 2] = [5, 5]; // p1: 1+4=5, p2: 1+4=5\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 10 (Peaches) has nullifier_secret = 600\n    let enc_null = p2_encrypt_nullifier(600);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,          // current_player = player2\n        10,         // card_id = Peaches\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        // Player 2 hand data\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        // ECDH data\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n#[test]\nfn test_capture_one_card() {\n    // Player 1 has card 1 (Mudwalker [1,4,1,5]) at (0,0)\n    // Player 2 has card 10 (Peaches [4,3,2,4]) at (0,1)\n    // Player 1 places card 4 (Sunny [6,1,1,2]) at (1,1)\n    // (1,1) is adjacent to (0,1) - placed card's top=6 vs Peaches's bottom=2 -> 6>2 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, player 1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, player 2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;     // (0,0) unchanged\n    board_after[2] = 10; board_after[3] = 1;    // (0,1) CAPTURED - owner changed to player 1\n    board_after[8] = 4; board_after[9] = 1;     // (1,1) placed card 4, player 1\n    let scores_after: [Field; 2] = [6, 4];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 4 (Sunny) has nullifier_secret = 400\n    let enc_null = p1_encrypt_nullifier(400);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1,          // current_player\n        4,          // card_id = Sunny\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_capture_multiple_cards() {\n    // P1 places card 1 Mudwalker [1,4,1,5] at (1,1):\n    // Right (1,2): Card 12 Camo left=1 vs placed right=4 -> 4>1 CAPTURE!\n    // Left (1,0): Card 10 Peaches right=3 vs placed left=5 -> 5>3 CAPTURE!\n    // Top (0,1): Card 11 Freckles bottom=1 vs placed top=1 -> NO (equal)\n    // Bottom (2,1): Card 13 Neon top=6 vs placed bottom=1 -> NO\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;   // (0,1) Freckles\n    board_before[6] = 10; board_before[7] = 2;   // (1,0) Peaches\n    board_before[10] = 12; board_before[11] = 2; // (1,2) Camo\n    board_before[14] = 13; board_before[15] = 2; // (2,1) Neon\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;     // (0,1) unchanged\n    board_after[6] = 10; board_after[7] = 1;     // (1,0) CAPTURED\n    board_after[8] = 1; board_after[9] = 1;      // (1,1) placed\n    board_after[10] = 12; board_after[11] = 1;   // (1,2) CAPTURED\n    board_after[14] = 13; board_after[15] = 2;   // (2,1) unchanged\n    // filled=5, p1_board=3, p2_board=2, p1_played=3, p2_played=2\n    // p1_score = 3 + (5-3) = 5, p2_score = 2 + (5-2) = 5\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 1 (Mudwalker) has nullifier_secret = 100\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1,\n        1,          // card_id = Mudwalker\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_no_capture_higher_adjacent() {\n    // P1 card 3 Snowdrop [1,3,3,5] at (0,0). (0,1) has P2 card 14 Glow Bug [5,3,3,4].\n    // Placed right=3 vs adj left=4. 3<4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 3 (Snowdrop) has nullifier_secret = 300\n    let enc_null = p1_encrypt_nullifier(300);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1,\n        3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p1_wins() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    board_before[2] = 10; board_before[3] = 2;\n    board_before[4] = 2; board_before[5] = 1;\n    board_before[6] = 11; board_before[7] = 2;\n    board_before[8] = 3; board_before[9] = 1;\n    board_before[10] = 12; board_before[11] = 1;\n    board_before[12] = 4; board_before[13] = 1;\n    board_before[14] = 13; board_before[15] = 2;\n\n    let scores_before: [Field; 2] = [6, 4];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    board_after[16] = 5;\n    board_after[17] = 1;\n    // (2,1) card 13 Neon: placed left=5 vs adj right=2 -> 5>2 CAPTURE!\n    board_after[15] = 1;\n\n    let scores_after: [Field; 2] = [7, 3];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 5 (Inkwell) has nullifier_secret = 500\n    let enc_null = p1_encrypt_nullifier(500);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 1,       // game ended, player 1 wins\n        enc_null,\n        1,\n        5,\n        2, 2,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_game_ends_draw() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    // Board where no captures happen on final move -> draw\n    let mut board_before2: [Field; 18] = [0; 18];\n    board_before2[0] = 1; board_before2[1] = 1;\n    board_before2[2] = 10; board_before2[3] = 2;\n    board_before2[4] = 2; board_before2[5] = 1;\n    board_before2[6] = 13; board_before2[7] = 2;\n    board_before2[8] = 3; board_before2[9] = 1;\n    board_before2[10] = 12; board_before2[11] = 2;\n    board_before2[12] = 4; board_before2[13] = 1;\n    board_before2[14] = 11; board_before2[15] = 2; // Freckles [2,6,1,6]\n    let scores_before2: [Field; 2] = [5, 5];\n    let current_turn_before2: Field = 1;\n    let start_hash2 = hash_board_state(board_before2, scores_before2, current_turn_before2);\n\n    let mut board_after2: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after2[i] = board_before2[i];\n    }\n    board_after2[16] = 5;  // Inkwell at (2,2)\n    board_after2[17] = 1;\n    // (1,2) card 12 Camo: placed top=2 vs adj bottom=3 -> NO\n    // (2,1) card 11 Freckles: placed left=5 vs adj right=6 -> NO\n    let scores_after2: [Field; 2] = [5, 5];\n    let end_hash2 = hash_board_state(board_after2, scores_after2, 2);\n\n    // Card 5 (Inkwell) has nullifier_secret = 500\n    let enc_null = p1_encrypt_nullifier(500);\n\n    main(\n        cc1, cc2,\n        start_hash2, end_hash2,\n        1, 3,       // game ended, draw\n        enc_null,\n        1,\n        5,\n        2, 2,\n        board_before2, board_after2,\n        scores_before2, scores_after2,\n        current_turn_before2,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p2_wins() {\n    // P2 places the 9th card and wins with a higher score\n    // Board has 8 cards, it's P2's turn. P2 places card 14 (Glow Bug [5,3,3,4]) at (2,2)\n    // capturing (2,1) which has P1's card 5 (Inkwell [2,3,1,5]) - placed bottom=3 vs adj top=1 -> NO\n    // but (1,2) has P1's card 3 (BiteBug [1,3,3,5]) - placed left=4 vs adj right=3 -> 4>3 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    // Row 0: P1 card 1, P2 card 10, P1 card 2\n    board_before[0] = 1; board_before[1] = 1;    // (0,0) Mudwalker P1\n    board_before[2] = 10; board_before[3] = 2;   // (0,1) Peaches P2\n    board_before[4] = 2; board_before[5] = 1;    // (0,2) Blushy P1\n    // Row 1: P2 card 11, P2 card 12, P1 card 3\n    board_before[6] = 11; board_before[7] = 2;   // (1,0) Freckles P2\n    board_before[8] = 12; board_before[9] = 2;   // (1,1) Camo P2\n    board_before[10] = 3; board_before[11] = 1;  // (1,2) BiteBug P1\n    // Row 2: P2 card 13, P1 card 5, empty (2,2)\n    board_before[12] = 13; board_before[13] = 2; // (2,0) Neon P2\n    board_before[14] = 5; board_before[15] = 1;  // (2,1) Inkwell P1\n\n    // Scores: P1 has 4 on board + 1 in hand = 5, P2 has 4 on board + 1 in hand = 5\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2; // P2's turn\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    // P2 places card 14 (Glow Bug [5,3,3,4]) at (2,2)\n    board_after[16] = 14; board_after[17] = 2;\n\n    // Check captures:\n    // (1,2) BiteBug P1 [1,3,3,5]: placed top=5 vs adj bottom=3 -> 5>3 CAPTURE!\n    board_after[11] = 2; // BiteBug captured by P2\n    // (2,1) Inkwell P1 [2,3,1,5]: placed left=4 vs adj right=3 -> 4>3 CAPTURE!\n    board_after[15] = 2; // Inkwell captured by P2\n\n    // filled=9, p1_board=2, p2_board=7, p1_played=5, p2_played=4\n    // p1_score = 2 + (5-5) = 2, p2_score = 7 + (5-4) = 8\n    let scores_after: [Field; 2] = [2, 8];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 14 (Glow Bug) has nullifier_secret = 1000\n    let enc_null = p2_encrypt_nullifier(1000);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 2,       // game ended, player 2 wins\n        enc_null,\n        2,          // current_player = P2\n        14,         // card_id = Glow Bug\n        2, 2,       // row=2, col=2\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n// ====================== FAILURE TESTS ======================\n\n#[test(should_fail_with = \"Cell not empty\")]\nfn test_fail_place_on_occupied_cell() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 10;\n    board_before[1] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,       // (0,0) is occupied\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Not this player's turn\")]\nfn test_fail_wrong_player_turn() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1; // P1's turn\n\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 10;\n    board_after[1] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    let enc_null = p2_encrypt_nullifier(600);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,          // P2 trying to play on P1's turn\n        10,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Row out of bounds\")]\nfn test_fail_row_out_of_bounds() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n    let end_hash = start_hash;\n\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        3, 0,       // row=3 out of bounds\n        board_before, board_before,\n        scores_before, scores_before,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Placed card not in committed hand\")]\nfn test_fail_card_not_in_hand() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 20;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 20,      // card 20 not in P1's hand\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Player 1 card commit mismatch\")]\nfn test_fail_wrong_player_secret() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        999,        // WRONG player secret\n        P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Non-captured cell owner changed\")]\nfn test_fail_false_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 1;      // FALSE CAPTURE\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(300);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Captured cell owner not updated\")]\nfn test_fail_missing_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;      // NOT captured (WRONG!)\n    board_after[8] = 4; board_after[9] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(400);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 4,\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Non-placed cell card_id changed\")]\nfn test_fail_card_id_changed() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 99; board_after[3] = 2;      // card_id CHANGED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_player2_move_with_capture() {\n    // P2 places card 12 (Camo [7,1,3,1]) at (1,0)\n    // (0,0) has P1 card 1 (Mudwalker [1,4,1,5]).\n    // Placed top=7 vs adj bottom=1 -> 7>1 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 2;      // CAPTURED by P2\n    board_after[6] = 12; board_after[7] = 2;\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 12 (Camo) has nullifier_secret = 800\n    let enc_null = p2_encrypt_nullifier(800);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,\n        12,\n        1, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n#[test]\nfn test_equal_ranks_no_capture() {\n    // P1 card 1 Mudwalker right=4 at (0,0), (0,1) has P2 card 10 Peaches left=4.\n    // 4 == 4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 10; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;      // NOT captured (equal ranks)\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 1 (Mudwalker) has nullifier_secret = 100\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test(should_fail_with = \"Encrypted nullifier mismatch\")]\nfn test_fail_wrong_encrypted_nullifier() {\n    // Correct move but wrong encrypted nullifier\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Use a wrong encrypted nullifier value\n    let wrong_enc_null: Field = 0xdeadbeef;\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        wrong_enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_ecdh_symmetric_encryption() {\n    // Verify that P1 encrypting with P2's pubkey produces something P2 can decrypt\n    // P1 encrypts: shared = P1_priv * P2_pub\n    // P2 decrypts: shared = P2_priv * P1_pub\n    // Both shared secrets should be equal (ECDH property)\n    let p1_pub = get_p1_pubkey();\n    let p2_pub = get_p2_pubkey();\n\n    let shared_1 = compute_shared_secret(P1_GRUMPKIN_KEY, p2_pub);\n    let shared_2 = compute_shared_secret(P2_GRUMPKIN_KEY, p1_pub);\n    assert(shared_1 == shared_2, \"ECDH shared secrets should match\");\n\n    // Encrypt and verify\n    let plaintext: Field = 12345;\n    let ciphertext = symmetric_encrypt_field(plaintext, shared_1);\n    // Decrypt: plaintext = ciphertext - key\n    let key = expand_secret_1(shared_2);\n    let decrypted = ciphertext - key;\n    assert(decrypted == plaintext, \"Decrypted value should match plaintext\");\n}\n\n// ====================== C1 FIX TESTS: Exact Score Verification ======================\n\n#[test(should_fail_with = \"P1 score mismatch\")]\nfn test_score_fabrication_rejected() {\n    // Valid first move (P1 places card 1 at (0,0) on empty board) but with fabricated scores.\n    // Correct scores: p1=5, p2=5 (1 on board + 4 in hand, 0 on board + 5 in hand)\n    // Fabricated: p1=8, p2=2 (would pass the old weak check since 8+2=10, 8>=1, 2>=0)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    // Fabricated scores: should be [5, 5] but attacker claims [8, 2]\n    let scores_after: [Field; 2] = [8, 2];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_exact_scores_after_capture() {\n    // P2 places card 13 (Neon [6,2,2,3]) at (0,1).\n    // (0,0) has P1 card 5 (Inkwell [2,3,1,5]). Placed left=3 vs adj right=3 -> NO (equal)\n    // (1,1) has P1 card 1 (Mudwalker [1,4,1,5]). Placed bottom=2 vs adj top=1 -> 2>1 CAPTURE!\n    // After: filled=4, p1_board=1, p2_board=3(card 10 + card 13 + captured card 1)\n    // p1_played=(4+1)/2=2, p2_played=4/2=2\n    // p1_score=1+(5-2)=4, p2_score=3+(5-2)=6\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 5; board_before[1] = 1;    // (0,0) Inkwell P1\n    board_before[4] = 10; board_before[5] = 2;   // (0,2) Peaches P2\n    board_before[8] = 1; board_before[9] = 1;    // (1,1) Mudwalker P1\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 5; board_after[1] = 1;      // (0,0) Inkwell P1 - unchanged\n    board_after[2] = 13; board_after[3] = 2;     // (0,1) Neon P2 - placed\n    board_after[4] = 10; board_after[5] = 2;     // (0,2) Peaches P2 - unchanged\n    board_after[8] = 1; board_after[9] = 2;      // (1,1) Mudwalker CAPTURED by P2\n    // Exact scores: p1_board=1, p2_board=3, p1_hand=3, p2_hand=3\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 13 (Neon) has nullifier_secret = 900\n    let enc_null = p2_encrypt_nullifier(900);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,\n        13,\n        0, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n    );\n}\n\n// ====================== C2 FIX TESTS: Card Replay Prevention ======================\n\n#[test(should_fail_with = \"Card already placed on board\")]\nfn test_card_replay_rejected() {\n    // P1 already has card 1 (Mudwalker) on board at (0,0).\n    // P1 tries to place card 1 AGAIN at (1,1). Should be rejected.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;\n    board_after[8] = 1; board_after[9] = 1;    // (1,1) card 1 REPLAYED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,          // card_id = 1 (already on board!)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n\n#[test]\nfn test_different_card_after_same_id_on_board() {\n    // P1 has card 1 on board. P1 places card 2 (different card). Should succeed.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 1;   // (0,1) CAPTURED: Blushy top=5 > Peaches bottom=2\n    board_after[8] = 2; board_after[9] = 1;    // (1,1) card 2, different card\n    // filled=3, p1_board=3, p2_board=0, p1_played=2, p2_played=1\n    // p1_score=3+3=6, p2_score=0+4=4\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 2 (Blushy) has nullifier_secret = 200\n    let enc_null = p1_encrypt_nullifier(200);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 2,          // card_id = 2 (different, valid)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n    );\n}\n","path":"/home/ec2-user/aztec-triple-triad/circuits/game_move/src/main.nr"}}}