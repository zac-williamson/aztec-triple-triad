{"noir_version":"1.0.0-beta.18+2db78f8894936db05c53430f364360ac9cc5c61f","hash":"286158375965986714","abi":{"parameters":[{"name":"card_commit_1","type":{"kind":"field"},"visibility":"public"},{"name":"card_commit_2","type":{"kind":"field"},"visibility":"public"},{"name":"start_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"end_state_hash","type":{"kind":"field"},"visibility":"public"},{"name":"game_ended","type":{"kind":"field"},"visibility":"public"},{"name":"winner_id","type":{"kind":"field"},"visibility":"public"},{"name":"encrypted_card_nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"current_player","type":{"kind":"field"},"visibility":"private"},{"name":"card_id","type":{"kind":"field"},"visibility":"private"},{"name":"row","type":{"kind":"field"},"visibility":"private"},{"name":"col","type":{"kind":"field"},"visibility":"private"},{"name":"board_before","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"board_after","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_before","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"scores_after","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"current_turn_before","type":{"kind":"field"},"visibility":"private"},{"name":"player_secret","type":{"kind":"field"},"visibility":"private"},{"name":"player_address","type":{"kind":"field"},"visibility":"private"},{"name":"game_id","type":{"kind":"field"},"visibility":"private"},{"name":"player_card_ids","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"player_card_ranks","type":{"kind":"array","length":5,"type":{"kind":"array","length":4,"type":{"kind":"field"}}},"visibility":"private"},{"name":"player_nullifier_secrets","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"grumpkin_private_key","type":{"kind":"field"},"visibility":"private"},{"name":"opponent_pubkey_x","type":{"kind":"field"},"visibility":"private"},{"name":"opponent_pubkey_y","type":{"kind":"field"},"visibility":"private"},{"name":"move_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"4286976953368078457":{"error_kind":"string","string":"Encrypted nullifier mismatch"},"4487758756370642245":{"error_kind":"string","string":"Start state hash mismatch"},"5077336431726014007":{"error_kind":"string","string":"Placed card ranks do not match database"},"5101543514421470893":{"error_kind":"string","string":"Card already placed on board"},"6511982886681245134":{"error_kind":"string","string":"Placed card not in committed hand"},"7317384265632011736":{"error_kind":"string","string":"Cell not empty (owner)"},"7370811245087594529":{"error_kind":"string","string":"Captured cell owner not updated"},"7520349170859696597":{"error_kind":"string","string":"Card not placed correctly"},"8084300406162371689":{"error_kind":"string","string":"Player 2 card commit mismatch"},"8749084135167576643":{"error_kind":"string","string":"Invalid player"},"9296992678443765102":{"error_kind":"string","string":"Non-placed cell card_id changed"},"9336663072722308931":{"error_kind":"string","string":"Owner not set correctly"},"9573161043312537276":{"error_kind":"string","string":"Should be a draw"},"9697039476693520435":{"error_kind":"string","string":"Player 2 should be winner"},"9715689440484907290":{"error_kind":"string","string":"Game should have ended"},"9915128275385804551":{"error_kind":"string","string":"Player 1 should be winner"},"10202045805087973061":{"error_kind":"string","string":"move_index must be 0-8"},"11936972275297119974":{"error_kind":"string","string":"Invalid card ID for rank lookup"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12724384224350165649":{"error_kind":"string","string":"End state hash mismatch"},"14199193565343435108":{"error_kind":"string","string":"opponent public key not on Grumpkin curve"},"14336771847768869760":{"error_kind":"string","string":"Not this player's turn"},"14904510168980638594":{"error_kind":"string","string":"Cell not empty"},"14918566239196857362":{"error_kind":"string","string":"grumpkin_private_key must be non-zero"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15156018542597224275":{"error_kind":"string","string":"Player 1 card commit mismatch"},"15353634778740263988":{"error_kind":"string","string":"Game should not have ended"},"15521846062275453407":{"error_kind":"string","string":"Col out of bounds"},"15667510634133007812":{"error_kind":"string","string":"move_index does not match board state"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16309609255298369368":{"error_kind":"string","string":"Row out of bounds"},"16422110396685134300":{"error_kind":"string","string":"P1 score mismatch"},"17174323770794875209":{"error_kind":"string","string":"Non-captured cell owner changed"},"18125798406593280834":{"error_kind":"string","string":"No winner yet"},"18256603403857491958":{"error_kind":"string","string":"P2 score mismatch"},"18302579419004363433":{"error_kind":"string","string":"Opponent pubkey is point at infinity"}}},"bytecode":"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","debug_symbols":"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","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n//\n// IMPORTANT: Prefer `multi_scalar_mul()` over repeated `embedded_curve_add()`\n// for adding multiple points. This is significantly more efficient.\n// For adding exactly 2 points, use `embedded_curve_add()` directly.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// Elliptic curve addition\n/// IMPORTANT: this function is expected to perform a full addition in order to handle all corner cases:\n/// - points on the curve\n/// - point doubling\n/// - point at infinity\n/// As a result, you may not get optimal performance, depending on the assumptions of your inputs.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // avoid calling the black box function for trivial cases\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_inner(point1, point2)\n        }\n    } else {\n        embedded_curve_add_inner(point1, point2)\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// EC addition wrapper for the foreign function\nfn embedded_curve_add_inner(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    crate::assert_constant(separator);\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"52":{"source":"/// Game Move circuit.\n/// Proves that a game move is valid: one card placed from correct player,\n/// board state correctly updated with capture logic.\n/// Also computes ECDH shared secret to encrypt the placed card's nullifier.\n///\n/// Public inputs:\n///   card_commit_1, card_commit_2 - player card commitments (include ranks)\n///   start_state_hash - hash of board state before this move\n///   end_state_hash - hash of board state after this move\n///   game_ended - 1 if game over, 0 otherwise\n///   winner_id - 0=not ended, 1=player1 wins, 2=player2 wins, 3=draw\n///   encrypted_card_nullifier - the placed card's nullifier secret, encrypted with ECDH shared key\n///\n/// The circuit verifies:\n/// 1. The placed card is in the current player's committed hand (card_commit binding)\n/// 2. Capture logic: rank comparison for all adjacent opponent cells\n/// 3. Non-placed, non-captured cells are unchanged between board_before/board_after\n/// 4. Scores are consistent with board ownership + hand counts\n/// 5. Game end detection and winner determination\n/// 6. ECDH encryption of placed card's nullifier secret\n\n/// Board cell: each cell is (card_id, owner) where owner 0=empty, 1=player1, 2=player2\n\nuse std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n// External poseidon dep removed; using stdlib pedersen_hash instead\n\n/// Grumpkin generator point G\nglobal G: EmbeddedCurvePoint = EmbeddedCurvePoint {\n    x: 0x083e7911d835097629f0067531fc15cafd79a89beecb39903f69572c636f4a5a,\n    y: 0x1a7f5efaad7f315c25a918f30cc8d7333fccab7ad7c90f14de81bcc528f9935d,\n    is_infinite: false,\n};\n\n/// Compute ECDH shared secret: shared_point = my_private_key * opponent_public_key\nfn compute_shared_secret(my_private_key: Field, opponent_pubkey: EmbeddedCurvePoint) -> Field {\n    let shared_point = multi_scalar_mul(\n        [opponent_pubkey],\n        [EmbeddedCurveScalar::from_field(my_private_key)],\n    );\n    shared_point.x\n}\n\n/// Key expansion for symmetric encryption using pedersen hash with move-index nonce.\n/// The nonce (current_turn_before) ensures a unique key per move, preventing\n/// an attacker who recovers one plaintext from decrypting all other moves.\nfn expand_secret(secret: Field, nonce: Field) -> Field {\n    std::hash::pedersen_hash([secret, nonce])\n}\n\n/// Symmetric encrypt a single field element using ECDH shared secret and move nonce.\nfn symmetric_encrypt_field(plaintext: Field, secret: Field, nonce: Field) -> Field {\n    let key = expand_secret(secret, nonce);\n    key + plaintext\n}\n\n// ====================== CARD DATABASE ======================\n/// Hardcoded card rank database: 50 cards with ranks [top, right, bottom, left].\nfn get_card_ranks(card_id: u32) -> [Field; 4] {\n    assert((card_id >= 1) & (card_id <= 50), \"Invalid card ID for rank lookup\");\n\n    // Level 1 - Common (IDs 1-10)\n    if card_id == 1 { [1, 4, 1, 5] }         // Mudwalker\n    else if card_id == 2 { [5, 1, 1, 3] }    // Blushy\n    else if card_id == 3 { [1, 3, 3, 5] }    // Snowdrop\n    else if card_id == 4 { [6, 1, 1, 2] }    // Sunny\n    else if card_id == 5 { [2, 3, 1, 5] }    // Inkwell\n    else if card_id == 6 { [2, 1, 4, 4] }    // Stripes\n    else if card_id == 7 { [1, 5, 4, 1] }    // Barkeeper\n    else if card_id == 8 { [3, 1, 5, 2] }    // Dotty\n    else if card_id == 9 { [2, 1, 6, 1] }    // Penny\n    else if card_id == 10 { [4, 3, 2, 4] }   // Peaches\n    // Level 2 - Uncommon (IDs 11-20)\n    else if card_id == 11 { [2, 6, 1, 6] }   // Freckles\n    else if card_id == 12 { [7, 1, 3, 1] }   // Camo\n    else if card_id == 13 { [6, 2, 2, 3] }   // Neon\n    else if card_id == 14 { [5, 3, 3, 4] }   // Glow Bug\n    else if card_id == 15 { [6, 1, 4, 3] }   // Limelight\n    else if card_id == 16 { [3, 4, 5, 3] }   // Marble\n    else if card_id == 17 { [5, 3, 2, 5] }   // Sapphire\n    else if card_id == 18 { [5, 1, 3, 5] }   // Jefferson\n    else if card_id == 19 { [5, 2, 5, 2] }   // Longfoot\n    else if card_id == 20 { [4, 2, 4, 5] }   // Featherfin\n    // Level 3 - Rare (IDs 21-30)\n    else if card_id == 21 { [3, 7, 2, 5] }   // Lilac\n    else if card_id == 22 { [5, 2, 5, 5] }   // Patches\n    else if card_id == 23 { [6, 6, 3, 3] }   // Faded\n    else if card_id == 24 { [6, 3, 6, 3] }   // Gold Dust\n    else if card_id == 25 { [3, 5, 5, 5] }   // Phantom\n    else if card_id == 26 { [7, 5, 1, 3] }   // Ash\n    else if card_id == 27 { [7, 1, 5, 3] }   // Cocoa\n    else if card_id == 28 { [5, 3, 6, 3] }   // Ringmaster\n    else if card_id == 29 { [5, 6, 2, 4] }   // Goldrush\n    else if card_id == 30 { [4, 4, 7, 2] }   // Swampling\n    // Level 4 - Epic (IDs 31-40)\n    else if card_id == 31 { [3, 6, 4, 7] }   // Glitter\n    else if card_id == 32 { [7, 2, 3, 7] }   // Starfield\n    else if card_id == 33 { [2, 3, 7, 7] }   // Specter\n    else if card_id == 34 { [6, 5, 5, 5] }   // Saffron\n    else if card_id == 35 { [4, 7, 6, 2] }   // Stardust\n    else if card_id == 36 { [2, 3, 7, 8] }   // Achoque\n    else if card_id == 37 { [1, 7, 6, 4] }   // Zacapu\n    else if card_id == 38 { [7, 3, 1, 6] }   // Laguna\n    else if card_id == 39 { [7, 4, 4, 4] }   // Streamwalker\n    else if card_id == 40 { [3, 7, 3, 6] }   // Digger\n    // Level 5 - Legendary (IDs 41-50)\n    else if card_id == 41 { [6, 7, 3, 7] }   // Eclipse\n    else if card_id == 42 { [6, 5, 8, 4] }   // Kaleidoscope\n    else if card_id == 43 { [6, 5, 6, 6] }   // Twinned\n    else if card_id == 44 { [3, 6, 7, 8] }   // Sparkletail\n    else if card_id == 45 { [7, 6, 5, 6] }   // Riddler\n    else if card_id == 46 { [3, 10, 2, 1] }  // Rosita\n    else if card_id == 47 { [6, 2, 6, 7] }   // Brooklet\n    else if card_id == 48 { [5, 5, 7, 6] }   // Whisper\n    else if card_id == 49 { [7, 7, 4, 2] }   // Misty\n    else { [7, 2, 7, 4] }                    // Lerma (50)\n}\n\n// ====================== HASH FUNCTIONS ======================\n\nfn hash_board_state(board: [Field; 18], scores: [Field; 2], current_turn: Field) -> Field {\n    let mut inputs: [Field; 21] = [0; 21];\n    for i in 0..18 {\n        inputs[i] = board[i];\n    }\n    inputs[18] = scores[0];\n    inputs[19] = scores[1];\n    inputs[20] = current_turn;\n    std::hash::pedersen_hash(inputs)\n}\n\n/// Compute card commitment hash (must match prove_hand format).\n/// Format: hash(player_secret, player_address, game_id,\n///              card_ids[5], card_ranks[5*4], nullifier_secrets[5])\nfn compute_card_commit(\n    player_secret: Field,\n    player_address: Field,\n    game_id: Field,\n    card_ids: [Field; 5],\n    card_ranks: [[Field; 4]; 5],\n    nullifier_secrets: [Field; 5],\n) -> Field {\n    let mut hash_inputs: [Field; 33] = [0; 33];\n    hash_inputs[0] = player_secret;\n    hash_inputs[1] = player_address;\n    hash_inputs[2] = game_id;\n    for i in 0..5 {\n        hash_inputs[3 + i] = card_ids[i];\n    }\n    for i in 0..5 {\n        for j in 0..4 {\n            hash_inputs[8 + i * 4 + j] = card_ranks[i][j];\n        }\n    }\n    for i in 0..5 {\n        hash_inputs[28 + i] = nullifier_secrets[i];\n    }\n    std::hash::pedersen_hash(hash_inputs)\n}\n\n// ====================== MAIN CIRCUIT ======================\n\nfn main(\n    // Public inputs\n    card_commit_1: pub Field,\n    card_commit_2: pub Field,\n    start_state_hash: pub Field,\n    end_state_hash: pub Field,\n    game_ended: pub Field,\n    winner_id: pub Field,\n    encrypted_card_nullifier: pub Field,\n    // Private inputs - move data\n    current_player: Field,       // 1 or 2\n    card_id: Field,              // ID of card being placed\n    row: Field,                  // 0-2\n    col: Field,                  // 0-2\n    // Private inputs - board state\n    board_before: [Field; 18],   // 9 cells x 2 fields (card_id, owner)\n    board_after: [Field; 18],\n    scores_before: [Field; 2],\n    scores_after: [Field; 2],\n    current_turn_before: Field,\n    // Private inputs - current player's hand commitment data\n    player_secret: Field,\n    player_address: Field,\n    game_id: Field,\n    player_card_ids: [Field; 5],\n    player_card_ranks: [[Field; 4]; 5],\n    player_nullifier_secrets: [Field; 5],\n    // Private inputs - ECDH encryption (FIX-3)\n    grumpkin_private_key: Field,\n    opponent_pubkey_x: Field,\n    opponent_pubkey_y: Field,\n    // Private input - move index for unique encryption nonce (V7 Fix 3.1)\n    move_index: Field,\n) {\n    // ===== 1. Validate current player =====\n    assert(\n        (current_player == 1) | (current_player == 2),\n        \"Invalid player\",\n    );\n    assert(current_player == current_turn_before, \"Not this player's turn\");\n\n    // ===== 2. Validate position =====\n    let r = row as u32;\n    let c = col as u32;\n    assert(r < 3, \"Row out of bounds\");\n    assert(c < 3, \"Col out of bounds\");\n\n    // ===== 2b. Validate move_index (V7 Fix 3.1) =====\n    let mi = move_index as u32;\n    assert(mi < 9, \"move_index must be 0-8\");\n    // Verify move_index matches number of filled cells in board_before\n    let mut filled_before: u32 = 0;\n    for i in 0..9 {\n        if board_before[i * 2] != 0 {\n            filled_before += 1;\n        }\n    }\n    assert(move_index == filled_before as Field, \"move_index does not match board state\");\n\n    // ===== 3. Verify card_commit binding (FIX-1) =====\n    // Recompute the current player's card_commit from their hand data\n    let recomputed_commit = compute_card_commit(\n        player_secret,\n        player_address,\n        game_id,\n        player_card_ids,\n        player_card_ranks,\n        player_nullifier_secrets,\n    );\n\n    // Verify it matches the correct card_commit (1 or 2 based on current_player)\n    if current_player == 1 {\n        assert(recomputed_commit == card_commit_1, \"Player 1 card commit mismatch\");\n    } else {\n        assert(recomputed_commit == card_commit_2, \"Player 2 card commit mismatch\");\n    }\n\n    // ===== 4. Verify placed card is in committed hand =====\n    let mut card_found: bool = false;\n    let mut placed_card_ranks: [Field; 4] = [0; 4];\n    let mut placed_card_nullifier_secret: Field = 0;\n    for i in 0..5 {\n        if player_card_ids[i] == card_id {\n            card_found = true;\n            placed_card_ranks = player_card_ranks[i];\n            placed_card_nullifier_secret = player_nullifier_secrets[i];\n        }\n    }\n    assert(card_found, \"Placed card not in committed hand\");\n\n    // ===== NEW: Verify card has not already been placed (C2 fix) =====\n    for i in 0..9 {\n        if board_before[i * 2 + 1] != 0 {\n            // Cell is occupied -- verify it's not the same card\n            assert(board_before[i * 2] != card_id, \"Card already placed on board\");\n        }\n    }\n\n    // Verify the committed ranks match the hardcoded card database\n    let db_ranks = get_card_ranks(card_id as u32);\n    for i in 0..4 {\n        assert(\n            placed_card_ranks[i] == db_ranks[i],\n            \"Placed card ranks do not match database\",\n        );\n    }\n\n    // ===== 5. Verify the cell was empty before the move =====\n    let cell_idx = r * 3 + c;\n    assert(board_before[cell_idx * 2] == 0, \"Cell not empty\");\n    assert(board_before[cell_idx * 2 + 1] == 0, \"Cell not empty (owner)\");\n\n    // ===== 6. Verify the card was placed in board_after =====\n    assert(board_after[cell_idx * 2] == card_id, \"Card not placed correctly\");\n    assert(\n        board_after[cell_idx * 2 + 1] == current_player,\n        \"Owner not set correctly\",\n    );\n\n    // ===== 7. Capture logic (FIX-2) =====\n    // Determine the opponent\n    let opponent: Field = if current_player == 1 { 2 } else { 1 };\n\n    // Track which cells are captured (1 = captured, 0 = not)\n    let mut captured: [bool; 9] = [false; 9];\n\n    // Check all 4 adjacent directions:\n    // Direction 0: Top    (row-1, col)   - placed card's top vs adjacent card's bottom\n    // Direction 1: Right  (row, col+1)   - placed card's right vs adjacent card's left\n    // Direction 2: Bottom (row+1, col)   - placed card's bottom vs adjacent card's top\n    // Direction 3: Left   (row, col-1)   - placed card's left vs adjacent card's right\n\n    // placed_card_ranks: [top, right, bottom, left]\n    // adjacent ranks:    [top=0, right=1, bottom=2, left=3]\n    // Facing rank pairs: placed_top vs adj_bottom, placed_right vs adj_left,\n    //                    placed_bottom vs adj_top, placed_left vs adj_right\n\n    // Direction 0: Top (row-1, col)\n    if r > 0 {\n        let adj_idx = (r - 1) * 3 + c;\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's top vs adjacent card's bottom\n            let placed_rank = placed_card_ranks[0] as u32;\n            let adj_rank = adj_ranks[2] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 1: Right (row, col+1)\n    if c < 2 {\n        let adj_idx = r * 3 + (c + 1);\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's right vs adjacent card's left\n            let placed_rank = placed_card_ranks[1] as u32;\n            let adj_rank = adj_ranks[3] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 2: Bottom (row+1, col)\n    if r < 2 {\n        let adj_idx = (r + 1) * 3 + c;\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's bottom vs adjacent card's top\n            let placed_rank = placed_card_ranks[2] as u32;\n            let adj_rank = adj_ranks[0] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // Direction 3: Left (row, col-1)\n    if c > 0 {\n        let adj_idx = r * 3 + (c - 1);\n        let adj_card_id = board_before[adj_idx * 2];\n        let adj_owner = board_before[adj_idx * 2 + 1];\n        if (adj_card_id != 0) & (adj_owner == opponent) {\n            let adj_ranks = get_card_ranks(adj_card_id as u32);\n            // Placed card's left vs adjacent card's right\n            let placed_rank = placed_card_ranks[3] as u32;\n            let adj_rank = adj_ranks[1] as u32;\n            if placed_rank > adj_rank {\n                captured[adj_idx] = true;\n            }\n        }\n    }\n\n    // ===== 8. Verify board_after matches expected state =====\n    // For each cell, verify:\n    // - Placed cell: already verified above (card_id and owner)\n    // - Captured cell: card_id unchanged, owner changed to current_player\n    // - All other cells: identical to board_before\n    for i in 0..9 {\n        if i as u32 != cell_idx {\n            let before_card = board_before[i * 2];\n            let before_owner = board_before[i * 2 + 1];\n            let after_card = board_after[i * 2];\n            let after_owner = board_after[i * 2 + 1];\n\n            // Card ID must never change for non-placed cells\n            assert(after_card == before_card, \"Non-placed cell card_id changed\");\n\n            if captured[i] {\n                // Captured cell: owner must change to current_player\n                assert(\n                    after_owner == current_player,\n                    \"Captured cell owner not updated\",\n                );\n            } else {\n                // Non-captured cell: owner must stay the same\n                assert(after_owner == before_owner, \"Non-captured cell owner changed\");\n            }\n        }\n    }\n\n    // ===== 9. Verify start_state_hash matches board_before =====\n    let computed_start = hash_board_state(board_before, scores_before, current_turn_before);\n    assert(computed_start == start_state_hash, \"Start state hash mismatch\");\n\n    // ===== 10. Compute and verify end state =====\n    let next_turn: Field = if current_player == 1 { 2 } else { 1 };\n    let computed_end = hash_board_state(board_after, scores_after, next_turn);\n    assert(computed_end == end_state_hash, \"End state hash mismatch\");\n\n    // ===== 11. Verify game ended flag =====\n    let mut filled: u32 = 0;\n    for i in 0..9 {\n        if board_after[i * 2] != 0 {\n            filled += 1;\n        }\n    }\n\n    if filled == 9 {\n        assert(game_ended == 1, \"Game should have ended\");\n        let p1_score = scores_after[0] as u32;\n        let p2_score = scores_after[1] as u32;\n        if p1_score > p2_score {\n            assert(winner_id == 1, \"Player 1 should be winner\");\n        } else if p2_score > p1_score {\n            assert(winner_id == 2, \"Player 2 should be winner\");\n        } else {\n            assert(winner_id == 3, \"Should be a draw\");\n        }\n    } else {\n        assert(game_ended == 0, \"Game should not have ended\");\n        assert(winner_id == 0, \"No winner yet\");\n    }\n\n    // ===== 12. Verify scores are exactly correct (C1 fix) =====\n    let mut p1_board: u32 = 0;\n    let mut p2_board: u32 = 0;\n    for i in 0..9 {\n        let owner = board_after[i * 2 + 1];\n        if owner == 1 {\n            p1_board += 1;\n        } else if owner == 2 {\n            p2_board += 1;\n        }\n    }\n    // Player 1 goes first, so P1 has placed ceil(filled/2) cards, P2 has placed floor(filled/2)\n    let p1_played = (filled + 1) / 2;\n    let p2_played = filled / 2;\n    let p1_hand = 5 - p1_played;\n    let p2_hand = 5 - p2_played;\n    let expected_p1_score = p1_board + p1_hand;\n    let expected_p2_score = p2_board + p2_hand;\n    assert(scores_after[0] == expected_p1_score as Field, \"P1 score mismatch\");\n    assert(scores_after[1] == expected_p2_score as Field, \"P2 score mismatch\");\n\n    // ===== 13. Validate Grumpkin private key is non-zero (V6 Fix 3.1) =====\n    assert(grumpkin_private_key != 0, \"grumpkin_private_key must be non-zero\");\n\n    // ===== 14. Validate opponent public key (V7 Fix 3.2 + V6 Fix 3.3) =====\n    // Check point-at-infinity (V7 Fix 3.2)\n    assert((opponent_pubkey_x != 0) | (opponent_pubkey_y != 0), \"Opponent pubkey is point at infinity\");\n    // Grumpkin curve equation: y^2 = x^3 - 17 (a=0, b=-17)\n    let x3 = opponent_pubkey_x * opponent_pubkey_x * opponent_pubkey_x;\n    let y2 = opponent_pubkey_y * opponent_pubkey_y;\n    assert(y2 == x3 - 17, \"opponent public key not on Grumpkin curve\");\n\n    // ===== 15. ECDH encryption of card nullifier =====\n    let opponent_pubkey = EmbeddedCurvePoint {\n        x: opponent_pubkey_x,\n        y: opponent_pubkey_y,\n        is_infinite: false,\n    };\n    let shared_secret = compute_shared_secret(grumpkin_private_key, opponent_pubkey);\n    // Use move_index as nonce for per-move unique key (V7 Fix 3.1, replaces V6 current_turn_before)\n    let computed_encrypted = symmetric_encrypt_field(placed_card_nullifier_secret, shared_secret, move_index);\n    assert(\n        computed_encrypted == encrypted_card_nullifier,\n        \"Encrypted nullifier mismatch\",\n    );\n}\n\n// ====================== TEST HELPERS ======================\n\n/// Helper: create a card_commit for test use\nfn test_card_commit(\n    player_secret: Field,\n    player_address: Field,\n    game_id: Field,\n    card_ids: [Field; 5],\n    card_ranks: [[Field; 4]; 5],\n    nullifier_secrets: [Field; 5],\n) -> Field {\n    compute_card_commit(player_secret, player_address, game_id, card_ids, card_ranks, nullifier_secrets)\n}\n\n/// Helper: compute encrypted nullifier for tests (with move_index nonce)\nfn test_encrypt_nullifier(nullifier_secret: Field, player_grumpkin_key: Field, opponent_pubkey: EmbeddedCurvePoint, move_index: Field) -> Field {\n    let shared_secret = compute_shared_secret(player_grumpkin_key, opponent_pubkey);\n    symmetric_encrypt_field(nullifier_secret, shared_secret, move_index)\n}\n\n/// Helper: derive Grumpkin public key\nfn test_derive_pubkey(private_key: Field) -> EmbeddedCurvePoint {\n    multi_scalar_mul([G], [EmbeddedCurveScalar::from_field(private_key)])\n}\n\n// Default hand data for Player 1 in tests: cards 1-5\n// Mudwalker[1,4,1,5], Blushy[5,1,1,3], Snowdrop[1,3,3,5], Sunny[6,1,1,2], Inkwell[2,3,1,5]\nglobal P1_SECRET: Field = 111;\nglobal P1_ADDRESS: Field = 0xaaa;\nglobal TEST_GAME_ID: Field = 1;\nglobal P1_GRUMPKIN_KEY: Field = 42;\n\nfn p1_card_ids() -> [Field; 5] { [1, 2, 3, 4, 5] }\nfn p1_card_ranks() -> [[Field; 4]; 5] {\n    [[1, 4, 1, 5], [5, 1, 1, 3], [1, 3, 3, 5], [6, 1, 1, 2], [2, 3, 1, 5]]\n}\nfn p1_nullifier_secrets() -> [Field; 5] { [100, 200, 300, 400, 500] }\n\n// Default hand data for Player 2 in tests: cards 10-14\n// Peaches[4,3,2,4], Freckles[2,6,1,6], Camo[7,1,3,1], Neon[6,2,2,3], Glow Bug[5,3,3,4]\nglobal P2_SECRET: Field = 222;\nglobal P2_ADDRESS: Field = 0xbbb;\nglobal P2_GRUMPKIN_KEY: Field = 77;\n\nfn p2_card_ids() -> [Field; 5] { [10, 11, 12, 13, 14] }\nfn p2_card_ranks() -> [[Field; 4]; 5] {\n    [[4, 3, 2, 4], [2, 6, 1, 6], [7, 1, 3, 1], [6, 2, 2, 3], [5, 3, 3, 4]]\n}\nfn p2_nullifier_secrets() -> [Field; 5] { [600, 700, 800, 900, 1000] }\n\nfn get_p1_commit() -> Field {\n    test_card_commit(P1_SECRET, P1_ADDRESS, TEST_GAME_ID, p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets())\n}\n\nfn get_p2_commit() -> Field {\n    test_card_commit(P2_SECRET, P2_ADDRESS, TEST_GAME_ID, p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets())\n}\n\nfn get_p1_pubkey() -> EmbeddedCurvePoint {\n    test_derive_pubkey(P1_GRUMPKIN_KEY)\n}\n\nfn get_p2_pubkey() -> EmbeddedCurvePoint {\n    test_derive_pubkey(P2_GRUMPKIN_KEY)\n}\n\n/// Helper: compute encrypted nullifier for P1 placing a card (P1 encrypts for P2 to decrypt)\nfn p1_encrypt_nullifier(nullifier_secret: Field, nonce: Field) -> Field {\n    test_encrypt_nullifier(nullifier_secret, P1_GRUMPKIN_KEY, get_p2_pubkey(), nonce)\n}\n\n/// Helper: compute encrypted nullifier for P2 placing a card (P2 encrypts for P1 to decrypt)\nfn p2_encrypt_nullifier(nullifier_secret: Field, nonce: Field) -> Field {\n    test_encrypt_nullifier(nullifier_secret, P2_GRUMPKIN_KEY, get_p1_pubkey(), nonce)\n}\n\n// ====================== TESTS ======================\n\n#[test]\nfn test_first_move_no_capture() {\n    // Player 1 places card 1 (Mudwalker) at (0,0) on empty board - no captures possible\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; // card_id = 1 (Mudwalker)\n    board_after[1] = 1; // owner = player1\n    let scores_after: [Field; 2] = [5, 5]; // 1 on board + 4 in hand = 5\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 1 (Mudwalker) has nullifier_secret = 100, move_index = 0 (empty board)\n    let enc_null = p1_encrypt_nullifier(100, 0);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,       // game not ended\n        enc_null,\n        1,          // current_player\n        1,          // card_id (Mudwalker)\n        0, 0,       // row, col\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        // Player 1 hand data\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        // ECDH data\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        0,          // move_index = 0 (empty board)\n    );\n}\n\n#[test]\nfn test_second_move_no_capture() {\n    // Player 2 places card 10 (Peaches) at (1,1)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; // card at (0,0): card_id=1, owner=player1\n    board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    board_after[8] = 10; // card at (1,1): card_id=10, owner=player2\n    board_after[9] = 2;\n    let scores_after: [Field; 2] = [5, 5]; // p1: 1+4=5, p2: 1+4=5\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 10 (Peaches) has nullifier_secret = 600, move_index = 1 (1 card on board)\n    let enc_null = p2_encrypt_nullifier(600, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,          // current_player = player2\n        10,         // card_id = Peaches\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        // Player 2 hand data\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        // ECDH data\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n        1,          // move_index = 1 (1 card on board)\n    );\n}\n\n#[test]\nfn test_capture_one_card() {\n    // Player 1 has card 1 (Mudwalker [1,4,1,5]) at (0,0)\n    // Player 2 has card 10 (Peaches [4,3,2,4]) at (0,1)\n    // Player 1 places card 4 (Sunny [6,1,1,2]) at (1,1)\n    // (1,1) is adjacent to (0,1) - placed card's top=6 vs Peaches's bottom=2 -> 6>2 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, player 1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, player 2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;     // (0,0) unchanged\n    board_after[2] = 10; board_after[3] = 1;    // (0,1) CAPTURED - owner changed to player 1\n    board_after[8] = 4; board_after[9] = 1;     // (1,1) placed card 4, player 1\n    let scores_after: [Field; 2] = [6, 4];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 4 (Sunny) has nullifier_secret = 400, move_index = 2 (2 cards on board)\n    let enc_null = p1_encrypt_nullifier(400, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1,          // current_player\n        4,          // card_id = Sunny\n        1, 1,       // row=1, col=1\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        2,          // move_index = 2 (2 cards on board)\n    );\n}\n\n#[test]\nfn test_capture_multiple_cards() {\n    // P1 places card 1 Mudwalker [1,4,1,5] at (1,1):\n    // Right (1,2): Card 12 Camo left=1 vs placed right=4 -> 4>1 CAPTURE!\n    // Left (1,0): Card 10 Peaches right=3 vs placed left=5 -> 5>3 CAPTURE!\n    // Top (0,1): Card 11 Freckles bottom=1 vs placed top=1 -> NO (equal)\n    // Bottom (2,1): Card 13 Neon top=6 vs placed bottom=1 -> NO\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;   // (0,1) Freckles\n    board_before[6] = 10; board_before[7] = 2;   // (1,0) Peaches\n    board_before[10] = 12; board_before[11] = 2; // (1,2) Camo\n    board_before[14] = 13; board_before[15] = 2; // (2,1) Neon\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;     // (0,1) unchanged\n    board_after[6] = 10; board_after[7] = 1;     // (1,0) CAPTURED\n    board_after[8] = 1; board_after[9] = 1;      // (1,1) placed\n    board_after[10] = 12; board_after[11] = 1;   // (1,2) CAPTURED\n    board_after[14] = 13; board_after[15] = 2;   // (2,1) unchanged\n    // filled=5, p1_board=3, p2_board=2, p1_played=3, p2_played=2\n    // p1_score = 3 + (5-3) = 5, p2_score = 2 + (5-2) = 5\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 1 (Mudwalker) has nullifier_secret = 100, move_index = 4 (4 cards on board)\n    let enc_null = p1_encrypt_nullifier(100, 4);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1,\n        1,          // card_id = Mudwalker\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        4,          // move_index = 4 (4 cards on board)\n    );\n}\n\n#[test]\nfn test_no_capture_higher_adjacent() {\n    // P1 card 3 Snowdrop [1,3,3,5] at (0,0). (0,1) has P2 card 14 Glow Bug [5,3,3,4].\n    // Placed right=3 vs adj left=4. 3<4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 3 (Snowdrop) has nullifier_secret = 300, move_index = 1 (1 card on board)\n    let enc_null = p1_encrypt_nullifier(300, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1,\n        3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        1,          // move_index = 1 (1 card on board)\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p1_wins() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    board_before[2] = 10; board_before[3] = 2;\n    board_before[4] = 2; board_before[5] = 1;\n    board_before[6] = 11; board_before[7] = 2;\n    board_before[8] = 3; board_before[9] = 1;\n    board_before[10] = 12; board_before[11] = 1;\n    board_before[12] = 4; board_before[13] = 1;\n    board_before[14] = 13; board_before[15] = 2;\n\n    let scores_before: [Field; 2] = [6, 4];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    board_after[16] = 5;\n    board_after[17] = 1;\n    // (2,1) card 13 Neon: placed left=5 vs adj right=2 -> 5>2 CAPTURE!\n    board_after[15] = 1;\n\n    let scores_after: [Field; 2] = [7, 3];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 5 (Inkwell) has nullifier_secret = 500, move_index = 8 (8 cards on board)\n    let enc_null = p1_encrypt_nullifier(500, 8);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 1,       // game ended, player 1 wins\n        enc_null,\n        1,\n        5,\n        2, 2,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        8,          // move_index = 8 (8 cards on board)\n    );\n}\n\n#[test]\nfn test_game_ends_draw() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    // Board where no captures happen on final move -> draw\n    let mut board_before2: [Field; 18] = [0; 18];\n    board_before2[0] = 1; board_before2[1] = 1;\n    board_before2[2] = 10; board_before2[3] = 2;\n    board_before2[4] = 2; board_before2[5] = 1;\n    board_before2[6] = 13; board_before2[7] = 2;\n    board_before2[8] = 3; board_before2[9] = 1;\n    board_before2[10] = 12; board_before2[11] = 2;\n    board_before2[12] = 4; board_before2[13] = 1;\n    board_before2[14] = 11; board_before2[15] = 2; // Freckles [2,6,1,6]\n    let scores_before2: [Field; 2] = [5, 5];\n    let current_turn_before2: Field = 1;\n    let start_hash2 = hash_board_state(board_before2, scores_before2, current_turn_before2);\n\n    let mut board_after2: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after2[i] = board_before2[i];\n    }\n    board_after2[16] = 5;  // Inkwell at (2,2)\n    board_after2[17] = 1;\n    // (1,2) card 12 Camo: placed top=2 vs adj bottom=3 -> NO\n    // (2,1) card 11 Freckles: placed left=5 vs adj right=6 -> NO\n    let scores_after2: [Field; 2] = [5, 5];\n    let end_hash2 = hash_board_state(board_after2, scores_after2, 2);\n\n    // Card 5 (Inkwell) has nullifier_secret = 500, move_index = 8 (8 cards on board)\n    let enc_null = p1_encrypt_nullifier(500, 8);\n\n    main(\n        cc1, cc2,\n        start_hash2, end_hash2,\n        1, 3,       // game ended, draw\n        enc_null,\n        1,\n        5,\n        2, 2,\n        board_before2, board_after2,\n        scores_before2, scores_after2,\n        current_turn_before2,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        8,          // move_index = 8 (8 cards on board)\n    );\n}\n\n#[test]\nfn test_final_move_game_ends_p2_wins() {\n    // P2 places the 9th card and wins with a higher score\n    // Board has 8 cards, it's P2's turn. P2 places card 14 (Glow Bug [5,3,3,4]) at (2,2)\n    // capturing (2,1) which has P1's card 5 (Inkwell [2,3,1,5]) - placed bottom=3 vs adj top=1 -> NO\n    // but (1,2) has P1's card 3 (BiteBug [1,3,3,5]) - placed left=4 vs adj right=3 -> 4>3 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    // Row 0: P1 card 1, P2 card 10, P1 card 2\n    board_before[0] = 1; board_before[1] = 1;    // (0,0) Mudwalker P1\n    board_before[2] = 10; board_before[3] = 2;   // (0,1) Peaches P2\n    board_before[4] = 2; board_before[5] = 1;    // (0,2) Blushy P1\n    // Row 1: P2 card 11, P2 card 12, P1 card 3\n    board_before[6] = 11; board_before[7] = 2;   // (1,0) Freckles P2\n    board_before[8] = 12; board_before[9] = 2;   // (1,1) Camo P2\n    board_before[10] = 3; board_before[11] = 1;  // (1,2) BiteBug P1\n    // Row 2: P2 card 13, P1 card 5, empty (2,2)\n    board_before[12] = 13; board_before[13] = 2; // (2,0) Neon P2\n    board_before[14] = 5; board_before[15] = 1;  // (2,1) Inkwell P1\n\n    // Scores: P1 has 4 on board + 1 in hand = 5, P2 has 4 on board + 1 in hand = 5\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2; // P2's turn\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    for i in 0..16 {\n        board_after[i] = board_before[i];\n    }\n    // P2 places card 14 (Glow Bug [5,3,3,4]) at (2,2)\n    board_after[16] = 14; board_after[17] = 2;\n\n    // Check captures:\n    // (1,2) BiteBug P1 [1,3,3,5]: placed top=5 vs adj bottom=3 -> 5>3 CAPTURE!\n    board_after[11] = 2; // BiteBug captured by P2\n    // (2,1) Inkwell P1 [2,3,1,5]: placed left=4 vs adj right=3 -> 4>3 CAPTURE!\n    board_after[15] = 2; // Inkwell captured by P2\n\n    // filled=9, p1_board=2, p2_board=7, p1_played=5, p2_played=4\n    // p1_score = 2 + (5-5) = 2, p2_score = 7 + (5-4) = 8\n    let scores_after: [Field; 2] = [2, 8];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 14 (Glow Bug) has nullifier_secret = 1000, move_index = 8 (8 cards on board)\n    let enc_null = p2_encrypt_nullifier(1000, 8);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        1, 2,       // game ended, player 2 wins\n        enc_null,\n        2,          // current_player = P2\n        14,         // card_id = Glow Bug\n        2, 2,       // row=2, col=2\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n        8,          // move_index = 8 (8 cards on board)\n    );\n}\n\n// ====================== FAILURE TESTS ======================\n\n#[test(should_fail_with = \"Cell not empty\")]\nfn test_fail_place_on_occupied_cell() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 10;\n    board_before[1] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,       // (0,0) is occupied\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        1,          // move_index = 1\n    );\n}\n\n#[test(should_fail_with = \"Not this player's turn\")]\nfn test_fail_wrong_player_turn() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1; // P1's turn\n\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 10;\n    board_after[1] = 2;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    let enc_null = p2_encrypt_nullifier(600, 0);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,          // P2 trying to play on P1's turn\n        10,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n        0,          // move_index = 0\n    );\n}\n\n#[test(should_fail_with = \"Row out of bounds\")]\nfn test_fail_row_out_of_bounds() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n    let end_hash = start_hash;\n\n    let enc_null = p1_encrypt_nullifier(100, 0);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        3, 0,       // row=3 out of bounds\n        board_before, board_before,\n        scores_before, scores_before,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        0,          // move_index = 0\n    );\n}\n\n#[test(should_fail_with = \"Placed card not in committed hand\")]\nfn test_fail_card_not_in_hand() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 20;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 0);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 20,      // card 20 not in P1's hand\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        0,          // move_index = 0\n    );\n}\n\n#[test(should_fail_with = \"Player 1 card commit mismatch\")]\nfn test_fail_wrong_player_secret() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 0);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        999,        // WRONG player secret\n        P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        0,          // move_index = 0\n    );\n}\n\n#[test(should_fail_with = \"Non-captured cell owner changed\")]\nfn test_fail_false_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 3; board_after[1] = 1;\n    board_after[2] = 14; board_after[3] = 1;      // FALSE CAPTURE\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(300, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 3,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        1,          // move_index = 1\n    );\n}\n\n#[test(should_fail_with = \"Captured cell owner not updated\")]\nfn test_fail_missing_capture() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 11; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[2] = 11; board_after[3] = 2;      // NOT captured (WRONG!)\n    board_after[8] = 4; board_after[9] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(400, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 4,\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        1,          // move_index = 1\n    );\n}\n\n#[test(should_fail_with = \"Non-placed cell card_id changed\")]\nfn test_fail_card_id_changed() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 14; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 99; board_after[3] = 2;      // card_id CHANGED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        1,          // move_index = 1\n    );\n}\n\n#[test]\nfn test_player2_move_with_capture() {\n    // P2 places card 12 (Camo [7,1,3,1]) at (1,0)\n    // (0,0) has P1 card 1 (Mudwalker [1,4,1,5]).\n    // Placed top=7 vs adj bottom=1 -> 7>1 CAPTURE!\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 2;      // CAPTURED by P2\n    board_after[6] = 12; board_after[7] = 2;\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 12 (Camo) has nullifier_secret = 800, move_index = 1 (1 card on board)\n    let enc_null = p2_encrypt_nullifier(800, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,\n        12,\n        1, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n        1,          // move_index = 1 (1 card on board)\n    );\n}\n\n#[test]\nfn test_equal_ranks_no_capture() {\n    // P1 card 1 Mudwalker right=4 at (0,0), (0,1) has P2 card 10 Peaches left=4.\n    // 4 == 4 -> NO capture.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[2] = 10; board_before[3] = 2;\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;      // NOT captured (equal ranks)\n    let scores_after: [Field; 2] = [5, 5];\n\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 1 (Mudwalker) has nullifier_secret = 100, move_index = 1 (1 card on board)\n    let enc_null = p1_encrypt_nullifier(100, 1);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        1,          // move_index = 1 (1 card on board)\n    );\n}\n\n#[test(should_fail_with = \"Encrypted nullifier mismatch\")]\nfn test_fail_wrong_encrypted_nullifier() {\n    // Correct move but wrong encrypted nullifier\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Use a wrong encrypted nullifier value\n    let wrong_enc_null: Field = 0xdeadbeef;\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        wrong_enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        0,          // move_index = 0\n    );\n}\n\n#[test]\nfn test_ecdh_symmetric_encryption() {\n    // Verify that P1 encrypting with P2's pubkey produces something P2 can decrypt\n    // P1 encrypts: shared = P1_priv * P2_pub\n    // P2 decrypts: shared = P2_priv * P1_pub\n    // Both shared secrets should be equal (ECDH property)\n    let p1_pub = get_p1_pubkey();\n    let p2_pub = get_p2_pubkey();\n\n    let shared_1 = compute_shared_secret(P1_GRUMPKIN_KEY, p2_pub);\n    let shared_2 = compute_shared_secret(P2_GRUMPKIN_KEY, p1_pub);\n    assert(shared_1 == shared_2, \"ECDH shared secrets should match\");\n\n    // Encrypt and verify with nonce\n    let plaintext: Field = 12345;\n    let nonce: Field = 3; // example move index\n    let ciphertext = symmetric_encrypt_field(plaintext, shared_1, nonce);\n    // Decrypt: plaintext = ciphertext - key\n    let key = expand_secret(shared_2, nonce);\n    let decrypted = ciphertext - key;\n    assert(decrypted == plaintext, \"Decrypted value should match plaintext\");\n}\n\n// ====================== C1 FIX TESTS: Exact Score Verification ======================\n\n#[test(should_fail_with = \"P1 score mismatch\")]\nfn test_score_fabrication_rejected() {\n    // Valid first move (P1 places card 1 at (0,0) on empty board) but with fabricated scores.\n    // Correct scores: p1=5, p2=5 (1 on board + 4 in hand, 0 on board + 5 in hand)\n    // Fabricated: p1=8, p2=2 (would pass the old weak check since 8+2=10, 8>=1, 2>=0)\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    // Fabricated scores: should be [5, 5] but attacker claims [8, 2]\n    let scores_after: [Field; 2] = [8, 2];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 0);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        0,          // move_index = 0\n    );\n}\n\n#[test]\nfn test_exact_scores_after_capture() {\n    // P2 places card 13 (Neon [6,2,2,3]) at (0,1).\n    // (0,0) has P1 card 5 (Inkwell [2,3,1,5]). Placed left=3 vs adj right=3 -> NO (equal)\n    // (1,1) has P1 card 1 (Mudwalker [1,4,1,5]). Placed bottom=2 vs adj top=1 -> 2>1 CAPTURE!\n    // After: filled=4, p1_board=1, p2_board=3(card 10 + card 13 + captured card 1)\n    // p1_played=(4+1)/2=2, p2_played=4/2=2\n    // p1_score=1+(5-2)=4, p2_score=3+(5-2)=6\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p1_pubkey = get_p1_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 5; board_before[1] = 1;    // (0,0) Inkwell P1\n    board_before[4] = 10; board_before[5] = 2;   // (0,2) Peaches P2\n    board_before[8] = 1; board_before[9] = 1;    // (1,1) Mudwalker P1\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 2;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 5; board_after[1] = 1;      // (0,0) Inkwell P1 - unchanged\n    board_after[2] = 13; board_after[3] = 2;     // (0,1) Neon P2 - placed\n    board_after[4] = 10; board_after[5] = 2;     // (0,2) Peaches P2 - unchanged\n    board_after[8] = 1; board_after[9] = 2;      // (1,1) Mudwalker CAPTURED by P2\n    // Exact scores: p1_board=1, p2_board=3, p1_hand=3, p2_hand=3\n    let scores_after: [Field; 2] = [4, 6];\n\n    let end_hash = hash_board_state(board_after, scores_after, 1);\n\n    // Card 13 (Neon) has nullifier_secret = 900, move_index = 3 (3 cards on board)\n    let enc_null = p2_encrypt_nullifier(900, 3);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        2,\n        13,\n        0, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P2_SECRET, P2_ADDRESS, TEST_GAME_ID,\n        p2_card_ids(), p2_card_ranks(), p2_nullifier_secrets(),\n        P2_GRUMPKIN_KEY, p1_pubkey.x, p1_pubkey.y,\n        3,          // move_index = 3 (3 cards on board)\n    );\n}\n\n// ====================== C2 FIX TESTS: Card Replay Prevention ======================\n\n#[test(should_fail_with = \"Card already placed on board\")]\nfn test_card_replay_rejected() {\n    // P1 already has card 1 (Mudwalker) on board at (0,0).\n    // P1 tries to place card 1 AGAIN at (1,1). Should be rejected.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 2;\n    board_after[8] = 1; board_after[9] = 1;    // (1,1) card 1 REPLAYED\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,          // card_id = 1 (already on board!)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        2,          // move_index = 2 (2 cards on board)\n    );\n}\n\n#[test]\nfn test_different_card_after_same_id_on_board() {\n    // P1 has card 1 on board. P1 places card 2 (different card). Should succeed.\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let mut board_before: [Field; 18] = [0; 18];\n    board_before[0] = 1; board_before[1] = 1;   // (0,0) card 1, P1\n    board_before[2] = 10; board_before[3] = 2;  // (0,1) card 10, P2\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1; board_after[1] = 1;\n    board_after[2] = 10; board_after[3] = 1;   // (0,1) CAPTURED: Blushy top=5 > Peaches bottom=2\n    board_after[8] = 2; board_after[9] = 1;    // (1,1) card 2, different card\n    // filled=3, p1_board=3, p2_board=0, p1_played=2, p2_played=1\n    // p1_score=3+3=6, p2_score=0+4=4\n    let scores_after: [Field; 2] = [6, 4];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Card 2 (Blushy) has nullifier_secret = 200, move_index = 2 (2 cards on board)\n    let enc_null = p1_encrypt_nullifier(200, 2);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 2,          // card_id = 2 (different, valid)\n        1, 1,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        2,          // move_index = 2 (2 cards on board)\n    );\n}\n\n// ====================== V7 FIX TESTS: move_index nonce + point-at-infinity ======================\n\n#[test(should_fail_with = \"move_index must be 0-8\")]\nfn test_fail_move_index_out_of_range() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 9);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        9,          // move_index = 9 (out of range!)\n    );\n}\n\n#[test(should_fail_with = \"move_index does not match board state\")]\nfn test_fail_move_index_mismatch() {\n    // Empty board but claim move_index = 3 -> should fail\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    // Encrypt with mismatched nonce\n    let enc_null = p1_encrypt_nullifier(100, 3);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        P1_GRUMPKIN_KEY, p2_pubkey.x, p2_pubkey.y,\n        3,          // move_index = 3 but board is empty (should be 0)\n    );\n}\n\n#[test(should_fail_with = \"grumpkin_private_key must be non-zero\")]\nfn test_fail_zero_grumpkin_key_game_move() {\n    let cc1 = get_p1_commit();\n    let cc2 = get_p2_commit();\n    let p2_pubkey = get_p2_pubkey();\n\n    let board_before: [Field; 18] = [0; 18];\n    let scores_before: [Field; 2] = [5, 5];\n    let current_turn_before: Field = 1;\n    let start_hash = hash_board_state(board_before, scores_before, current_turn_before);\n\n    let mut board_after: [Field; 18] = [0; 18];\n    board_after[0] = 1;\n    board_after[1] = 1;\n    let scores_after: [Field; 2] = [5, 5];\n    let end_hash = hash_board_state(board_after, scores_after, 2);\n\n    let enc_null = p1_encrypt_nullifier(100, 0);\n\n    main(\n        cc1, cc2,\n        start_hash, end_hash,\n        0, 0,\n        enc_null,\n        1, 1,\n        0, 0,\n        board_before, board_after,\n        scores_before, scores_after,\n        current_turn_before,\n        P1_SECRET, P1_ADDRESS, TEST_GAME_ID,\n        p1_card_ids(), p1_card_ranks(), p1_nullifier_secrets(),\n        0,          // ZERO grumpkin key - should fail\n        p2_pubkey.x, p2_pubkey.y,\n        0,\n    );\n}\n\n#[test]\nfn test_unique_encryption_per_move_index() {\n    // Verify that different move_index values produce different encrypted values\n    let p2_pub = get_p2_pubkey();\n    let shared = compute_shared_secret(P1_GRUMPKIN_KEY, p2_pub);\n    let plaintext: Field = 12345;\n\n    let enc0 = symmetric_encrypt_field(plaintext, shared, 0);\n    let enc1 = symmetric_encrypt_field(plaintext, shared, 1);\n    let enc2 = symmetric_encrypt_field(plaintext, shared, 2);\n\n    // All should be different (unique nonce -> unique key -> unique ciphertext)\n    assert(enc0 != enc1, \"move_index 0 and 1 should produce different ciphertexts\");\n    assert(enc1 != enc2, \"move_index 1 and 2 should produce different ciphertexts\");\n    assert(enc0 != enc2, \"move_index 0 and 2 should produce different ciphertexts\");\n}\n","path":"/home/ec2-user/aztec-triple-triad/circuits/game_move/src/main.nr"}}}